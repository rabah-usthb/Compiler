2025-04-16 17:12:34:453 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Expr (@ header {
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;
}) (@ members {
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();
}) (RULES (RULE SIGN (RULEMODIFIERS fragment) (BLOCK (ALT '-') (ALT '+'))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INTEGER (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT)))))) (RULE FLOATED (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.'))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE BOOLEANVALUE (BLOCK (ALT 'True' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}) (ALT 'False' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}))) (RULE INPUT (BLOCK (ALT 'input' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Read Function");}))) (RULE OUTPUT (BLOCK (ALT 'output' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Print Function");}))) (RULE TYPE (BLOCK (ALT 'Int' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Float' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Bool' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'String' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Char' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainProgram Header");}))) (RULE VAR (BLOCK (ALT 'Var' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Block Delimiter");}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE END (BLOCK (ALT 'EndPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE IF (BLOCK (ALT 'if' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"If Keyword");}))) (RULE ELSE (BLOCK (ALT 'else' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else Keyword");}))) (RULE ELSIF (BLOCK (ALT 'elsif' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else If Keyword");}))) (RULE THEN (BLOCK (ALT 'then' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Then Keyword");}))) (RULE SWITCH (BLOCK (ALT 'switch' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Switch Keyword");}))) (RULE CASE (BLOCK (ALT 'case' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE BREAK (BLOCK (ALT 'break' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE DEFAULT (BLOCK (ALT 'default' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Default Case Delimiter");}))) (RULE WHILE (BLOCK (ALT 'while' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE DO (BLOCK (ALT 'do' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FOR (BLOCK (ALT 'for' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FROM (BLOCK (ALT 'from' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"From Keyword");}))) (RULE TO (BLOCK (ALT 'to' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"To Keyword");}))) (RULE STEP (BLOCK (ALT 'step' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Step Keyword");}))) (RULE AND (BLOCK (ALT 'AND' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical AND");}))) (RULE OR (BLOCK (ALT 'OR' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical OR");}))) (RULE LET (BLOCK (ALT 'let' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Declarator");}))) (RULE DEFINE (BLOCK (ALT '@define' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE CONST (BLOCK (ALT 'Const' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (? (BLOCK (ALT (* (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {IDF_HashTable.table.insertFirst(getText(),getLine(),getCharPositionInLine());}))) (RULE INT (BLOCK (ALT '(' SIGN INTEGER ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}) (ALT INTEGER {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT '(' SIGN FLOATED ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}) (ALT FLOATED {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {Constant_Hashtable.ConstantTable.insertTable(getText(),"string",getLine(),getCharPositionInLine());}))) (RULE CHAR (BLOCK (ALT '\'' (* (BLOCK (ALT (~ (SET ['\n]))))) '\'' {Constant_Hashtable.ConstantTable.insertTable(getText(),"char",getLine(),getCharPositionInLine());}))) (RULE CONCAT (BLOCK (ALT '.'))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE GREATER (BLOCK (ALT '>'))) (RULE LESSER (BLOCK (ALT '<'))) (RULE GEQ (BLOCK (ALT '>='))) (RULE LEQ (BLOCK (ALT '<='))) (RULE EQ (BLOCK (ALT '=='))) (RULE NEQ (BLOCK (ALT '!='))) (RULE LBRACE (BLOCK (ALT '{'))) (RULE RBRACE (BLOCK (ALT '}'))) (RULE PLUS (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE COM (BLOCK (ALT ','))) (RULE SEMI (BLOCK (ALT ';'))) (RULE LBRACKET (BLOCK (ALT '['))) (RULE RBRACKET (BLOCK (ALT ']'))) (RULE LPAR (BLOCK (ALT '('))) (RULE RPAR (BLOCK (ALT ')'))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE TWOPOINT (BLOCK (ALT ':'))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT))) (LEXER_ACTION_CALL channel HIDDEN)))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT .))) (RULE prog (BLOCK (ALT MAIN IDF ';' varBlock mainCode EOF))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' value ';' {
this.types.add($value.type);
    for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$value.text,types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
        for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
       }))) (RULE number (returns ErrorToken type) (BLOCK (ALT INT { $type = new ErrorToken($INT.text,"INT",$INT.line,$INT.pos); }) (ALT FLOAT { $type = new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos); }))) (RULE arrayDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,this.types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}))) (RULE affectArray (BLOCK (ALT '=' '{' (* (BLOCK (ALT listValue))) '}'))) (RULE declarationKeyword (returns String mul) (BLOCK (ALT DEFINE CONST {$mul = "Constant";}) (ALT LET {$mul = "Variable";}))) (RULE listValue (BLOCK (ALT (= v1 value) {ErrorToken type_1 = $v1.type; type_1.exp = $v1.text; this.types.add(type_1); } (* (BLOCK (ALT ',' (= v value) { ErrorToken type_2 = $v.type; type_2.exp = $v.text; this.types.add(type_2);})))))) (RULE value (returns ErrorToken type) (@ init {this.boolList.clear(); this.compareList.clear(); this.concatList.clear(); this.arithmeticList.clear();}) (BLOCK (ALT var {$type= $var.type;}) (ALT number {$type = $number.type;}) (ALT BOOLEANVALUE {$type = new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos);}) (ALT CHAR {$type = new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos); }) (ALT STRING {$type = new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos);}) (ALT condition {$type = IDF_HashTable.table.conditionType(this.boolList,this.compareList);}) (ALT arithmeticExpression {$type=IDF_HashTable.table.getType(this.arithmeticList,0);}) (ALT concatInst {$type=IDF_HashTable.table.getType(this.concatList,1);}))) (RULE mainCode (BLOCK (ALT BEGIN '{' (+ (BLOCK (ALT inst))) '}' END ';') (ALT BEGIN '{' '}' END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst) (ALT forInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (BLOCK (ALT STRING) (ALT IDF)) ','))) (BLOCK (ALT STRING) (ALT IDF))) (ALT (BLOCK (ALT STRING) (ALT IDF))))) (RULE affectInst (@ init { this.types.clear(); }) (BLOCK (ALT (= var_1 var) AFFECT (= var_2 var) ';' { 
  IDF_HashTable.table.affectMONO($var_2.text,$var_1.type, $var_2.type,$var_1.start.getLine(),$var_1.start.getCharPositionInLine());
}) (ALT var AFFECT value ';' {
 	IDF_HashTable.table.affectEXP($value.text,$var.type, $value.type,$var.start.getLine(),$var.start.getCharPositionInLine());
	
}) (ALT IDF AFFECT '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  IDF_HashTable.table.affectArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos),this.types, $IDF.line,$IDF.pos);
}) (ALT IDF AFFECT '{' '}' ';' {
  IDF_HashTable.table.affectEmptyArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos), $IDF.line,$IDF.pos);
}))) (RULE concatInst (BLOCK (ALT (BLOCK (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));}) (ALT var {this.concatList.add($var.type);})) (+ (BLOCK (ALT '.' (BLOCK (ALT (BLOCK (ALT var {this.concatList.add($var.type);}) (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));})))))))))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression (= op (BLOCK (ALT MUL) (ALT DIV))) (= ari arithmeticExpression) {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}) (ALT arithmeticExpression (BLOCK (ALT PLUS) (ALT SUB)) arithmeticExpression) (ALT operator {this.arithmeticList.add($operator.type);}) (ALT '(' arithmeticExpression ')'))) (RULE operator (returns ErrorToken type) (BLOCK (ALT number {$type = $number.type;}) (ALT var {$type = $var.type;}))) (RULE var (returns ErrorToken type) (BLOCK (ALT IDF {$type = IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos); }) (ALT IDF '[' INT ']' {$type = IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos);}))) (RULE forInst (BLOCK (ALT FOR IDF FROM INT TO INT STEP INT '{' (* (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (* (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (* (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF LPAR condition RPAR THEN '{' (* (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}' elseIfInst) (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT ELSE '{' (* (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseValue (BLOCK (ALT number) (ALT BOOLEANVALUE) (ALT CHAR) (ALT STRING))) (RULE caseInst (BLOCK (ALT CASE caseValue ':' (* (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE caseValue ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (* (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT LPAR condition RPAR) (ALT NOT condition) (ALT condition AND condition) (ALT condition OR condition) (ALT partCondition) (ALT var {this.boolList.add($var.type);}) (ALT BOOLEANVALUE))) (RULE partCondition (BLOCK (ALT arithmeticExpression comparaisonOperator arithmeticExpression {this.compareList.addAll(this.arithmeticList); }))) (RULE comparaisonOperator (BLOCK (ALT EQ) (ALT NEQ) (ALT GREATER) (ALT LESSER) (ALT GEQ) (ALT LEQ)))))
2025-04-16 17:12:34:492 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Expr (@ header {
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;
}) (@ members {
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();
}) (RULES (RULE SIGN (RULEMODIFIERS fragment) (BLOCK (ALT (SET '-' '+')))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INTEGER (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT)))))) (RULE FLOATED (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.'))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE BOOLEANVALUE (BLOCK (ALT 'True' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}) (ALT 'False' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}))) (RULE INPUT (BLOCK (ALT 'input' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Read Function");}))) (RULE OUTPUT (BLOCK (ALT 'output' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Print Function");}))) (RULE TYPE (BLOCK (ALT 'Int' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Float' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Bool' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'String' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Char' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainProgram Header");}))) (RULE VAR (BLOCK (ALT 'Var' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Block Delimiter");}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE END (BLOCK (ALT 'EndPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE IF (BLOCK (ALT 'if' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"If Keyword");}))) (RULE ELSE (BLOCK (ALT 'else' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else Keyword");}))) (RULE ELSIF (BLOCK (ALT 'elsif' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else If Keyword");}))) (RULE THEN (BLOCK (ALT 'then' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Then Keyword");}))) (RULE SWITCH (BLOCK (ALT 'switch' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Switch Keyword");}))) (RULE CASE (BLOCK (ALT 'case' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE BREAK (BLOCK (ALT 'break' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE DEFAULT (BLOCK (ALT 'default' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Default Case Delimiter");}))) (RULE WHILE (BLOCK (ALT 'while' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE DO (BLOCK (ALT 'do' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FOR (BLOCK (ALT 'for' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FROM (BLOCK (ALT 'from' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"From Keyword");}))) (RULE TO (BLOCK (ALT 'to' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"To Keyword");}))) (RULE STEP (BLOCK (ALT 'step' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Step Keyword");}))) (RULE AND (BLOCK (ALT 'AND' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical AND");}))) (RULE OR (BLOCK (ALT 'OR' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical OR");}))) (RULE LET (BLOCK (ALT 'let' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Declarator");}))) (RULE DEFINE (BLOCK (ALT '@define' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE CONST (BLOCK (ALT 'Const' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (? (BLOCK (ALT (* (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {IDF_HashTable.table.insertFirst(getText(),getLine(),getCharPositionInLine());}))) (RULE INT (BLOCK (ALT '(' SIGN INTEGER ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}) (ALT INTEGER {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT '(' SIGN FLOATED ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}) (ALT FLOATED {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {Constant_Hashtable.ConstantTable.insertTable(getText(),"string",getLine(),getCharPositionInLine());}))) (RULE CHAR (BLOCK (ALT '\'' (* (BLOCK (ALT (~ (SET ['\n]))))) '\'' {Constant_Hashtable.ConstantTable.insertTable(getText(),"char",getLine(),getCharPositionInLine());}))) (RULE CONCAT (BLOCK (ALT '.'))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE GREATER (BLOCK (ALT '>'))) (RULE LESSER (BLOCK (ALT '<'))) (RULE GEQ (BLOCK (ALT '>='))) (RULE LEQ (BLOCK (ALT '<='))) (RULE EQ (BLOCK (ALT '=='))) (RULE NEQ (BLOCK (ALT '!='))) (RULE LBRACE (BLOCK (ALT '{'))) (RULE RBRACE (BLOCK (ALT '}'))) (RULE PLUS (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE COM (BLOCK (ALT ','))) (RULE SEMI (BLOCK (ALT ';'))) (RULE LBRACKET (BLOCK (ALT '['))) (RULE RBRACKET (BLOCK (ALT ']'))) (RULE LPAR (BLOCK (ALT '('))) (RULE RPAR (BLOCK (ALT ')'))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE TWOPOINT (BLOCK (ALT ':'))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT))) (LEXER_ACTION_CALL channel HIDDEN)))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT .))) (RULE prog (BLOCK (ALT MAIN IDF ';' varBlock mainCode EOF))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' value ';' {
this.types.add($value.type);
    for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$value.text,types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
        for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
       }))) (RULE number (returns ErrorToken type) (BLOCK (ALT INT { $type = new ErrorToken($INT.text,"INT",$INT.line,$INT.pos); }) (ALT FLOAT { $type = new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos); }))) (RULE arrayDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,this.types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}))) (RULE affectArray (BLOCK (ALT '=' '{' (* (BLOCK (ALT listValue))) '}'))) (RULE declarationKeyword (returns String mul) (BLOCK (ALT DEFINE CONST {$mul = "Constant";}) (ALT LET {$mul = "Variable";}))) (RULE listValue (BLOCK (ALT (= v1 value) {ErrorToken type_1 = $v1.type; type_1.exp = $v1.text; this.types.add(type_1); } (* (BLOCK (ALT ',' (= v value) { ErrorToken type_2 = $v.type; type_2.exp = $v.text; this.types.add(type_2);})))))) (RULE value (returns ErrorToken type) (@ init {this.boolList.clear(); this.compareList.clear(); this.concatList.clear(); this.arithmeticList.clear();}) (BLOCK (ALT var {$type= $var.type;}) (ALT number {$type = $number.type;}) (ALT BOOLEANVALUE {$type = new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos);}) (ALT CHAR {$type = new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos); }) (ALT STRING {$type = new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos);}) (ALT condition {$type = IDF_HashTable.table.conditionType(this.boolList,this.compareList);}) (ALT arithmeticExpression {$type=IDF_HashTable.table.getType(this.arithmeticList,0);}) (ALT concatInst {$type=IDF_HashTable.table.getType(this.concatList,1);}))) (RULE mainCode (BLOCK (ALT BEGIN '{' (+ (BLOCK (ALT inst))) '}' END ';') (ALT BEGIN '{' '}' END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst) (ALT forInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (@ init { this.types.clear(); }) (BLOCK (ALT (= var_1 var) AFFECT (= var_2 var) ';' { 
  IDF_HashTable.table.affectMONO($var_2.text,$var_1.type, $var_2.type,$var_1.start.getLine(),$var_1.start.getCharPositionInLine());
}) (ALT var AFFECT value ';' {
 	IDF_HashTable.table.affectEXP($value.text,$var.type, $value.type,$var.start.getLine(),$var.start.getCharPositionInLine());
	
}) (ALT IDF AFFECT '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  IDF_HashTable.table.affectArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos),this.types, $IDF.line,$IDF.pos);
}) (ALT IDF AFFECT '{' '}' ';' {
  IDF_HashTable.table.affectEmptyArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos), $IDF.line,$IDF.pos);
}))) (RULE concatInst (BLOCK (ALT (BLOCK (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));}) (ALT var {this.concatList.add($var.type);})) (+ (BLOCK (ALT '.' (BLOCK (ALT (BLOCK (ALT var {this.concatList.add($var.type);}) (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));})))))))))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression (= op (SET MUL DIV)) (= ari arithmeticExpression) {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}) (ALT arithmeticExpression (SET PLUS SUB) arithmeticExpression) (ALT operator {this.arithmeticList.add($operator.type);}) (ALT '(' arithmeticExpression ')'))) (RULE operator (returns ErrorToken type) (BLOCK (ALT number {$type = $number.type;}) (ALT var {$type = $var.type;}))) (RULE var (returns ErrorToken type) (BLOCK (ALT IDF {$type = IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos); }) (ALT IDF '[' INT ']' {$type = IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos);}))) (RULE forInst (BLOCK (ALT FOR IDF FROM INT TO INT STEP INT '{' (* (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (* (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (* (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF LPAR condition RPAR THEN '{' (* (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}' elseIfInst) (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT ELSE '{' (* (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseValue (BLOCK (ALT number) (ALT BOOLEANVALUE) (ALT CHAR) (ALT STRING))) (RULE caseInst (BLOCK (ALT CASE caseValue ':' (* (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE caseValue ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (* (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT LPAR condition RPAR) (ALT NOT condition) (ALT condition AND condition) (ALT condition OR condition) (ALT partCondition) (ALT var {this.boolList.add($var.type);}) (ALT BOOLEANVALUE))) (RULE partCondition (BLOCK (ALT arithmeticExpression comparaisonOperator arithmeticExpression {this.compareList.addAll(this.arithmeticList); }))) (RULE comparaisonOperator (BLOCK (ALT (SET EQ NEQ GREATER LESSER GEQ LEQ))))))
2025-04-16 17:12:34:538 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Expr (@ header {
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;
}) (@ members {
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();
}) (RULES (RULE prog (BLOCK (ALT MAIN IDF ';' varBlock mainCode EOF))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' value ';' {
this.types.add($value.type);
    for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$value.text,types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
        for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
       }))) (RULE number (returns ErrorToken type) (BLOCK (ALT INT { $type = new ErrorToken($INT.text,"INT",$INT.line,$INT.pos); }) (ALT FLOAT { $type = new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos); }))) (RULE arrayDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,this.types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}))) (RULE affectArray (BLOCK (ALT '=' '{' (* (BLOCK (ALT listValue))) '}'))) (RULE declarationKeyword (returns String mul) (BLOCK (ALT DEFINE CONST {$mul = "Constant";}) (ALT LET {$mul = "Variable";}))) (RULE listValue (BLOCK (ALT (= v1 value) {ErrorToken type_1 = $v1.type; type_1.exp = $v1.text; this.types.add(type_1); } (* (BLOCK (ALT ',' (= v value) { ErrorToken type_2 = $v.type; type_2.exp = $v.text; this.types.add(type_2);})))))) (RULE value (returns ErrorToken type) (@ init {this.boolList.clear(); this.compareList.clear(); this.concatList.clear(); this.arithmeticList.clear();}) (BLOCK (ALT var {$type= $var.type;}) (ALT number {$type = $number.type;}) (ALT BOOLEANVALUE {$type = new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos);}) (ALT CHAR {$type = new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos); }) (ALT STRING {$type = new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos);}) (ALT condition {$type = IDF_HashTable.table.conditionType(this.boolList,this.compareList);}) (ALT arithmeticExpression {$type=IDF_HashTable.table.getType(this.arithmeticList,0);}) (ALT concatInst {$type=IDF_HashTable.table.getType(this.concatList,1);}))) (RULE mainCode (BLOCK (ALT BEGIN '{' (+ (BLOCK (ALT inst))) '}' END ';') (ALT BEGIN '{' '}' END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst) (ALT forInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (@ init { this.types.clear(); }) (BLOCK (ALT (= var_1 var) AFFECT (= var_2 var) ';' { 
  IDF_HashTable.table.affectMONO($var_2.text,$var_1.type, $var_2.type,$var_1.start.getLine(),$var_1.start.getCharPositionInLine());
}) (ALT var AFFECT value ';' {
 	IDF_HashTable.table.affectEXP($value.text,$var.type, $value.type,$var.start.getLine(),$var.start.getCharPositionInLine());
	
}) (ALT IDF AFFECT '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  IDF_HashTable.table.affectArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos),this.types, $IDF.line,$IDF.pos);
}) (ALT IDF AFFECT '{' '}' ';' {
  IDF_HashTable.table.affectEmptyArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos), $IDF.line,$IDF.pos);
}))) (RULE concatInst (BLOCK (ALT (BLOCK (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));}) (ALT var {this.concatList.add($var.type);})) (+ (BLOCK (ALT '.' (BLOCK (ALT (BLOCK (ALT var {this.concatList.add($var.type);}) (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));})))))))))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression (= op (SET MUL DIV)) (= ari arithmeticExpression) {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}) (ALT arithmeticExpression (SET PLUS SUB) arithmeticExpression) (ALT operator {this.arithmeticList.add($operator.type);}) (ALT '(' arithmeticExpression ')'))) (RULE operator (returns ErrorToken type) (BLOCK (ALT number {$type = $number.type;}) (ALT var {$type = $var.type;}))) (RULE var (returns ErrorToken type) (BLOCK (ALT IDF {$type = IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos); }) (ALT IDF '[' INT ']' {$type = IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos);}))) (RULE forInst (BLOCK (ALT FOR IDF FROM INT TO INT STEP INT '{' (* (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (* (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (* (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF LPAR condition RPAR THEN '{' (* (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}' elseIfInst) (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT ELSE '{' (* (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseValue (BLOCK (ALT number) (ALT BOOLEANVALUE) (ALT CHAR) (ALT STRING))) (RULE caseInst (BLOCK (ALT CASE caseValue ':' (* (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE caseValue ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (* (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT LPAR condition RPAR) (ALT NOT condition) (ALT condition AND condition) (ALT condition OR condition) (ALT partCondition) (ALT var {this.boolList.add($var.type);}) (ALT BOOLEANVALUE))) (RULE partCondition (BLOCK (ALT arithmeticExpression comparaisonOperator arithmeticExpression {this.compareList.addAll(this.arithmeticList); }))) (RULE comparaisonOperator (BLOCK (ALT (SET EQ NEQ GREATER LESSER GEQ LEQ))))))
2025-04-16 17:12:34:538 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR ExprLexer (@ header {
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;
}) (@ members {
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();
}) (RULES (RULE SIGN (RULEMODIFIERS fragment) (BLOCK (ALT (SET '-' '+')))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INTEGER (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT)))))) (RULE FLOATED (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.'))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE BOOLEANVALUE (BLOCK (ALT 'True' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}) (ALT 'False' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}))) (RULE INPUT (BLOCK (ALT 'input' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Read Function");}))) (RULE OUTPUT (BLOCK (ALT 'output' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Print Function");}))) (RULE TYPE (BLOCK (ALT 'Int' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Float' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Bool' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'String' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Char' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainProgram Header");}))) (RULE VAR (BLOCK (ALT 'Var' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Block Delimiter");}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE END (BLOCK (ALT 'EndPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE IF (BLOCK (ALT 'if' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"If Keyword");}))) (RULE ELSE (BLOCK (ALT 'else' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else Keyword");}))) (RULE ELSIF (BLOCK (ALT 'elsif' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else If Keyword");}))) (RULE THEN (BLOCK (ALT 'then' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Then Keyword");}))) (RULE SWITCH (BLOCK (ALT 'switch' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Switch Keyword");}))) (RULE CASE (BLOCK (ALT 'case' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE BREAK (BLOCK (ALT 'break' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE DEFAULT (BLOCK (ALT 'default' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Default Case Delimiter");}))) (RULE WHILE (BLOCK (ALT 'while' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE DO (BLOCK (ALT 'do' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FOR (BLOCK (ALT 'for' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FROM (BLOCK (ALT 'from' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"From Keyword");}))) (RULE TO (BLOCK (ALT 'to' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"To Keyword");}))) (RULE STEP (BLOCK (ALT 'step' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Step Keyword");}))) (RULE AND (BLOCK (ALT 'AND' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical AND");}))) (RULE OR (BLOCK (ALT 'OR' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical OR");}))) (RULE LET (BLOCK (ALT 'let' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Declarator");}))) (RULE DEFINE (BLOCK (ALT '@define' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE CONST (BLOCK (ALT 'Const' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (? (BLOCK (ALT (* (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {IDF_HashTable.table.insertFirst(getText(),getLine(),getCharPositionInLine());}))) (RULE INT (BLOCK (ALT '(' SIGN INTEGER ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}) (ALT INTEGER {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT '(' SIGN FLOATED ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}) (ALT FLOATED {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {Constant_Hashtable.ConstantTable.insertTable(getText(),"string",getLine(),getCharPositionInLine());}))) (RULE CHAR (BLOCK (ALT '\'' (* (BLOCK (ALT (~ (SET ['\n]))))) '\'' {Constant_Hashtable.ConstantTable.insertTable(getText(),"char",getLine(),getCharPositionInLine());}))) (RULE CONCAT (BLOCK (ALT '.'))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE GREATER (BLOCK (ALT '>'))) (RULE LESSER (BLOCK (ALT '<'))) (RULE GEQ (BLOCK (ALT '>='))) (RULE LEQ (BLOCK (ALT '<='))) (RULE EQ (BLOCK (ALT '=='))) (RULE NEQ (BLOCK (ALT '!='))) (RULE LBRACE (BLOCK (ALT '{'))) (RULE RBRACE (BLOCK (ALT '}'))) (RULE PLUS (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE COM (BLOCK (ALT ','))) (RULE SEMI (BLOCK (ALT ';'))) (RULE LBRACKET (BLOCK (ALT '['))) (RULE RBRACKET (BLOCK (ALT ']'))) (RULE LPAR (BLOCK (ALT '('))) (RULE RPAR (BLOCK (ALT ')'))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE TWOPOINT (BLOCK (ALT ':'))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT))) (LEXER_ACTION_CALL channel HIDDEN)))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT .)))))
2025-04-16 17:12:34:828 action-translator LogManager.java:25 translate 
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();

2025-04-16 17:12:34:828 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;

2025-04-16 17:12:34:852 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");
2025-04-16 17:12:34:852 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");
2025-04-16 17:12:34:853 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Read Function");
2025-04-16 17:12:34:853 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Print Function");
2025-04-16 17:12:34:853 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-16 17:12:34:853 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-16 17:12:34:853 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-16 17:12:34:853 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-16 17:12:34:853 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-16 17:12:34:853 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainProgram Header");
2025-04-16 17:12:34:853 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Block Delimiter");
2025-04-16 17:12:34:854 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");
2025-04-16 17:12:34:854 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");
2025-04-16 17:12:34:854 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"If Keyword");
2025-04-16 17:12:34:854 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else Keyword");
2025-04-16 17:12:34:854 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else If Keyword");
2025-04-16 17:12:34:854 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Then Keyword");
2025-04-16 17:12:34:854 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Switch Keyword");
2025-04-16 17:12:34:854 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");
2025-04-16 17:12:34:854 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");
2025-04-16 17:12:34:854 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Default Case Delimiter");
2025-04-16 17:12:34:855 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");
2025-04-16 17:12:34:855 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");
2025-04-16 17:12:34:855 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");
2025-04-16 17:12:34:855 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"From Keyword");
2025-04-16 17:12:34:855 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"To Keyword");
2025-04-16 17:12:34:855 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Step Keyword");
2025-04-16 17:12:34:855 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical AND");
2025-04-16 17:12:34:855 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical OR");
2025-04-16 17:12:34:855 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Declarator");
2025-04-16 17:12:34:855 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");
2025-04-16 17:12:34:855 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");
2025-04-16 17:12:34:855 action-translator LogManager.java:25 translate IDF_HashTable.table.insertFirst(getText(),getLine(),getCharPositionInLine());
2025-04-16 17:12:34:856 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());
2025-04-16 17:12:34:856 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());
2025-04-16 17:12:34:856 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());
2025-04-16 17:12:34:856 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());
2025-04-16 17:12:34:856 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"string",getLine(),getCharPositionInLine());
2025-04-16 17:12:34:856 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"char",getLine(),getCharPositionInLine());
2025-04-16 17:12:34:970 left-recursion LogManager.java:25 arithmeticExpression
    :   ( {} operator<tokenIndex=1189> {this.arithmeticList.add($operator.type);} 
        | '('<tokenIndex=1194> arithmeticExpression<tokenIndex=1196> ')'<tokenIndex=1198> 
        )
        (
          {precpred(_ctx, 4)}?<p=4> op=(MUL<tokenIndex=1161> | DIV<tokenIndex=1165>) ari=arithmeticExpression<tokenIndex=1170,p=5>  {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}
                  | {precpred(_ctx, 3)}?<p=3> (PLUS<tokenIndex=1179>| SUB<tokenIndex=1182>) arithmeticExpression<tokenIndex=1185,p=4>
        )*
    ;
2025-04-16 17:12:34:978 grammar LogManager.java:25 added: (RULE arithmeticExpression (BLOCK (ALT (BLOCK (ALT {} (operator (ELEMENT_OPTIONS (= tokenIndex 1189))) {this.arithmeticList.add($operator.type);}) (ALT ('(' (ELEMENT_OPTIONS (= tokenIndex 1194))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 1196))) (')' (ELEMENT_OPTIONS (= tokenIndex 1198))))) (* (BLOCK (ALT ({precpred(_ctx, 4)}? (ELEMENT_OPTIONS (= p 4))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 1161))) (DIV (ELEMENT_OPTIONS (= tokenIndex 1165))))) (= ari (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 1170) (= p 5)))) {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}) (ALT ({precpred(_ctx, 3)}? (ELEMENT_OPTIONS (= p 3))) (SET (PLUS (ELEMENT_OPTIONS (= tokenIndex 1179))) (SUB (ELEMENT_OPTIONS (= tokenIndex 1182)))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 1185) (= p 4)))))))))
2025-04-16 17:12:34:983 left-recursion LogManager.java:25 condition
    :   ( {} LPAR<tokenIndex=1482> condition<tokenIndex=1484> RPAR<tokenIndex=1486> 
        | NOT<tokenIndex=1489> condition<tokenIndex=1491,p=6> 
        | partCondition<tokenIndex=1509> 
        | var<tokenIndex=1512> {this.boolList.add($var.type);} 
        | BOOLEANVALUE<tokenIndex=1518> 
        )
        (
          {precpred(_ctx, 5)}?<p=5> AND<tokenIndex=1497> condition<tokenIndex=1499,p=6>
                  | {precpred(_ctx, 4)}?<p=4> OR<tokenIndex=1504> condition<tokenIndex=1506,p=5>
        )*
    ;
2025-04-16 17:12:34:987 grammar LogManager.java:25 added: (RULE condition (BLOCK (ALT (BLOCK (ALT {} (LPAR (ELEMENT_OPTIONS (= tokenIndex 1482))) (condition (ELEMENT_OPTIONS (= tokenIndex 1484))) (RPAR (ELEMENT_OPTIONS (= tokenIndex 1486)))) (ALT (NOT (ELEMENT_OPTIONS (= tokenIndex 1489))) (condition (ELEMENT_OPTIONS (= tokenIndex 1491) (= p 6)))) (ALT (partCondition (ELEMENT_OPTIONS (= tokenIndex 1509)))) (ALT (var (ELEMENT_OPTIONS (= tokenIndex 1512))) {this.boolList.add($var.type);}) (ALT (BOOLEANVALUE (ELEMENT_OPTIONS (= tokenIndex 1518))))) (* (BLOCK (ALT ({precpred(_ctx, 5)}? (ELEMENT_OPTIONS (= p 5))) (AND (ELEMENT_OPTIONS (= tokenIndex 1497))) (condition (ELEMENT_OPTIONS (= tokenIndex 1499) (= p 6)))) (ALT ({precpred(_ctx, 4)}? (ELEMENT_OPTIONS (= p 4))) (OR (ELEMENT_OPTIONS (= tokenIndex 1504))) (condition (ELEMENT_OPTIONS (= tokenIndex 1506) (= p 5)))))))))
2025-04-16 17:12:34:992 semantics LogManager.java:25 tokens={EOF=-1, BOOLEANVALUE=1, INPUT=2, OUTPUT=3, TYPE=4, MAIN=5, VAR=6, BEGIN=7, END=8, IF=9, ELSE=10, ELSIF=11, THEN=12, SWITCH=13, CASE=14, BREAK=15, DEFAULT=16, WHILE=17, DO=18, FOR=19, FROM=20, TO=21, STEP=22, AND=23, OR=24, LET=25, DEFINE=26, CONST=27, IDF=28, INT=29, FLOAT=30, STRING=31, CHAR=32, CONCAT=33, AFFECT=34, NOT=35, GREATER=36, LESSER=37, GEQ=38, LEQ=39, EQ=40, NEQ=41, LBRACE=42, RBRACE=43, PLUS=44, SUB=45, MUL=46, DIV=47, COM=48, SEMI=49, LBRACKET=50, RBRACKET=51, LPAR=52, RPAR=53, ASSIGN=54, TWOPOINT=55, COMMENT=56, WS=57, ERROR_TOKEN=58}
2025-04-16 17:12:34:992 semantics LogManager.java:25 strings={'input'=2, 'output'=3, 'MainPrgm'=5, 'Var'=6, 'BeginPg'=7, 'EndPg'=8, 'if'=9, 'else'=10, 'elsif'=11, 'then'=12, 'switch'=13, 'case'=14, 'break'=15, 'default'=16, 'while'=17, 'do'=18, 'for'=19, 'from'=20, 'to'=21, 'step'=22, 'AND'=23, 'OR'=24, 'let'=25, '@define'=26, 'Const'=27, '.'=33, ':='=34, '!'=35, '>'=36, '<'=37, '>='=38, '<='=39, '=='=40, '!='=41, '{'=42, '}'=43, '+'=44, '-'=45, '*'=46, '/'=47, ','=48, ';'=49, '['=50, ']'=51, '('=52, ')'=53, '='=54, ':'=55}
2025-04-16 17:12:35:020 LL1 LogManager.java:25 
DECISION 0 in rule varBlock
2025-04-16 17:12:35:021 LL1 LogManager.java:25 look=[{25..26}, 7]
2025-04-16 17:12:35:021 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:021 LL1 LogManager.java:25 
DECISION 1 in rule varBlock
2025-04-16 17:12:35:021 LL1 LogManager.java:25 look=[6, 6]
2025-04-16 17:12:35:021 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:021 LL1 LogManager.java:25 
DECISION 2 in rule declaration
2025-04-16 17:12:35:021 LL1 LogManager.java:25 look=[{25..26}, {25..26}]
2025-04-16 17:12:35:021 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:021 LL1 LogManager.java:25 
DECISION 3 in rule listIDF
2025-04-16 17:12:35:021 LL1 LogManager.java:25 look=[48, {53, 55}]
2025-04-16 17:12:35:022 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:022 LL1 LogManager.java:25 
DECISION 4 in rule normalDeclaration
2025-04-16 17:12:35:022 LL1 LogManager.java:25 look=[{25..26}, {25..26}]
2025-04-16 17:12:35:022 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:022 LL1 LogManager.java:25 
DECISION 5 in rule number
2025-04-16 17:12:35:022 LL1 LogManager.java:25 look=[29, 30]
2025-04-16 17:12:35:022 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:022 LL1 LogManager.java:25 
DECISION 6 in rule arrayDeclaration
2025-04-16 17:12:35:022 LL1 LogManager.java:25 look=[{1, 28..32, 35, 52}, 43]
2025-04-16 17:12:35:022 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:022 LL1 LogManager.java:25 
DECISION 7 in rule arrayDeclaration
2025-04-16 17:12:35:022 LL1 LogManager.java:25 look=[{25..26}, {25..26}, {25..26}]
2025-04-16 17:12:35:022 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:022 LL1 LogManager.java:25 
DECISION 8 in rule affectArray
2025-04-16 17:12:35:022 LL1 LogManager.java:25 look=[{1, 28..32, 35, 52}, 43]
2025-04-16 17:12:35:022 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:022 LL1 LogManager.java:25 
DECISION 9 in rule declarationKeyword
2025-04-16 17:12:35:022 LL1 LogManager.java:25 look=[26, 25]
2025-04-16 17:12:35:022 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:022 LL1 LogManager.java:25 
DECISION 10 in rule listValue
2025-04-16 17:12:35:023 LL1 LogManager.java:25 look=[48, {1, 28..32, 35, 43, 52}]
2025-04-16 17:12:35:023 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:023 LL1 LogManager.java:25 
DECISION 11 in rule value
2025-04-16 17:12:35:023 LL1 LogManager.java:25 look=[28, {29..30}, 1, 32, 31, {1, 28..30, 35, 52}, {28..30, 52}, {28, 31..32}]
2025-04-16 17:12:35:023 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:023 LL1 LogManager.java:25 
DECISION 12 in rule mainCode
2025-04-16 17:12:35:023 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 17:12:35:023 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:023 LL1 LogManager.java:25 
DECISION 13 in rule mainCode
2025-04-16 17:12:35:023 LL1 LogManager.java:25 look=[7, 7]
2025-04-16 17:12:35:024 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:024 LL1 LogManager.java:25 
DECISION 14 in rule inst
2025-04-16 17:12:35:024 LL1 LogManager.java:25 look=[3, 2, 28, 18, 17, 9, 13, 19]
2025-04-16 17:12:35:024 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:024 LL1 LogManager.java:25 
DECISION 15 in rule content
2025-04-16 17:12:35:024 LL1 LogManager.java:25 look=[{28, 31}, {28, 31}]
2025-04-16 17:12:35:024 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:024 LL1 LogManager.java:25 
DECISION 16 in rule content
2025-04-16 17:12:35:024 LL1 LogManager.java:25 look=[{28, 31}, {28, 31}]
2025-04-16 17:12:35:024 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:024 LL1 LogManager.java:25 
DECISION 17 in rule affectInst
2025-04-16 17:12:35:024 LL1 LogManager.java:25 look=[{1, 28..32, 35, 52}, 43]
2025-04-16 17:12:35:024 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:024 LL1 LogManager.java:25 
DECISION 18 in rule affectInst
2025-04-16 17:12:35:024 LL1 LogManager.java:25 look=[28, 28, 28, 28]
2025-04-16 17:12:35:024 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:024 LL1 LogManager.java:25 
DECISION 19 in rule concatInst
2025-04-16 17:12:35:024 LL1 LogManager.java:25 look=[31, 32, 28]
2025-04-16 17:12:35:024 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:024 LL1 LogManager.java:25 
DECISION 20 in rule concatInst
2025-04-16 17:12:35:024 LL1 LogManager.java:25 look=[28, 31, 32]
2025-04-16 17:12:35:024 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:024 LL1 LogManager.java:25 
DECISION 21 in rule concatInst
2025-04-16 17:12:35:025 LL1 LogManager.java:25 look=[33, {1, 28..32, 35, 43, 48..49, 52}]
2025-04-16 17:12:35:025 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:025 LL1 LogManager.java:25 
DECISION 22 in rule arithmeticExpression
2025-04-16 17:12:35:025 LL1 LogManager.java:25 look=[{28..30}, 52]
2025-04-16 17:12:35:025 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:025 LL1 LogManager.java:25 
DECISION 23 in rule arithmeticExpression
2025-04-16 17:12:35:025 LL1 LogManager.java:25 look=[null, null]
2025-04-16 17:12:35:025 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:025 LL1 LogManager.java:25 
DECISION 24 in rule arithmeticExpression
2025-04-16 17:12:35:026 LL1 LogManager.java:25 look=[null, null]
2025-04-16 17:12:35:026 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:026 LL1 LogManager.java:25 
DECISION 25 in rule operator
2025-04-16 17:12:35:026 LL1 LogManager.java:25 look=[{29..30}, 28]
2025-04-16 17:12:35:026 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:026 LL1 LogManager.java:25 
DECISION 26 in rule var
2025-04-16 17:12:35:026 LL1 LogManager.java:25 look=[28, 28]
2025-04-16 17:12:35:026 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:026 LL1 LogManager.java:25 
DECISION 27 in rule forInst
2025-04-16 17:12:35:026 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 17:12:35:026 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:026 LL1 LogManager.java:25 
DECISION 28 in rule doWhileInst
2025-04-16 17:12:35:026 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 17:12:35:026 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:026 LL1 LogManager.java:25 
DECISION 29 in rule whileInst
2025-04-16 17:12:35:026 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 17:12:35:026 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:026 LL1 LogManager.java:25 
DECISION 30 in rule ifInst
2025-04-16 17:12:35:027 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 17:12:35:027 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:027 LL1 LogManager.java:25 
DECISION 31 in rule ifInst
2025-04-16 17:12:35:027 LL1 LogManager.java:25 look=[11, {2..3, 9..10, 13, 15, 17..19, 28, 43}]
2025-04-16 17:12:35:027 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:027 LL1 LogManager.java:25 
DECISION 32 in rule ifInst
2025-04-16 17:12:35:028 LL1 LogManager.java:25 look=[10, {2..3, 9, 13, 15, 17..19, 28, 43}]
2025-04-16 17:12:35:028 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:028 LL1 LogManager.java:25 
DECISION 33 in rule elseIfInst
2025-04-16 17:12:35:028 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 17:12:35:028 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:028 LL1 LogManager.java:25 
DECISION 34 in rule elseIfInst
2025-04-16 17:12:35:028 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 17:12:35:028 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:028 LL1 LogManager.java:25 
DECISION 35 in rule elseIfInst
2025-04-16 17:12:35:029 LL1 LogManager.java:25 look=[11, 11]
2025-04-16 17:12:35:029 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:029 LL1 LogManager.java:25 
DECISION 36 in rule elseInst
2025-04-16 17:12:35:029 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 17:12:35:029 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:029 LL1 LogManager.java:25 
DECISION 37 in rule caseValue
2025-04-16 17:12:35:029 LL1 LogManager.java:25 look=[{29..30}, 1, 32, 31]
2025-04-16 17:12:35:029 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:029 LL1 LogManager.java:25 
DECISION 38 in rule caseInst
2025-04-16 17:12:35:029 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 15]
2025-04-16 17:12:35:029 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:029 LL1 LogManager.java:25 
DECISION 39 in rule caseInst
2025-04-16 17:12:35:030 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 15]
2025-04-16 17:12:35:030 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:030 LL1 LogManager.java:25 
DECISION 40 in rule caseInst
2025-04-16 17:12:35:030 LL1 LogManager.java:25 look=[14, 14]
2025-04-16 17:12:35:030 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:030 LL1 LogManager.java:25 
DECISION 41 in rule defaultInst
2025-04-16 17:12:35:030 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 15]
2025-04-16 17:12:35:030 LL1 LogManager.java:25 LL(1)? true
2025-04-16 17:12:35:030 LL1 LogManager.java:25 
DECISION 42 in rule condition
2025-04-16 17:12:35:030 LL1 LogManager.java:25 look=[52, 35, {28..30, 52}, 28, 1]
2025-04-16 17:12:35:030 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:030 LL1 LogManager.java:25 
DECISION 43 in rule condition
2025-04-16 17:12:35:030 LL1 LogManager.java:25 look=[null, null]
2025-04-16 17:12:35:030 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:030 LL1 LogManager.java:25 
DECISION 44 in rule condition
2025-04-16 17:12:35:030 LL1 LogManager.java:25 look=[null, null]
2025-04-16 17:12:35:030 LL1 LogManager.java:25 LL(1)? false
2025-04-16 17:12:35:034 action-translator LogManager.java:25 translate 
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();

2025-04-16 17:12:35:035 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;

2025-04-16 17:12:35:056 action-translator LogManager.java:25 translate types.clear();
2025-04-16 17:12:35:057 action-translator LogManager.java:25 translate 
this.types.add($value.type);
    for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$value.text,types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }

2025-04-16 17:12:35:057 action-translator LogManager.java:25 qattr [@-1,18:22='value',<0>,120:16].[@-1,24:27='type',<0>,120:22]
2025-04-16 17:12:35:058 action-translator LogManager.java:25 qattr [@-1,52:58='listIDF',<0>,121:20].[@-1,60:62='ctx',<0>,121:28]
2025-04-16 17:12:35:059 action-translator LogManager.java:25 qattr [@-1,144:161='declarationKeyword',<0>,122:60].[@-1,163:165='mul',<0>,122:79]
2025-04-16 17:12:35:059 action-translator LogManager.java:25 qattr [@-1,169:172='TYPE',<0>,122:85].[@-1,174:177='text',<0>,122:90]
2025-04-16 17:12:35:060 action-translator LogManager.java:25 qattr [@-1,180:184='value',<0>,122:96].[@-1,186:189='text',<0>,122:102]
2025-04-16 17:12:35:060 action-translator LogManager.java:25 translate 
        for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
       
2025-04-16 17:12:35:061 action-translator LogManager.java:25 qattr [@-1,26:32='listIDF',<0>,128:24].[@-1,34:36='ctx',<0>,128:32]
2025-04-16 17:12:35:061 action-translator LogManager.java:25 qattr [@-1,113:130='declarationKeyword',<0>,129:55].[@-1,132:134='mul',<0>,129:74]
2025-04-16 17:12:35:061 action-translator LogManager.java:25 qattr [@-1,138:141='TYPE',<0>,129:80].[@-1,143:146='text',<0>,129:85]
2025-04-16 17:12:35:061 action-translator LogManager.java:25 translate  $type = new ErrorToken($INT.text,"INT",$INT.line,$INT.pos); 
2025-04-16 17:12:35:062 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,134:41] [@-1,8:58=' new ErrorToken($INT.text,"INT",$INT.line,$INT.pos)',<0>,134:47]
2025-04-16 17:12:35:062 action-translator LogManager.java:25 translate  new ErrorToken($INT.text,"INT",$INT.line,$INT.pos)
2025-04-16 17:12:35:062 action-translator LogManager.java:25 qattr [@-1,17:19='INT',<0>,134:56].[@-1,21:24='text',<0>,134:60]
2025-04-16 17:12:35:062 action-translator LogManager.java:25 qattr [@-1,33:35='INT',<0>,134:72].[@-1,37:40='line',<0>,134:76]
2025-04-16 17:12:35:063 action-translator LogManager.java:25 qattr [@-1,43:45='INT',<0>,134:82].[@-1,47:49='pos',<0>,134:86]
2025-04-16 17:12:35:064 action-translator LogManager.java:25 translate  $type = new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos); 
2025-04-16 17:12:35:064 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,134:115] [@-1,8:66=' new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos)',<0>,134:121]
2025-04-16 17:12:35:064 action-translator LogManager.java:25 translate  new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos)
2025-04-16 17:12:35:064 action-translator LogManager.java:25 qattr [@-1,17:21='FLOAT',<0>,134:130].[@-1,23:26='text',<0>,134:136]
2025-04-16 17:12:35:064 action-translator LogManager.java:25 qattr [@-1,37:41='FLOAT',<0>,134:150].[@-1,43:46='line',<0>,134:156]
2025-04-16 17:12:35:064 action-translator LogManager.java:25 qattr [@-1,49:53='FLOAT',<0>,134:162].[@-1,55:57='pos',<0>,134:168]
2025-04-16 17:12:35:072 action-translator LogManager.java:25 translate types.clear();
2025-04-16 17:12:35:073 action-translator LogManager.java:25 translate 
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }

2025-04-16 17:12:35:073 action-translator LogManager.java:25 qattr [@-1,20:26='listIDF',<0>,137:18].[@-1,28:30='ctx',<0>,137:26]
2025-04-16 17:12:35:073 action-translator LogManager.java:25 qattr [@-1,116:133='declarationKeyword',<0>,138:64].[@-1,135:137='mul',<0>,138:83]
2025-04-16 17:12:35:073 action-translator LogManager.java:25 qattr [@-1,141:144='TYPE',<0>,138:89].[@-1,146:149='text',<0>,138:94]
2025-04-16 17:12:35:073 action-translator LogManager.java:25 qattr [@-1,152:154='INT',<0>,138:100].[@-1,156:159='text',<0>,138:104]
2025-04-16 17:12:35:074 action-translator LogManager.java:25 translate 
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,this.types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }

2025-04-16 17:12:35:074 action-translator LogManager.java:25 qattr [@-1,20:26='listIDF',<0>,143:18].[@-1,28:30='ctx',<0>,143:26]
2025-04-16 17:12:35:074 action-translator LogManager.java:25 qattr [@-1,116:133='declarationKeyword',<0>,144:64].[@-1,135:137='mul',<0>,144:83]
2025-04-16 17:12:35:075 action-translator LogManager.java:25 qattr [@-1,141:144='TYPE',<0>,144:89].[@-1,146:149='text',<0>,144:94]
2025-04-16 17:12:35:075 action-translator LogManager.java:25 qattr [@-1,152:154='INT',<0>,144:100].[@-1,156:159='text',<0>,144:104]
2025-04-16 17:12:35:075 action-translator LogManager.java:25 translate 
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }

2025-04-16 17:12:35:075 action-translator LogManager.java:25 qattr [@-1,20:26='listIDF',<0>,150:18].[@-1,28:30='ctx',<0>,150:26]
2025-04-16 17:12:35:075 action-translator LogManager.java:25 qattr [@-1,111:128='declarationKeyword',<0>,151:59].[@-1,130:132='mul',<0>,151:78]
2025-04-16 17:12:35:076 action-translator LogManager.java:25 qattr [@-1,136:139='TYPE',<0>,151:84].[@-1,141:144='text',<0>,151:89]
2025-04-16 17:12:35:076 action-translator LogManager.java:25 qattr [@-1,147:149='INT',<0>,151:95].[@-1,151:154='text',<0>,151:99]
2025-04-16 17:12:35:077 action-translator LogManager.java:25 translate $mul = "Constant";
2025-04-16 17:12:35:077 action-translator LogManager.java:25 setAttr [@-1,1:3='mul',<0>,156:54] [@-1,6:16=' "Constant"',<0>,156:59]
2025-04-16 17:12:35:077 action-translator LogManager.java:25 translate  "Constant"
2025-04-16 17:12:35:077 action-translator LogManager.java:25 translate $mul = "Variable";
2025-04-16 17:12:35:077 action-translator LogManager.java:25 setAttr [@-1,1:3='mul',<0>,156:81] [@-1,6:16=' "Variable"',<0>,156:86]
2025-04-16 17:12:35:077 action-translator LogManager.java:25 translate  "Variable"
2025-04-16 17:12:35:077 action-translator LogManager.java:25 translate ErrorToken type_1 = $v1.type; type_1.exp = $v1.text; this.types.add(type_1); 
2025-04-16 17:12:35:078 action-translator LogManager.java:25 qattr [@-1,21:22='v1',<0>,157:41].[@-1,24:27='type',<0>,157:44]
2025-04-16 17:12:35:078 action-translator LogManager.java:25 qattr [@-1,44:45='v1',<0>,157:64].[@-1,47:50='text',<0>,157:67]
2025-04-16 17:12:35:078 action-translator LogManager.java:25 translate  ErrorToken type_2 = $v.type; type_2.exp = $v.text; this.types.add(type_2);
2025-04-16 17:12:35:078 action-translator LogManager.java:25 qattr [@-1,22:22='v',<0>,157:136].[@-1,24:27='type',<0>,157:138]
2025-04-16 17:12:35:078 action-translator LogManager.java:25 qattr [@-1,44:44='v',<0>,157:158].[@-1,46:49='text',<0>,157:160]
2025-04-16 17:12:35:079 action-translator LogManager.java:25 translate this.boolList.clear(); this.compareList.clear(); this.concatList.clear(); this.arithmeticList.clear();
2025-04-16 17:12:35:080 action-translator LogManager.java:25 translate $type= $var.type;
2025-04-16 17:12:35:080 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,158:150] [@-1,6:15=' $var.type',<0>,158:155]
2025-04-16 17:12:35:080 action-translator LogManager.java:25 translate  $var.type
2025-04-16 17:12:35:080 action-translator LogManager.java:25 qattr [@-1,2:4='var',<0>,158:151].[@-1,6:9='type',<0>,158:155]
2025-04-16 17:12:35:080 action-translator LogManager.java:25 translate $type = $number.type;
2025-04-16 17:12:35:080 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,158:178] [@-1,7:19=' $number.type',<0>,158:184]
2025-04-16 17:12:35:080 action-translator LogManager.java:25 translate  $number.type
2025-04-16 17:12:35:080 action-translator LogManager.java:25 qattr [@-1,2:7='number',<0>,158:179].[@-1,9:12='type',<0>,158:186]
2025-04-16 17:12:35:081 action-translator LogManager.java:25 translate $type = new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos);
2025-04-16 17:12:35:081 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,158:217] [@-1,7:85=' new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos)',<0>,158:223]
2025-04-16 17:12:35:081 action-translator LogManager.java:25 translate  new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos)
2025-04-16 17:12:35:081 action-translator LogManager.java:25 qattr [@-1,17:28='BOOLEANVALUE',<0>,158:233].[@-1,30:33='text',<0>,158:246]
2025-04-16 17:12:35:081 action-translator LogManager.java:25 qattr [@-1,43:54='BOOLEANVALUE',<0>,158:259].[@-1,56:59='line',<0>,158:272]
2025-04-16 17:12:35:081 action-translator LogManager.java:25 qattr [@-1,62:73='BOOLEANVALUE',<0>,158:278].[@-1,75:77='pos',<0>,158:291]
2025-04-16 17:12:35:081 action-translator LogManager.java:25 translate $type = new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos); 
2025-04-16 17:12:35:081 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,158:314] [@-1,7:61=' new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos)',<0>,158:320]
2025-04-16 17:12:35:081 action-translator LogManager.java:25 translate  new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos)
2025-04-16 17:12:35:081 action-translator LogManager.java:25 qattr [@-1,17:20='CHAR',<0>,158:330].[@-1,22:25='text',<0>,158:335]
2025-04-16 17:12:35:082 action-translator LogManager.java:25 qattr [@-1,35:38='CHAR',<0>,158:348].[@-1,40:43='line',<0>,158:353]
2025-04-16 17:12:35:082 action-translator LogManager.java:25 qattr [@-1,46:49='CHAR',<0>,158:359].[@-1,51:53='pos',<0>,158:364]
2025-04-16 17:12:35:082 action-translator LogManager.java:25 translate $type = new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos);
2025-04-16 17:12:35:082 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,158:390] [@-1,7:69=' new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos)',<0>,158:396]
2025-04-16 17:12:35:082 action-translator LogManager.java:25 translate  new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos)
2025-04-16 17:12:35:082 action-translator LogManager.java:25 qattr [@-1,17:22='STRING',<0>,158:406].[@-1,24:27='text',<0>,158:413]
2025-04-16 17:12:35:083 action-translator LogManager.java:25 qattr [@-1,39:44='STRING',<0>,158:428].[@-1,46:49='line',<0>,158:435]
2025-04-16 17:12:35:083 action-translator LogManager.java:25 qattr [@-1,52:57='STRING',<0>,158:441].[@-1,59:61='pos',<0>,158:448]
2025-04-16 17:12:35:083 action-translator LogManager.java:25 translate $type = IDF_HashTable.table.conditionType(this.boolList,this.compareList);
2025-04-16 17:12:35:083 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,158:477] [@-1,7:72=' IDF_HashTable.table.conditionType(this.boolList,this.compareList)',<0>,158:483]
2025-04-16 17:12:35:083 action-translator LogManager.java:25 translate  IDF_HashTable.table.conditionType(this.boolList,this.compareList)
2025-04-16 17:12:35:083 action-translator LogManager.java:25 translate $type=IDF_HashTable.table.getType(this.arithmeticList,0);
2025-04-16 17:12:35:083 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,158:576] [@-1,6:55='IDF_HashTable.table.getType(this.arithmeticList,0)',<0>,158:581]
2025-04-16 17:12:35:083 action-translator LogManager.java:25 translate IDF_HashTable.table.getType(this.arithmeticList,0)
2025-04-16 17:12:35:084 action-translator LogManager.java:25 translate $type=IDF_HashTable.table.getType(this.concatList,1);
2025-04-16 17:12:35:084 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,158:649] [@-1,6:51='IDF_HashTable.table.getType(this.concatList,1)',<0>,158:654]
2025-04-16 17:12:35:084 action-translator LogManager.java:25 translate IDF_HashTable.table.getType(this.concatList,1)
2025-04-16 17:12:35:089 action-translator LogManager.java:25 translate  this.types.clear(); 
2025-04-16 17:12:35:089 action-translator LogManager.java:25 translate  
  IDF_HashTable.table.affectMONO($var_2.text,$var_1.type, $var_2.type,$var_1.start.getLine(),$var_1.start.getCharPositionInLine());

2025-04-16 17:12:35:089 action-translator LogManager.java:25 qattr [@-1,37:41='var_2',<0>,167:34].[@-1,43:46='text',<0>,167:40]
2025-04-16 17:12:35:090 action-translator LogManager.java:25 qattr [@-1,49:53='var_1',<0>,167:46].[@-1,55:58='type',<0>,167:52]
2025-04-16 17:12:35:090 action-translator LogManager.java:25 qattr [@-1,62:66='var_2',<0>,167:59].[@-1,68:71='type',<0>,167:65]
2025-04-16 17:12:35:090 action-translator LogManager.java:25 qattr [@-1,74:78='var_1',<0>,167:71].[@-1,80:84='start',<0>,167:77]
2025-04-16 17:12:35:090 action-translator LogManager.java:25 qattr [@-1,97:101='var_1',<0>,167:94].[@-1,103:107='start',<0>,167:100]
2025-04-16 17:12:35:091 action-translator LogManager.java:25 translate 
 	IDF_HashTable.table.affectEXP($value.text,$var.type, $value.type,$var.start.getLine(),$var.start.getCharPositionInLine());
	

2025-04-16 17:12:35:091 action-translator LogManager.java:25 qattr [@-1,35:39='value',<0>,171:33].[@-1,41:44='text',<0>,171:39]
2025-04-16 17:12:35:091 action-translator LogManager.java:25 qattr [@-1,47:49='var',<0>,171:45].[@-1,51:54='type',<0>,171:49]
2025-04-16 17:12:35:091 action-translator LogManager.java:25 qattr [@-1,58:62='value',<0>,171:56].[@-1,64:67='type',<0>,171:62]
2025-04-16 17:12:35:091 action-translator LogManager.java:25 qattr [@-1,70:72='var',<0>,171:68].[@-1,74:78='start',<0>,171:72]
2025-04-16 17:12:35:092 action-translator LogManager.java:25 qattr [@-1,91:93='var',<0>,171:89].[@-1,95:99='start',<0>,171:93]
2025-04-16 17:12:35:093 action-translator LogManager.java:25 translate 
  IDF_HashTable.table.affectArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos),this.types, $IDF.line,$IDF.pos);

2025-04-16 17:12:35:093 action-translator LogManager.java:25 qattr [@-1,37:39='IDF',<0>,176:35].[@-1,41:44='text',<0>,176:39]
2025-04-16 17:12:35:093 action-translator LogManager.java:25 qattr [@-1,91:93='IDF',<0>,176:89].[@-1,95:98='text',<0>,176:93]
2025-04-16 17:12:35:093 action-translator LogManager.java:25 qattr [@-1,101:103='IDF',<0>,176:99].[@-1,105:108='line',<0>,176:103]
2025-04-16 17:12:35:094 action-translator LogManager.java:25 qattr [@-1,111:113='IDF',<0>,176:109].[@-1,115:117='pos',<0>,176:113]
2025-04-16 17:12:35:094 action-translator LogManager.java:25 qattr [@-1,133:135='IDF',<0>,176:131].[@-1,137:140='line',<0>,176:135]
2025-04-16 17:12:35:094 action-translator LogManager.java:25 qattr [@-1,143:145='IDF',<0>,176:141].[@-1,147:149='pos',<0>,176:145]
2025-04-16 17:12:35:094 action-translator LogManager.java:25 translate 
  IDF_HashTable.table.affectEmptyArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos), $IDF.line,$IDF.pos);

2025-04-16 17:12:35:094 action-translator LogManager.java:25 qattr [@-1,42:44='IDF',<0>,180:40].[@-1,46:49='text',<0>,180:44]
2025-04-16 17:12:35:094 action-translator LogManager.java:25 qattr [@-1,96:98='IDF',<0>,180:94].[@-1,100:103='text',<0>,180:98]
2025-04-16 17:12:35:094 action-translator LogManager.java:25 qattr [@-1,106:108='IDF',<0>,180:104].[@-1,110:113='line',<0>,180:108]
2025-04-16 17:12:35:095 action-translator LogManager.java:25 qattr [@-1,116:118='IDF',<0>,180:114].[@-1,120:122='pos',<0>,180:118]
2025-04-16 17:12:35:095 action-translator LogManager.java:25 qattr [@-1,127:129='IDF',<0>,180:125].[@-1,131:134='line',<0>,180:129]
2025-04-16 17:12:35:095 action-translator LogManager.java:25 qattr [@-1,137:139='IDF',<0>,180:135].[@-1,141:143='pos',<0>,180:139]
2025-04-16 17:12:35:103 action-translator LogManager.java:25 translate this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));
2025-04-16 17:12:35:106 action-translator LogManager.java:25 qattr [@-1,36:41='STRING',<0>,184:57].[@-1,43:46='text',<0>,184:64]
2025-04-16 17:12:35:107 action-translator LogManager.java:25 qattr [@-1,58:63='STRING',<0>,184:79].[@-1,65:68='line',<0>,184:86]
2025-04-16 17:12:35:107 action-translator LogManager.java:25 qattr [@-1,71:76='STRING',<0>,184:92].[@-1,78:80='pos',<0>,184:99]
2025-04-16 17:12:35:108 action-translator LogManager.java:25 translate this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));
2025-04-16 17:12:35:108 action-translator LogManager.java:25 qattr [@-1,36:39='CHAR',<0>,184:150].[@-1,41:44='text',<0>,184:155]
2025-04-16 17:12:35:109 action-translator LogManager.java:25 qattr [@-1,56:59='CHAR',<0>,184:170].[@-1,61:64='line',<0>,184:175]
2025-04-16 17:12:35:109 action-translator LogManager.java:25 qattr [@-1,67:70='CHAR',<0>,184:181].[@-1,72:74='pos',<0>,184:186]
2025-04-16 17:12:35:113 action-translator LogManager.java:25 translate this.concatList.add($var.type);
2025-04-16 17:12:35:113 action-translator LogManager.java:25 qattr [@-1,21:23='var',<0>,184:221].[@-1,25:28='type',<0>,184:225]
2025-04-16 17:12:35:114 action-translator LogManager.java:25 translate this.concatList.add($var.type);
2025-04-16 17:12:35:114 action-translator LogManager.java:25 qattr [@-1,21:23='var',<0>,184:268].[@-1,25:28='type',<0>,184:272]
2025-04-16 17:12:35:115 action-translator LogManager.java:25 translate this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));
2025-04-16 17:12:35:115 action-translator LogManager.java:25 qattr [@-1,36:41='STRING',<0>,184:324].[@-1,43:46='text',<0>,184:331]
2025-04-16 17:12:35:115 action-translator LogManager.java:25 qattr [@-1,58:63='STRING',<0>,184:346].[@-1,65:68='line',<0>,184:353]
2025-04-16 17:12:35:115 action-translator LogManager.java:25 qattr [@-1,71:76='STRING',<0>,184:359].[@-1,78:80='pos',<0>,184:366]
2025-04-16 17:12:35:116 action-translator LogManager.java:25 translate this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));
2025-04-16 17:12:35:116 action-translator LogManager.java:25 qattr [@-1,36:39='CHAR',<0>,184:415].[@-1,41:44='text',<0>,184:420]
2025-04-16 17:12:35:117 action-translator LogManager.java:25 qattr [@-1,56:59='CHAR',<0>,184:435].[@-1,61:64='line',<0>,184:440]
2025-04-16 17:12:35:117 action-translator LogManager.java:25 qattr [@-1,67:70='CHAR',<0>,184:446].[@-1,72:74='pos',<0>,184:451]
2025-04-16 17:12:35:118 action-translator LogManager.java:25 translate 
2025-04-16 17:12:35:118 action-translator LogManager.java:25 translate this.arithmeticList.add($operator.type);
2025-04-16 17:12:35:118 action-translator LogManager.java:25 qattr [@-1,25:32='operator',<0>,2:64].[@-1,34:37='type',<0>,2:73]
2025-04-16 17:12:35:118 action-translator LogManager.java:25 translate precpred(_ctx, 4)
2025-04-16 17:12:35:119 action-translator LogManager.java:25 translate if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}
2025-04-16 17:12:35:119 action-translator LogManager.java:25 qattr [@-1,4:5='op',<0>,6:136].[@-1,7:10='type',<0>,6:139]
2025-04-16 17:12:35:119 action-translator LogManager.java:25 qattr [@-1,95:97='ari',<0>,6:227].[@-1,99:102='text',<0>,6:231]
2025-04-16 17:12:35:119 action-translator LogManager.java:25 qattr [@-1,106:108='ari',<0>,6:238].[@-1,110:114='start',<0>,6:242]
2025-04-16 17:12:35:120 action-translator LogManager.java:25 qattr [@-1,128:130='ari',<0>,6:260].[@-1,132:136='start',<0>,6:264]
2025-04-16 17:12:35:120 action-translator LogManager.java:25 translate precpred(_ctx, 3)
2025-04-16 17:12:35:121 action-translator LogManager.java:25 translate precpred(_ctx, 4)
2025-04-16 17:12:35:121 action-translator LogManager.java:25 translate precpred(_ctx, 3)
2025-04-16 17:12:35:122 action-translator LogManager.java:25 translate $type = $number.type;
2025-04-16 17:12:35:122 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,186:44] [@-1,7:19=' $number.type',<0>,186:50]
2025-04-16 17:12:35:122 action-translator LogManager.java:25 translate  $number.type
2025-04-16 17:12:35:122 action-translator LogManager.java:25 qattr [@-1,2:7='number',<0>,186:45].[@-1,9:12='type',<0>,186:52]
2025-04-16 17:12:35:122 action-translator LogManager.java:25 translate $type = $var.type;
2025-04-16 17:12:35:123 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,186:74] [@-1,7:16=' $var.type',<0>,186:80]
2025-04-16 17:12:35:123 action-translator LogManager.java:25 translate  $var.type
2025-04-16 17:12:35:123 action-translator LogManager.java:25 qattr [@-1,2:4='var',<0>,186:75].[@-1,6:9='type',<0>,186:79]
2025-04-16 17:12:35:123 action-translator LogManager.java:25 translate $type = IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos); 
2025-04-16 17:12:35:123 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,187:36] [@-1,7:80=' IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos)',<0>,187:42]
2025-04-16 17:12:35:124 action-translator LogManager.java:25 translate  IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos)
2025-04-16 17:12:35:124 action-translator LogManager.java:25 qattr [@-1,46:48='IDF',<0>,187:81].[@-1,50:53='text',<0>,187:85]
2025-04-16 17:12:35:124 action-translator LogManager.java:25 qattr [@-1,56:58='IDF',<0>,187:91].[@-1,60:63='line',<0>,187:95]
2025-04-16 17:12:35:124 action-translator LogManager.java:25 qattr [@-1,66:68='IDF',<0>,187:101].[@-1,70:72='pos',<0>,187:105]
2025-04-16 17:12:35:124 action-translator LogManager.java:25 translate $type = IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos);
2025-04-16 17:12:35:124 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,187:140] [@-1,7:89=' IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos)',<0>,187:146]
2025-04-16 17:12:35:124 action-translator LogManager.java:25 translate  IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos)
2025-04-16 17:12:35:124 action-translator LogManager.java:25 qattr [@-1,45:47='IDF',<0>,187:184].[@-1,49:52='text',<0>,187:188]
2025-04-16 17:12:35:124 action-translator LogManager.java:25 qattr [@-1,55:57='INT',<0>,187:194].[@-1,59:62='text',<0>,187:198]
2025-04-16 17:12:35:125 action-translator LogManager.java:25 qattr [@-1,65:67='IDF',<0>,187:204].[@-1,69:72='line',<0>,187:208]
2025-04-16 17:12:35:125 action-translator LogManager.java:25 qattr [@-1,75:77='IDF',<0>,187:214].[@-1,79:81='pos',<0>,187:218]
2025-04-16 17:12:35:132 action-translator LogManager.java:25 translate 
2025-04-16 17:12:35:133 action-translator LogManager.java:25 translate this.boolList.add($var.type);
2025-04-16 17:12:35:133 action-translator LogManager.java:25 qattr [@-1,19:21='var',<0>,5:50].[@-1,23:26='type',<0>,5:54]
2025-04-16 17:12:35:133 action-translator LogManager.java:25 translate precpred(_ctx, 5)
2025-04-16 17:12:35:133 action-translator LogManager.java:25 translate precpred(_ctx, 4)
2025-04-16 17:12:35:133 action-translator LogManager.java:25 translate precpred(_ctx, 5)
2025-04-16 17:12:35:133 action-translator LogManager.java:25 translate precpred(_ctx, 4)
2025-04-16 17:12:35:134 action-translator LogManager.java:25 translate this.compareList.addAll(this.arithmeticList); 
2025-04-16 17:12:35:235 action-translator LogManager.java:25 translate 
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();

2025-04-16 17:12:35:235 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;

2025-04-16 17:12:35:236 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;

2025-04-16 17:12:35:241 action-translator LogManager.java:25 translate 
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();

2025-04-16 17:12:35:241 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;

2025-04-16 17:12:35:241 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;

