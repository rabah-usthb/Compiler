2025-03-17 09:51:24:267 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Expr (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (@ lexer members {
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }

}) (RULES (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE ARITHMETICOPERATOR (RULEMODIFIERS fragment) (BLOCK (ALT [+/*\-]))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE TYPE (BLOCK (ALT 'Int') (ALT 'Float' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE VAR (BLOCK (ALT 'Var' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE END (BLOCK (ALT 'EndPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IF (BLOCK (ALT 'if' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSE (BLOCK (ALT 'else' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSIF (BLOCK (ALT 'elsif'))) (RULE THEN (BLOCK (ALT 'then' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DO (BLOCK (ALT 'do' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FOR (BLOCK (ALT 'for' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FROM (BLOCK (ALT 'from' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE TO (BLOCK (ALT 'to' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE STEP (BLOCK (ALT 'step' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE AND (BLOCK (ALT 'AND' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE OR (BLOCK (ALT 'OR' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE LET (BLOCK (ALT 'let' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DEFINE (BLOCK (ALT '@Define' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE CONST (BLOCK (ALT 'const' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (* (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());}))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) {validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.' {printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {printToken(getText(),"String Constant",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE COMPARAISONOPERATOR (BLOCK (ALT '<') (ALT '>') (ALT '>=') (ALT '<=') (ALT '==') (ALT '!='))) (RULE Separators (BLOCK (ALT '(') (ALT ')') (ALT '=') (ALT ';') (ALT '{') (ALT '}') (ALT '[') (ALT ']') (ALT ':') (ALT ',') (ALT ARITHMETICOPERATOR) (ALT COMPARAISONOPERATOR {printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COMMENT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT {printToken(getText(),"Comment",getLine(),getCharPositionInLine());}))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT . {System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());System.exit(1);}))) (RULE prog (BLOCK (ALT (* (BLOCK (ALT COMMENT))) MAIN IDF ';' (* (BLOCK (ALT COMMENT))) varBlock (* (BLOCK (ALT COMMENT))) mainCode (* (BLOCK (ALT COMMENT))) EOF {IDF_HashTable.table.printTable();}))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration) (ALT COMMENT))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' affectValue ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }
}))) (RULE sign (BLOCK (ALT '+') (ALT '-'))) (RULE affectValue (returns String type) (BLOCK (ALT number {$type = $number.type;}))) (RULE number (returns String type) (BLOCK (ALT '(' sign INT ')' { $type = "INT"; }) (ALT '(' sign FLOAT ')' { $type = "FLOAT"; }) (ALT INT { $type = "INT"; }) (ALT FLOAT { $type = "FLOAT"; }))) (RULE arrayDeclaration (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' affectArray ';') (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';'))) (RULE affectArray (BLOCK (ALT '=' '{' listNumber '}'))) (RULE declarationKeyword (BLOCK (ALT DEFINE CONST) (ALT LET))) (RULE listNumber (BLOCK (ALT number (* (BLOCK (ALT ',' number)))))) (RULE mainCode (BLOCK (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' (+ (BLOCK (ALT inst))) '}' (* (BLOCK (ALT COMMENT))) END ';') (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' '}' (* (BLOCK (ALT COMMENT))) END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT COMMENT) (ALT forInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (BLOCK (ALT STRING) (ALT IDF)) ','))) (BLOCK (ALT STRING) (ALT IDF))) (ALT (BLOCK (ALT STRING) (ALT IDF))))) (RULE affectInst (BLOCK (ALT var AFFECT arithmeticExpression ';'))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression operation arithmeticExpression) (ALT '(' arithmeticExpression ')') (ALT operator))) (RULE operator (BLOCK (ALT number) (ALT var))) (RULE var (BLOCK (ALT IDF) (ALT IDF '[' INT ']'))) (RULE operation (BLOCK (ALT '+') (ALT '-') (ALT '*') (ALT '/'))) (RULE forInst (BLOCK (ALT FOR IDF (? (BLOCK (ALT operation arithmeticExpression))) FROM arithmeticExpression TO arithmeticExpression STEP arithmeticExpression '{' (+ (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (+ (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (+ (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' elseIfInst) (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSE '{' (+ (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseInst (BLOCK (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (+ (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT '(' condition ')') (ALT '!' '(' condition ')') (ALT condition logicalOperator condition) (ALT partCondition))) (RULE partCondition (BLOCK (ALT IDF COMPARAISONOPERATOR arithmeticExpression))) (RULE logicalOperator (BLOCK (ALT AND) (ALT OR) (ALT NOT)))))
2025-03-17 09:51:24:287 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Expr (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (@ lexer members {
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }

}) (RULES (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE ARITHMETICOPERATOR (RULEMODIFIERS fragment) (BLOCK (ALT [+/*\-]))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE TYPE (BLOCK (ALT 'Int') (ALT 'Float' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE VAR (BLOCK (ALT 'Var' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE END (BLOCK (ALT 'EndPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IF (BLOCK (ALT 'if' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSE (BLOCK (ALT 'else' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSIF (BLOCK (ALT 'elsif'))) (RULE THEN (BLOCK (ALT 'then' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DO (BLOCK (ALT 'do' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FOR (BLOCK (ALT 'for' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FROM (BLOCK (ALT 'from' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE TO (BLOCK (ALT 'to' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE STEP (BLOCK (ALT 'step' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE AND (BLOCK (ALT 'AND' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE OR (BLOCK (ALT 'OR' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE LET (BLOCK (ALT 'let' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DEFINE (BLOCK (ALT '@Define' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE CONST (BLOCK (ALT 'const' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (* (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());}))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) {validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.' {printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {printToken(getText(),"String Constant",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE COMPARAISONOPERATOR (BLOCK (ALT '<') (ALT '>') (ALT '>=') (ALT '<=') (ALT '==') (ALT '!='))) (RULE Separators (BLOCK (ALT '(') (ALT ')') (ALT '=') (ALT ';') (ALT '{') (ALT '}') (ALT '[') (ALT ']') (ALT ':') (ALT ',') (ALT ARITHMETICOPERATOR) (ALT COMPARAISONOPERATOR {printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COMMENT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT {printToken(getText(),"Comment",getLine(),getCharPositionInLine());}))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT . {System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());System.exit(1);}))) (RULE prog (BLOCK (ALT (* (BLOCK (ALT COMMENT))) MAIN IDF ';' (* (BLOCK (ALT COMMENT))) varBlock (* (BLOCK (ALT COMMENT))) mainCode (* (BLOCK (ALT COMMENT))) EOF {IDF_HashTable.table.printTable();}))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration) (ALT COMMENT))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' affectValue ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }
}))) (RULE sign (BLOCK (ALT (SET '+' '-')))) (RULE affectValue (returns String type) (BLOCK (ALT number {$type = $number.type;}))) (RULE number (returns String type) (BLOCK (ALT '(' sign INT ')' { $type = "INT"; }) (ALT '(' sign FLOAT ')' { $type = "FLOAT"; }) (ALT INT { $type = "INT"; }) (ALT FLOAT { $type = "FLOAT"; }))) (RULE arrayDeclaration (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' affectArray ';') (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';'))) (RULE affectArray (BLOCK (ALT '=' '{' listNumber '}'))) (RULE declarationKeyword (BLOCK (ALT DEFINE CONST) (ALT LET))) (RULE listNumber (BLOCK (ALT number (* (BLOCK (ALT ',' number)))))) (RULE mainCode (BLOCK (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' (+ (BLOCK (ALT inst))) '}' (* (BLOCK (ALT COMMENT))) END ';') (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' '}' (* (BLOCK (ALT COMMENT))) END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT COMMENT) (ALT forInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (BLOCK (ALT var AFFECT arithmeticExpression ';'))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression operation arithmeticExpression) (ALT '(' arithmeticExpression ')') (ALT operator))) (RULE operator (BLOCK (ALT number) (ALT var))) (RULE var (BLOCK (ALT IDF) (ALT IDF '[' INT ']'))) (RULE operation (BLOCK (ALT (SET '+' '-' '*' '/')))) (RULE forInst (BLOCK (ALT FOR IDF (? (BLOCK (ALT operation arithmeticExpression))) FROM arithmeticExpression TO arithmeticExpression STEP arithmeticExpression '{' (+ (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (+ (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (+ (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' elseIfInst) (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSE '{' (+ (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseInst (BLOCK (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (+ (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT '(' condition ')') (ALT '!' '(' condition ')') (ALT condition logicalOperator condition) (ALT partCondition))) (RULE partCondition (BLOCK (ALT IDF COMPARAISONOPERATOR arithmeticExpression))) (RULE logicalOperator (BLOCK (ALT (SET AND OR NOT))))))
2025-03-17 09:51:24:336 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Expr (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT COMMENT))) MAIN IDF ';' (* (BLOCK (ALT COMMENT))) varBlock (* (BLOCK (ALT COMMENT))) mainCode (* (BLOCK (ALT COMMENT))) EOF {IDF_HashTable.table.printTable();}))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration) (ALT COMMENT))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' affectValue ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }
}))) (RULE sign (BLOCK (ALT (SET '+' '-')))) (RULE affectValue (returns String type) (BLOCK (ALT number {$type = $number.type;}))) (RULE number (returns String type) (BLOCK (ALT '(' sign INT ')' { $type = "INT"; }) (ALT '(' sign FLOAT ')' { $type = "FLOAT"; }) (ALT INT { $type = "INT"; }) (ALT FLOAT { $type = "FLOAT"; }))) (RULE arrayDeclaration (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' affectArray ';') (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';'))) (RULE affectArray (BLOCK (ALT '=' '{' listNumber '}'))) (RULE declarationKeyword (BLOCK (ALT DEFINE CONST) (ALT LET))) (RULE listNumber (BLOCK (ALT number (* (BLOCK (ALT ',' number)))))) (RULE mainCode (BLOCK (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' (+ (BLOCK (ALT inst))) '}' (* (BLOCK (ALT COMMENT))) END ';') (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' '}' (* (BLOCK (ALT COMMENT))) END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT COMMENT) (ALT forInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (BLOCK (ALT var AFFECT arithmeticExpression ';'))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression operation arithmeticExpression) (ALT '(' arithmeticExpression ')') (ALT operator))) (RULE operator (BLOCK (ALT number) (ALT var))) (RULE var (BLOCK (ALT IDF) (ALT IDF '[' INT ']'))) (RULE operation (BLOCK (ALT (SET '+' '-' '*' '/')))) (RULE forInst (BLOCK (ALT FOR IDF (? (BLOCK (ALT operation arithmeticExpression))) FROM arithmeticExpression TO arithmeticExpression STEP arithmeticExpression '{' (+ (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (+ (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (+ (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' elseIfInst) (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSE '{' (+ (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseInst (BLOCK (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (+ (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT '(' condition ')') (ALT '!' '(' condition ')') (ALT condition logicalOperator condition) (ALT partCondition))) (RULE partCondition (BLOCK (ALT IDF COMPARAISONOPERATOR arithmeticExpression))) (RULE logicalOperator (BLOCK (ALT (SET AND OR NOT))))))
2025-03-17 09:51:24:336 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR ExprLexer (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (@ lexer members {
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }

}) (RULES (RULE T__0 (BLOCK (ALT ';'))) (RULE T__1 (BLOCK (ALT ','))) (RULE T__2 (BLOCK (ALT ':'))) (RULE T__3 (BLOCK (ALT '='))) (RULE T__4 (BLOCK (ALT '+'))) (RULE T__5 (BLOCK (ALT '-'))) (RULE T__6 (BLOCK (ALT '('))) (RULE T__7 (BLOCK (ALT ')'))) (RULE T__8 (BLOCK (ALT '['))) (RULE T__9 (BLOCK (ALT ']'))) (RULE T__10 (BLOCK (ALT '{'))) (RULE T__11 (BLOCK (ALT '}'))) (RULE T__12 (BLOCK (ALT '*'))) (RULE T__13 (BLOCK (ALT '/'))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE ARITHMETICOPERATOR (RULEMODIFIERS fragment) (BLOCK (ALT [+/*\-]))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE TYPE (BLOCK (ALT 'Int') (ALT 'Float' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE VAR (BLOCK (ALT 'Var' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE END (BLOCK (ALT 'EndPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IF (BLOCK (ALT 'if' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSE (BLOCK (ALT 'else' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSIF (BLOCK (ALT 'elsif'))) (RULE THEN (BLOCK (ALT 'then' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DO (BLOCK (ALT 'do' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FOR (BLOCK (ALT 'for' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FROM (BLOCK (ALT 'from' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE TO (BLOCK (ALT 'to' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE STEP (BLOCK (ALT 'step' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE AND (BLOCK (ALT 'AND' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE OR (BLOCK (ALT 'OR' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE LET (BLOCK (ALT 'let' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DEFINE (BLOCK (ALT '@Define' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE CONST (BLOCK (ALT 'const' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (* (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());}))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) {validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.' {printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {printToken(getText(),"String Constant",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE COMPARAISONOPERATOR (BLOCK (ALT '<') (ALT '>') (ALT '>=') (ALT '<=') (ALT '==') (ALT '!='))) (RULE Separators (BLOCK (ALT '(') (ALT ')') (ALT '=') (ALT ';') (ALT '{') (ALT '}') (ALT '[') (ALT ']') (ALT ':') (ALT ',') (ALT ARITHMETICOPERATOR) (ALT COMPARAISONOPERATOR {printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COMMENT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT {printToken(getText(),"Comment",getLine(),getCharPositionInLine());}))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT . {System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());System.exit(1);})))))
2025-03-17 09:51:24:536 action-translator LogManager.java:25 translate 
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }


2025-03-17 09:51:24:536 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"String Constant",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate printToken(getText(),"Comment",getLine(),getCharPositionInLine());
2025-03-17 09:51:24:570 action-translator LogManager.java:25 translate System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());System.exit(1);
2025-03-17 09:51:24:652 left-recursion LogManager.java:25 arithmeticExpression
    :   ( {} '('<tokenIndex=850> arithmeticExpression<tokenIndex=852> ')'<tokenIndex=854> 
        | operator<tokenIndex=858> 
        )
        (
          {precpred(_ctx, 3)}?<p=3> operation<tokenIndex=844> arithmeticExpression<tokenIndex=846,p=4>
        )*
    ;
2025-03-17 09:51:24:668 grammar LogManager.java:25 added: (RULE arithmeticExpression (BLOCK (ALT (BLOCK (ALT {} ('(' (ELEMENT_OPTIONS (= tokenIndex 850))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 852))) (')' (ELEMENT_OPTIONS (= tokenIndex 854)))) (ALT (operator (ELEMENT_OPTIONS (= tokenIndex 858))))) (* (BLOCK (ALT ({precpred(_ctx, 3)}? (ELEMENT_OPTIONS (= p 3))) (operation (ELEMENT_OPTIONS (= tokenIndex 844))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 846) (= p 4)))))))))
2025-03-17 09:51:24:670 left-recursion LogManager.java:25 condition
    :   ( {} '('<tokenIndex=1147> condition<tokenIndex=1149> ')'<tokenIndex=1151> 
        | '!'<tokenIndex=1155> '('<tokenIndex=1157> condition<tokenIndex=1159> ')'<tokenIndex=1161> 
        | partCondition<tokenIndex=1173> 
        )
        (
          {precpred(_ctx, 2)}?<p=2> logicalOperator<tokenIndex=1167> condition<tokenIndex=1169,p=3>
        )*
    ;
2025-03-17 09:51:24:670 grammar LogManager.java:25 added: (RULE condition (BLOCK (ALT (BLOCK (ALT {} ('(' (ELEMENT_OPTIONS (= tokenIndex 1147))) (condition (ELEMENT_OPTIONS (= tokenIndex 1149))) (')' (ELEMENT_OPTIONS (= tokenIndex 1151)))) (ALT ('!' (ELEMENT_OPTIONS (= tokenIndex 1155))) ('(' (ELEMENT_OPTIONS (= tokenIndex 1157))) (condition (ELEMENT_OPTIONS (= tokenIndex 1159))) (')' (ELEMENT_OPTIONS (= tokenIndex 1161)))) (ALT (partCondition (ELEMENT_OPTIONS (= tokenIndex 1173))))) (* (BLOCK (ALT ({precpred(_ctx, 2)}? (ELEMENT_OPTIONS (= p 2))) (logicalOperator (ELEMENT_OPTIONS (= tokenIndex 1167))) (condition (ELEMENT_OPTIONS (= tokenIndex 1169) (= p 3)))))))))
2025-03-17 09:51:24:670 semantics LogManager.java:25 tokens={EOF=-1, T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, T__8=9, T__9=10, T__10=11, T__11=12, T__12=13, T__13=14, INPUT=15, OUTPUT=16, TYPE=17, MAIN=18, VAR=19, BEGIN=20, END=21, IF=22, ELSE=23, ELSIF=24, THEN=25, SWITCH=26, CASE=27, BREAK=28, DEFAULT=29, WHILE=30, DO=31, FOR=32, FROM=33, TO=34, STEP=35, AND=36, OR=37, LET=38, DEFINE=39, CONST=40, IDF=41, INT=42, FLOAT=43, STRING=44, AFFECT=45, NOT=46, COMPARAISONOPERATOR=47, Separators=48, COMMENT=49, WS=50, ERROR_TOKEN=51}
2025-03-17 09:51:24:670 semantics LogManager.java:25 strings={';'=1, ','=2, ':'=3, '='=4, '+'=5, '-'=6, '('=7, ')'=8, '['=9, ']'=10, '{'=11, '}'=12, '*'=13, '/'=14, 'input'=15, 'output'=16, 'MainPrgm'=18, 'Var'=19, 'BeginPg'=20, 'EndPg'=21, 'if'=22, 'else'=23, 'elsif'=24, 'then'=25, 'switch'=26, 'case'=27, 'break'=28, 'default'=29, 'while'=30, 'do'=31, 'for'=32, 'from'=33, 'to'=34, 'step'=35, 'AND'=36, 'OR'=37, 'let'=38, '@Define'=39, 'const'=40, ':='=45, '!'=46}
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 0 in rule prog
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[49, 18]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 1 in rule prog
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[49, 19]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 2 in rule prog
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[49, 20]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 3 in rule prog
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[49, <EOF>]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 4 in rule varBlock
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{38..39, 49}, {20, 49}]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 5 in rule varBlock
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[19, 19]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 6 in rule declaration
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{38..39}, {38..39}, 49]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 7 in rule listIDF
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[2, {3, 8}]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 8 in rule normalDeclaration
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{38..39}, {38..39}]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 9 in rule number
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[7, 7, 42, 43]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 10 in rule arrayDeclaration
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{38..39}, {38..39}]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 11 in rule declarationKeyword
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[39, 38]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 12 in rule listNumber
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[2, 12]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 13 in rule mainCode
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[49, 11]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 14 in rule mainCode
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{15..16, 22, 26, 30..32, 41, 49}, 12]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 15 in rule mainCode
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[49, 21]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 16 in rule mainCode
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[49, 11]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 17 in rule mainCode
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[49, 21]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 18 in rule mainCode
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[20, 20]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 19 in rule inst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[16, 15, 41, 49, 32, 31, 30, 22, 26]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 20 in rule content
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{41, 44}, {41, 44}]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 21 in rule content
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{41, 44}, {41, 44}]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 22 in rule arithmeticExpression
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[7, {7, 41..43}]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 23 in rule arithmeticExpression
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[null, null]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 24 in rule operator
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{7, 42..43}, 41]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 25 in rule var
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[41, 41]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 26 in rule forInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{5..6, 13..14}, 33]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 27 in rule forInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{15..16, 22, 26, 30..32, 41, 49}, 12]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 28 in rule doWhileInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{15..16, 22, 26, 30..32, 41, 49}, 12]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 29 in rule whileInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{15..16, 22, 26, 30..32, 41, 49}, 12]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 30 in rule ifInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{15..16, 22, 26, 30..32, 41, 49}, 12]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 31 in rule ifInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{24, 49}, {12, 15..16, 22..23, 26, 28, 30..32, 41, 49}]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 32 in rule ifInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{23, 49}, {12, 15..16, 22, 26, 28, 30..32, 41, 49}]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 33 in rule elseIfInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[49, 24]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 34 in rule elseIfInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{15..16, 22, 26, 30..32, 41, 49}, 12]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 35 in rule elseIfInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[49, 24]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 36 in rule elseIfInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{15..16, 22, 26, 30..32, 41, 49}, 12]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 37 in rule elseIfInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{24, 49}, {24, 49}]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 38 in rule elseInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[49, 23]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 39 in rule elseInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{15..16, 22, 26, 30..32, 41, 49}, 12]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 40 in rule caseInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{15..16, 22, 26, 30..32, 41, 49}, 28]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 41 in rule caseInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[{15..16, 22, 26, 30..32, 41, 49}, 28]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 42 in rule caseInst
2025-03-17 09:51:24:686 LL1 LogManager.java:25 look=[27, 27]
2025-03-17 09:51:24:686 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:686 LL1 LogManager.java:25 
DECISION 43 in rule defaultInst
2025-03-17 09:51:24:702 LL1 LogManager.java:25 look=[{15..16, 22, 26, 30..32, 41, 49}, 28]
2025-03-17 09:51:24:702 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:702 LL1 LogManager.java:25 
DECISION 44 in rule condition
2025-03-17 09:51:24:702 LL1 LogManager.java:25 look=[7, 46, 41]
2025-03-17 09:51:24:703 LL1 LogManager.java:25 LL(1)? true
2025-03-17 09:51:24:703 LL1 LogManager.java:25 
DECISION 45 in rule condition
2025-03-17 09:51:24:703 LL1 LogManager.java:25 look=[null, null]
2025-03-17 09:51:24:703 LL1 LogManager.java:25 LL(1)? false
2025-03-17 09:51:24:703 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-17 09:51:24:725 action-translator LogManager.java:25 translate IDF_HashTable.table.printTable();
2025-03-17 09:51:24:729 action-translator LogManager.java:25 translate 
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }

2025-03-17 09:51:24:730 action-translator LogManager.java:25 qattr [@-1,25:31='listIDF',<0>,103:23].[@-1,33:36='text',<0>,103:31]
2025-03-17 09:51:24:732 action-translator LogManager.java:25 qattr [@-1,111:114='TYPE',<0>,104:57].[@-1,116:119='text',<0>,104:62]
2025-03-17 09:51:24:732 action-translator LogManager.java:25 qattr [@-1,122:132='affectValue',<0>,104:68].[@-1,134:137='text',<0>,104:80]
2025-03-17 09:51:24:732 action-translator LogManager.java:25 qattr [@-1,140:150='affectValue',<0>,104:86].[@-1,152:155='type',<0>,104:98]
2025-03-17 09:51:24:733 action-translator LogManager.java:25 translate 
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }

2025-03-17 09:51:24:733 action-translator LogManager.java:25 qattr [@-1,25:31='listIDF',<0>,109:23].[@-1,33:36='text',<0>,109:31]
2025-03-17 09:51:24:733 action-translator LogManager.java:25 qattr [@-1,106:109='TYPE',<0>,110:52].[@-1,111:114='text',<0>,110:57]
2025-03-17 09:51:24:734 action-translator LogManager.java:25 translate $type = $number.type;
2025-03-17 09:51:24:735 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,114:46] [@-1,7:19=' $number.type',<0>,114:52]
2025-03-17 09:51:24:735 action-translator LogManager.java:25 translate  $number.type
2025-03-17 09:51:24:735 action-translator LogManager.java:25 qattr [@-1,2:7='number',<0>,114:47].[@-1,9:12='type',<0>,114:54]
2025-03-17 09:51:24:739 action-translator LogManager.java:25 translate  $type = "INT"; 
2025-03-17 09:51:24:739 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,115:49] [@-1,8:13=' "INT"',<0>,115:55]
2025-03-17 09:51:24:739 action-translator LogManager.java:25 translate  "INT"
2025-03-17 09:51:24:739 action-translator LogManager.java:25 translate  $type = "FLOAT"; 
2025-03-17 09:51:24:739 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,115:89] [@-1,8:15=' "FLOAT"',<0>,115:95]
2025-03-17 09:51:24:739 action-translator LogManager.java:25 translate  "FLOAT"
2025-03-17 09:51:24:739 action-translator LogManager.java:25 translate  $type = "INT"; 
2025-03-17 09:51:24:739 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,115:116] [@-1,8:13=' "INT"',<0>,115:122]
2025-03-17 09:51:24:739 action-translator LogManager.java:25 translate  "INT"
2025-03-17 09:51:24:739 action-translator LogManager.java:25 translate  $type = "FLOAT"; 
2025-03-17 09:51:24:739 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,115:144] [@-1,8:15=' "FLOAT"',<0>,115:150]
2025-03-17 09:51:24:739 action-translator LogManager.java:25 translate  "FLOAT"
2025-03-17 09:51:24:739 action-translator LogManager.java:25 translate 
2025-03-17 09:51:24:739 action-translator LogManager.java:25 translate precpred(_ctx, 3)
2025-03-17 09:51:24:739 action-translator LogManager.java:25 translate precpred(_ctx, 3)
2025-03-17 09:51:24:764 action-translator LogManager.java:25 translate 
2025-03-17 09:51:24:765 action-translator LogManager.java:25 translate precpred(_ctx, 2)
2025-03-17 09:51:24:765 action-translator LogManager.java:25 translate precpred(_ctx, 2)
2025-03-17 09:51:24:870 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-17 09:51:24:870 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-17 09:51:24:870 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-17 09:51:24:870 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

