2025-03-18 03:08:42:875 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Expr (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (@ lexer members {
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }

}) (RULES (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE ARITHMETICOPERATOR (RULEMODIFIERS fragment) (BLOCK (ALT [+/*\-]))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE TYPE (BLOCK (ALT 'Int') (ALT 'Float' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE VAR (BLOCK (ALT 'Var' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE END (BLOCK (ALT 'EndPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IF (BLOCK (ALT 'if' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSE (BLOCK (ALT 'else' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSIF (BLOCK (ALT 'elsif'))) (RULE THEN (BLOCK (ALT 'then' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DO (BLOCK (ALT 'do' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FOR (BLOCK (ALT 'for' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FROM (BLOCK (ALT 'from' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE TO (BLOCK (ALT 'to' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE STEP (BLOCK (ALT 'step' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE AND (BLOCK (ALT 'AND' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE OR (BLOCK (ALT 'OR' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE LET (BLOCK (ALT 'let' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DEFINE (BLOCK (ALT '@Define' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE CONST (BLOCK (ALT 'const' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (* (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());}))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) {validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.' {printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {printToken(getText(),"String Constant",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE COMPARAISONOPERATOR (BLOCK (ALT '<') (ALT '>') (ALT '>=') (ALT '<=') (ALT '==') (ALT '!='))) (RULE Separators (BLOCK (ALT '(') (ALT ')') (ALT '=') (ALT ';') (ALT '{') (ALT '}') (ALT '[') (ALT ']') (ALT ':') (ALT ',') (ALT ARITHMETICOPERATOR) (LEXER_ALT_ACTION (ALT COMPARAISONOPERATOR {printToken(getText(),"Separator",getLine(),getCharPositionInLine());}) (LEXER_ACTION_CALL type SEPARATOR)))) (RULE COMMENT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT {printToken(getText(),"Comment",getLine(),getCharPositionInLine());}))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT . {System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());System.exit(1);}))) (RULE prog (BLOCK (ALT (* (BLOCK (ALT COMMENT))) MAIN IDF ';' (* (BLOCK (ALT COMMENT))) varBlock (* (BLOCK (ALT COMMENT))) mainCode (* (BLOCK (ALT COMMENT))) EOF {IDF_HashTable.table.printTable();}))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration) (ALT COMMENT))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' affectValue ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }
}))) (RULE sign (BLOCK (ALT '+') (ALT '-'))) (RULE affectValue (returns String type) (BLOCK (ALT number {$type = $number.type;}))) (RULE number (returns String type) (BLOCK (ALT '(' sign INT ')' { $type = "INT"; }) (ALT '(' sign FLOAT ')' { $type = "FLOAT"; }) (ALT INT { $type = "INT"; }) (ALT FLOAT { $type = "FLOAT"; }))) (RULE arrayDeclaration (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' affectArray ';') (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';'))) (RULE affectArray (BLOCK (ALT '=' '{' listNumber '}'))) (RULE declarationKeyword (BLOCK (ALT DEFINE CONST) (ALT LET))) (RULE listNumber (BLOCK (ALT number (* (BLOCK (ALT ',' number)))))) (RULE mainCode (BLOCK (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' (+ (BLOCK (ALT inst))) '}' (* (BLOCK (ALT COMMENT))) END ';') (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' '}' (* (BLOCK (ALT COMMENT))) END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT COMMENT) (ALT forInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (BLOCK (ALT STRING) (ALT IDF)) ','))) (BLOCK (ALT STRING) (ALT IDF))) (ALT (BLOCK (ALT STRING) (ALT IDF))))) (RULE affectInst (BLOCK (ALT var AFFECT arithmeticExpression ';'))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression operation arithmeticExpression) (ALT '(' arithmeticExpression ')') (ALT operator))) (RULE operator (BLOCK (ALT number) (ALT var))) (RULE var (BLOCK (ALT IDF) (ALT IDF '[' INT ']'))) (RULE operation (BLOCK (ALT '+') (ALT '-') (ALT '*') (ALT '/'))) (RULE forInst (BLOCK (ALT FOR IDF (? (BLOCK (ALT operation arithmeticExpression))) FROM arithmeticExpression TO arithmeticExpression STEP arithmeticExpression '{' (+ (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (+ (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (+ (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' elseIfInst) (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSE '{' (+ (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseInst (BLOCK (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (+ (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT '(' condition ')') (ALT '!' '(' condition ')') (ALT condition logicalOperator condition) (ALT partCondition))) (RULE partCondition (BLOCK (ALT IDF COMPARAISONOPERATOR arithmeticExpression))) (RULE logicalOperator (BLOCK (ALT AND) (ALT OR) (ALT NOT)))))
2025-03-18 03:08:42:906 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Expr (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (@ lexer members {
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }

}) (RULES (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE ARITHMETICOPERATOR (RULEMODIFIERS fragment) (BLOCK (ALT [+/*\-]))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE TYPE (BLOCK (ALT 'Int') (ALT 'Float' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE VAR (BLOCK (ALT 'Var' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE END (BLOCK (ALT 'EndPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IF (BLOCK (ALT 'if' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSE (BLOCK (ALT 'else' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSIF (BLOCK (ALT 'elsif'))) (RULE THEN (BLOCK (ALT 'then' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DO (BLOCK (ALT 'do' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FOR (BLOCK (ALT 'for' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FROM (BLOCK (ALT 'from' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE TO (BLOCK (ALT 'to' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE STEP (BLOCK (ALT 'step' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE AND (BLOCK (ALT 'AND' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE OR (BLOCK (ALT 'OR' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE LET (BLOCK (ALT 'let' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DEFINE (BLOCK (ALT '@Define' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE CONST (BLOCK (ALT 'const' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (* (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());}))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) {validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.' {printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {printToken(getText(),"String Constant",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE COMPARAISONOPERATOR (BLOCK (ALT '<') (ALT '>') (ALT '>=') (ALT '<=') (ALT '==') (ALT '!='))) (RULE Separators (BLOCK (ALT '(') (ALT ')') (ALT '=') (ALT ';') (ALT '{') (ALT '}') (ALT '[') (ALT ']') (ALT ':') (ALT ',') (ALT ARITHMETICOPERATOR) (LEXER_ALT_ACTION (ALT COMPARAISONOPERATOR {printToken(getText(),"Separator",getLine(),getCharPositionInLine());}) (LEXER_ACTION_CALL type SEPARATOR)))) (RULE COMMENT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT {printToken(getText(),"Comment",getLine(),getCharPositionInLine());}))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT . {System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());System.exit(1);}))) (RULE prog (BLOCK (ALT (* (BLOCK (ALT COMMENT))) MAIN IDF ';' (* (BLOCK (ALT COMMENT))) varBlock (* (BLOCK (ALT COMMENT))) mainCode (* (BLOCK (ALT COMMENT))) EOF {IDF_HashTable.table.printTable();}))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration) (ALT COMMENT))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' affectValue ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }
}))) (RULE sign (BLOCK (ALT (SET '+' '-')))) (RULE affectValue (returns String type) (BLOCK (ALT number {$type = $number.type;}))) (RULE number (returns String type) (BLOCK (ALT '(' sign INT ')' { $type = "INT"; }) (ALT '(' sign FLOAT ')' { $type = "FLOAT"; }) (ALT INT { $type = "INT"; }) (ALT FLOAT { $type = "FLOAT"; }))) (RULE arrayDeclaration (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' affectArray ';') (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';'))) (RULE affectArray (BLOCK (ALT '=' '{' listNumber '}'))) (RULE declarationKeyword (BLOCK (ALT DEFINE CONST) (ALT LET))) (RULE listNumber (BLOCK (ALT number (* (BLOCK (ALT ',' number)))))) (RULE mainCode (BLOCK (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' (+ (BLOCK (ALT inst))) '}' (* (BLOCK (ALT COMMENT))) END ';') (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' '}' (* (BLOCK (ALT COMMENT))) END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT COMMENT) (ALT forInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (BLOCK (ALT var AFFECT arithmeticExpression ';'))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression operation arithmeticExpression) (ALT '(' arithmeticExpression ')') (ALT operator))) (RULE operator (BLOCK (ALT number) (ALT var))) (RULE var (BLOCK (ALT IDF) (ALT IDF '[' INT ']'))) (RULE operation (BLOCK (ALT (SET '+' '-' '*' '/')))) (RULE forInst (BLOCK (ALT FOR IDF (? (BLOCK (ALT operation arithmeticExpression))) FROM arithmeticExpression TO arithmeticExpression STEP arithmeticExpression '{' (+ (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (+ (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (+ (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' elseIfInst) (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSE '{' (+ (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseInst (BLOCK (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (+ (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT '(' condition ')') (ALT '!' '(' condition ')') (ALT condition logicalOperator condition) (ALT partCondition))) (RULE partCondition (BLOCK (ALT IDF COMPARAISONOPERATOR arithmeticExpression))) (RULE logicalOperator (BLOCK (ALT (SET AND OR NOT))))))
2025-03-18 03:08:42:938 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Expr (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT COMMENT))) MAIN IDF ';' (* (BLOCK (ALT COMMENT))) varBlock (* (BLOCK (ALT COMMENT))) mainCode (* (BLOCK (ALT COMMENT))) EOF {IDF_HashTable.table.printTable();}))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration) (ALT COMMENT))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' affectValue ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }
}))) (RULE sign (BLOCK (ALT (SET '+' '-')))) (RULE affectValue (returns String type) (BLOCK (ALT number {$type = $number.type;}))) (RULE number (returns String type) (BLOCK (ALT '(' sign INT ')' { $type = "INT"; }) (ALT '(' sign FLOAT ')' { $type = "FLOAT"; }) (ALT INT { $type = "INT"; }) (ALT FLOAT { $type = "FLOAT"; }))) (RULE arrayDeclaration (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' affectArray ';') (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';'))) (RULE affectArray (BLOCK (ALT '=' '{' listNumber '}'))) (RULE declarationKeyword (BLOCK (ALT DEFINE CONST) (ALT LET))) (RULE listNumber (BLOCK (ALT number (* (BLOCK (ALT ',' number)))))) (RULE mainCode (BLOCK (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' (+ (BLOCK (ALT inst))) '}' (* (BLOCK (ALT COMMENT))) END ';') (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' '}' (* (BLOCK (ALT COMMENT))) END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT COMMENT) (ALT forInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (BLOCK (ALT var AFFECT arithmeticExpression ';'))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression operation arithmeticExpression) (ALT '(' arithmeticExpression ')') (ALT operator))) (RULE operator (BLOCK (ALT number) (ALT var))) (RULE var (BLOCK (ALT IDF) (ALT IDF '[' INT ']'))) (RULE operation (BLOCK (ALT (SET '+' '-' '*' '/')))) (RULE forInst (BLOCK (ALT FOR IDF (? (BLOCK (ALT operation arithmeticExpression))) FROM arithmeticExpression TO arithmeticExpression STEP arithmeticExpression '{' (+ (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (+ (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (+ (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' elseIfInst) (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSE '{' (+ (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseInst (BLOCK (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (+ (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT '(' condition ')') (ALT '!' '(' condition ')') (ALT condition logicalOperator condition) (ALT partCondition))) (RULE partCondition (BLOCK (ALT IDF COMPARAISONOPERATOR arithmeticExpression))) (RULE logicalOperator (BLOCK (ALT (SET AND OR NOT))))))
2025-03-18 03:08:42:939 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR ExprLexer (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (@ lexer members {
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }

}) (RULES (RULE T__0 (BLOCK (ALT ';'))) (RULE T__1 (BLOCK (ALT ','))) (RULE T__2 (BLOCK (ALT ':'))) (RULE T__3 (BLOCK (ALT '='))) (RULE T__4 (BLOCK (ALT '+'))) (RULE T__5 (BLOCK (ALT '-'))) (RULE T__6 (BLOCK (ALT '('))) (RULE T__7 (BLOCK (ALT ')'))) (RULE T__8 (BLOCK (ALT '['))) (RULE T__9 (BLOCK (ALT ']'))) (RULE T__10 (BLOCK (ALT '{'))) (RULE T__11 (BLOCK (ALT '}'))) (RULE T__12 (BLOCK (ALT '*'))) (RULE T__13 (BLOCK (ALT '/'))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE ARITHMETICOPERATOR (RULEMODIFIERS fragment) (BLOCK (ALT [+/*\-]))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE TYPE (BLOCK (ALT 'Int') (ALT 'Float' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE VAR (BLOCK (ALT 'Var' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE END (BLOCK (ALT 'EndPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IF (BLOCK (ALT 'if' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSE (BLOCK (ALT 'else' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSIF (BLOCK (ALT 'elsif'))) (RULE THEN (BLOCK (ALT 'then' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DO (BLOCK (ALT 'do' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FOR (BLOCK (ALT 'for' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FROM (BLOCK (ALT 'from' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE TO (BLOCK (ALT 'to' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE STEP (BLOCK (ALT 'step' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE AND (BLOCK (ALT 'AND' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE OR (BLOCK (ALT 'OR' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE LET (BLOCK (ALT 'let' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DEFINE (BLOCK (ALT '@Define' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE CONST (BLOCK (ALT 'const' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (* (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());}))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) {validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.' {printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {printToken(getText(),"String Constant",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE COMPARAISONOPERATOR (BLOCK (ALT '<') (ALT '>') (ALT '>=') (ALT '<=') (ALT '==') (ALT '!='))) (RULE Separators (BLOCK (ALT '(') (ALT ')') (ALT '=') (ALT ';') (ALT '{') (ALT '}') (ALT '[') (ALT ']') (ALT ':') (ALT ',') (ALT ARITHMETICOPERATOR) (LEXER_ALT_ACTION (ALT COMPARAISONOPERATOR {printToken(getText(),"Separator",getLine(),getCharPositionInLine());}) (LEXER_ACTION_CALL type SEPARATOR)))) (RULE COMMENT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT {printToken(getText(),"Comment",getLine(),getCharPositionInLine());}))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT . {System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());System.exit(1);})))))
2025-03-18 03:08:43:110 left-recursion LogManager.java:25 arithmeticExpression
    :   ( {} '('<tokenIndex=857> arithmeticExpression<tokenIndex=859> ')'<tokenIndex=861> 
        | operator<tokenIndex=865> 
        )
        (
          {precpred(_ctx, 3)}?<p=3> operation<tokenIndex=851> arithmeticExpression<tokenIndex=853,p=4>
        )*
    ;
2025-03-18 03:08:43:116 grammar LogManager.java:25 added: (RULE arithmeticExpression (BLOCK (ALT (BLOCK (ALT {} ('(' (ELEMENT_OPTIONS (= tokenIndex 857))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 859))) (')' (ELEMENT_OPTIONS (= tokenIndex 861)))) (ALT (operator (ELEMENT_OPTIONS (= tokenIndex 865))))) (* (BLOCK (ALT ({precpred(_ctx, 3)}? (ELEMENT_OPTIONS (= p 3))) (operation (ELEMENT_OPTIONS (= tokenIndex 851))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 853) (= p 4)))))))))
2025-03-18 03:08:43:121 left-recursion LogManager.java:25 condition
    :   ( {} '('<tokenIndex=1154> condition<tokenIndex=1156> ')'<tokenIndex=1158> 
        | '!'<tokenIndex=1162> '('<tokenIndex=1164> condition<tokenIndex=1166> ')'<tokenIndex=1168> 
        | partCondition<tokenIndex=1180> 
        )
        (
          {precpred(_ctx, 2)}?<p=2> logicalOperator<tokenIndex=1174> condition<tokenIndex=1176,p=3>
        )*
    ;
2025-03-18 03:08:43:124 grammar LogManager.java:25 added: (RULE condition (BLOCK (ALT (BLOCK (ALT {} ('(' (ELEMENT_OPTIONS (= tokenIndex 1154))) (condition (ELEMENT_OPTIONS (= tokenIndex 1156))) (')' (ELEMENT_OPTIONS (= tokenIndex 1158)))) (ALT ('!' (ELEMENT_OPTIONS (= tokenIndex 1162))) ('(' (ELEMENT_OPTIONS (= tokenIndex 1164))) (condition (ELEMENT_OPTIONS (= tokenIndex 1166))) (')' (ELEMENT_OPTIONS (= tokenIndex 1168)))) (ALT (partCondition (ELEMENT_OPTIONS (= tokenIndex 1180))))) (* (BLOCK (ALT ({precpred(_ctx, 2)}? (ELEMENT_OPTIONS (= p 2))) (logicalOperator (ELEMENT_OPTIONS (= tokenIndex 1174))) (condition (ELEMENT_OPTIONS (= tokenIndex 1176) (= p 3)))))))))
2025-03-18 03:08:43:348 semantics LogManager.java:25 tokens={EOF=-1, COMMENT=1, MAIN=2, IDF=3, VAR=4, TYPE=5, INT=6, FLOAT=7, DEFINE=8, CONST=9, LET=10, BEGIN=11, END=12, INPUT=13, OUTPUT=14, STRING=15, AFFECT=16, FOR=17, FROM=18, TO=19, STEP=20, DO=21, WHILE=22, IF=23, THEN=24, ELSIF=25, ELSE=26, SWITCH=27, CASE=28, BREAK=29, DEFAULT=30, COMPARAISONOPERATOR=31, AND=32, OR=33, NOT=34}
2025-03-18 03:08:43:348 semantics LogManager.java:25 strings={}
