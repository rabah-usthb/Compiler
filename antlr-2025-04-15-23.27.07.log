2025-04-15 23:27:06:418 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Expr (@ header {
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
}) (@ members {
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();
}) (RULES (RULE SIGN (RULEMODIFIERS fragment) (BLOCK (ALT '-') (ALT '+'))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INTEGER (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT)))))) (RULE FLOATED (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.'))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE BOOLEANVALUE (BLOCK (ALT 'True' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}) (ALT 'False' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}))) (RULE INPUT (BLOCK (ALT 'input' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Read Function");}))) (RULE OUTPUT (BLOCK (ALT 'output' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Print Function");}))) (RULE TYPE (BLOCK (ALT 'Int' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Float' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Bool' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'String' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Char' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainProgram Header");}))) (RULE VAR (BLOCK (ALT 'Var' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Block Delimiter");}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE END (BLOCK (ALT 'EndPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE IF (BLOCK (ALT 'if' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"If Keyword");}))) (RULE ELSE (BLOCK (ALT 'else' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else Keyword");}))) (RULE ELSIF (BLOCK (ALT 'elsif' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else If Keyword");}))) (RULE THEN (BLOCK (ALT 'then' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Then Keyword");}))) (RULE SWITCH (BLOCK (ALT 'switch' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Switch Keyword");}))) (RULE CASE (BLOCK (ALT 'case' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE BREAK (BLOCK (ALT 'break' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE DEFAULT (BLOCK (ALT 'default' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Default Case Delimiter");}))) (RULE WHILE (BLOCK (ALT 'while' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE DO (BLOCK (ALT 'do' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FOR (BLOCK (ALT 'for' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FROM (BLOCK (ALT 'from' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"From Keyword");}))) (RULE TO (BLOCK (ALT 'to' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"To Keyword");}))) (RULE STEP (BLOCK (ALT 'step' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Step Keyword");}))) (RULE AND (BLOCK (ALT 'AND' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical AND");}))) (RULE OR (BLOCK (ALT 'OR' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical OR");}))) (RULE LET (BLOCK (ALT 'let' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Declarator");}))) (RULE DEFINE (BLOCK (ALT '@define' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE CONST (BLOCK (ALT 'Const' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (? (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {IDF_HashTable.table.insertFirst(getText(),getLine(),getCharPositionInLine());}))) (RULE INT (BLOCK (ALT '(' SIGN INTEGER ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}) (ALT INTEGER {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT '(' SIGN FLOATED ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}) (ALT FLOATED {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {Constant_Hashtable.ConstantTable.insertTable(getText(),"string",getLine(),getCharPositionInLine());}))) (RULE CHAR (BLOCK (ALT '\'' (* (BLOCK (ALT (~ (SET ['\n]))))) '\'' {Constant_Hashtable.ConstantTable.insertTable(getText(),"char",getLine(),getCharPositionInLine());}))) (RULE CONCAT (BLOCK (ALT '.'))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE GREATER (BLOCK (ALT '>'))) (RULE LESSER (BLOCK (ALT '<'))) (RULE GEQ (BLOCK (ALT '>='))) (RULE LEQ (BLOCK (ALT '<='))) (RULE EQ (BLOCK (ALT '=='))) (RULE NEQ (BLOCK (ALT '!='))) (RULE LBRACE (BLOCK (ALT '{'))) (RULE RBRACE (BLOCK (ALT '}'))) (RULE PLUS (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE COM (BLOCK (ALT ','))) (RULE SEMI (BLOCK (ALT ';'))) (RULE LBRACKET (BLOCK (ALT '['))) (RULE RBRACKET (BLOCK (ALT ']'))) (RULE LPAR (BLOCK (ALT '('))) (RULE RPAR (BLOCK (ALT ')'))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE TWOPOINT (BLOCK (ALT ':'))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT))) (LEXER_ACTION_CALL channel HIDDEN)))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT .))) (RULE prog (BLOCK (ALT MAIN IDF ';' varBlock mainCode EOF))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' value ';' {
this.types.add($value.type);
    for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$value.text,types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
        for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
       }))) (RULE number (returns ErrorToken type) (BLOCK (ALT INT { $type = new ErrorToken($INT.text,"INT",$INT.line,$INT.pos); }) (ALT FLOAT { $type = new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos); }))) (RULE arrayDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,this.types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}))) (RULE affectArray (BLOCK (ALT '=' '{' (* (BLOCK (ALT listValue))) '}'))) (RULE declarationKeyword (returns String mul) (BLOCK (ALT DEFINE CONST {$mul = "Constant";}) (ALT LET {$mul = "Variable";}))) (RULE listValue (BLOCK (ALT (= v1 value) {ErrorToken type_1 = $v1.type; type_1.exp = $v1.text; this.types.add(type_1); } (* (BLOCK (ALT ',' (= v value) { ErrorToken type_2 = $v.type; type_2.exp = $v.text; this.types.add(type_2);})))))) (RULE value (returns ErrorToken type) (@ init {this.boolList.clear(); this.compareList.clear(); this.concatList.clear(); this.arithmeticList.clear();}) (BLOCK (ALT var {$type= $var.type;}) (ALT number {$type = $number.type;}) (ALT BOOLEANVALUE {$type = new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos);}) (ALT CHAR {$type = new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos); }) (ALT STRING {$type = new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos);}) (ALT condition {$type = IDF_HashTable.table.conditionType(this.boolList,this.compareList);}) (ALT arithmeticExpression {$type=IDF_HashTable.table.getType(this.arithmeticList,0);}) (ALT concatInst {$type=IDF_HashTable.table.getType(this.concatList,1);}))) (RULE mainCode (BLOCK (ALT BEGIN '{' (+ (BLOCK (ALT inst))) '}' END ';') (ALT BEGIN '{' '}' END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst) (ALT forInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (BLOCK (ALT STRING) (ALT IDF)) ','))) (BLOCK (ALT STRING) (ALT IDF))) (ALT (BLOCK (ALT STRING) (ALT IDF))))) (RULE affectInst (@ init { this.types.clear(); }) (BLOCK (ALT (= var_1 var) AFFECT (= var_2 var) ';' { 
  IDF_HashTable.table.affectMONO($var_2.text,$var_1.type, $var_2.type,$var_1.start.getLine(),$var_1.start.getCharPositionInLine());
}) (ALT var AFFECT value ';' {
 	IDF_HashTable.table.affectEXP($value.text,$var.type, $value.type,$var.start.getLine(),$var.start.getCharPositionInLine());
	
}) (ALT IDF AFFECT '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  IDF_HashTable.table.affectArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos),this.types, $IDF.line,$IDF.pos);
}) (ALT IDF AFFECT '{' '}' ';' {
  IDF_HashTable.table.affectEmptyArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos), $IDF.line,$IDF.pos);
}))) (RULE concatInst (BLOCK (ALT (BLOCK (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));}) (ALT var {this.concatList.add($var.type);})) (+ (BLOCK (ALT '.' (BLOCK (ALT (BLOCK (ALT var {this.concatList.add($var.type);}) (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));})))))))))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression (= op (BLOCK (ALT MUL) (ALT DIV))) (= ari arithmeticExpression) {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}) (ALT arithmeticExpression (BLOCK (ALT PLUS) (ALT SUB)) arithmeticExpression) (ALT operator {this.arithmeticList.add($operator.type);}) (ALT '(' arithmeticExpression ')'))) (RULE operator (returns ErrorToken type) (BLOCK (ALT number {$type = $number.type;}) (ALT var {$type = $var.type;}))) (RULE var (returns ErrorToken type) (BLOCK (ALT IDF {$type = IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos); }) (ALT IDF '[' INT ']' {$type = IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos);}))) (RULE forInst (BLOCK (ALT FOR IDF FROM INT TO INT STEP INT '{' (* (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (* (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (* (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF LPAR condition RPAR THEN '{' (* (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}' elseIfInst) (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT ELSE '{' (* (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseValue (BLOCK (ALT number) (ALT BOOLEANVALUE) (ALT CHAR) (ALT STRING))) (RULE caseInst (BLOCK (ALT CASE caseValue ':' (* (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE caseValue ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (* (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT LPAR condition RPAR) (ALT NOT condition) (ALT condition AND condition) (ALT condition OR condition) (ALT partCondition) (ALT var {this.boolList.add($var.type);}) (ALT BOOLEANVALUE))) (RULE partCondition (BLOCK (ALT arithmeticExpression comparaisonOperator arithmeticExpression {this.compareList.addAll(this.arithmeticList); }))) (RULE comparaisonOperator (BLOCK (ALT EQ) (ALT NEQ) (ALT GREATER) (ALT LESSER) (ALT GEQ) (ALT LEQ)))))
2025-04-15 23:27:06:459 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Expr (@ header {
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
}) (@ members {
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();
}) (RULES (RULE SIGN (RULEMODIFIERS fragment) (BLOCK (ALT (SET '-' '+')))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INTEGER (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT)))))) (RULE FLOATED (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.'))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE BOOLEANVALUE (BLOCK (ALT 'True' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}) (ALT 'False' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}))) (RULE INPUT (BLOCK (ALT 'input' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Read Function");}))) (RULE OUTPUT (BLOCK (ALT 'output' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Print Function");}))) (RULE TYPE (BLOCK (ALT 'Int' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Float' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Bool' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'String' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Char' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainProgram Header");}))) (RULE VAR (BLOCK (ALT 'Var' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Block Delimiter");}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE END (BLOCK (ALT 'EndPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE IF (BLOCK (ALT 'if' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"If Keyword");}))) (RULE ELSE (BLOCK (ALT 'else' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else Keyword");}))) (RULE ELSIF (BLOCK (ALT 'elsif' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else If Keyword");}))) (RULE THEN (BLOCK (ALT 'then' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Then Keyword");}))) (RULE SWITCH (BLOCK (ALT 'switch' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Switch Keyword");}))) (RULE CASE (BLOCK (ALT 'case' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE BREAK (BLOCK (ALT 'break' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE DEFAULT (BLOCK (ALT 'default' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Default Case Delimiter");}))) (RULE WHILE (BLOCK (ALT 'while' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE DO (BLOCK (ALT 'do' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FOR (BLOCK (ALT 'for' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FROM (BLOCK (ALT 'from' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"From Keyword");}))) (RULE TO (BLOCK (ALT 'to' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"To Keyword");}))) (RULE STEP (BLOCK (ALT 'step' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Step Keyword");}))) (RULE AND (BLOCK (ALT 'AND' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical AND");}))) (RULE OR (BLOCK (ALT 'OR' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical OR");}))) (RULE LET (BLOCK (ALT 'let' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Declarator");}))) (RULE DEFINE (BLOCK (ALT '@define' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE CONST (BLOCK (ALT 'Const' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (? (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {IDF_HashTable.table.insertFirst(getText(),getLine(),getCharPositionInLine());}))) (RULE INT (BLOCK (ALT '(' SIGN INTEGER ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}) (ALT INTEGER {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT '(' SIGN FLOATED ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}) (ALT FLOATED {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {Constant_Hashtable.ConstantTable.insertTable(getText(),"string",getLine(),getCharPositionInLine());}))) (RULE CHAR (BLOCK (ALT '\'' (* (BLOCK (ALT (~ (SET ['\n]))))) '\'' {Constant_Hashtable.ConstantTable.insertTable(getText(),"char",getLine(),getCharPositionInLine());}))) (RULE CONCAT (BLOCK (ALT '.'))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE GREATER (BLOCK (ALT '>'))) (RULE LESSER (BLOCK (ALT '<'))) (RULE GEQ (BLOCK (ALT '>='))) (RULE LEQ (BLOCK (ALT '<='))) (RULE EQ (BLOCK (ALT '=='))) (RULE NEQ (BLOCK (ALT '!='))) (RULE LBRACE (BLOCK (ALT '{'))) (RULE RBRACE (BLOCK (ALT '}'))) (RULE PLUS (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE COM (BLOCK (ALT ','))) (RULE SEMI (BLOCK (ALT ';'))) (RULE LBRACKET (BLOCK (ALT '['))) (RULE RBRACKET (BLOCK (ALT ']'))) (RULE LPAR (BLOCK (ALT '('))) (RULE RPAR (BLOCK (ALT ')'))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE TWOPOINT (BLOCK (ALT ':'))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT))) (LEXER_ACTION_CALL channel HIDDEN)))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT .))) (RULE prog (BLOCK (ALT MAIN IDF ';' varBlock mainCode EOF))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' value ';' {
this.types.add($value.type);
    for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$value.text,types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
        for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
       }))) (RULE number (returns ErrorToken type) (BLOCK (ALT INT { $type = new ErrorToken($INT.text,"INT",$INT.line,$INT.pos); }) (ALT FLOAT { $type = new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos); }))) (RULE arrayDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,this.types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}))) (RULE affectArray (BLOCK (ALT '=' '{' (* (BLOCK (ALT listValue))) '}'))) (RULE declarationKeyword (returns String mul) (BLOCK (ALT DEFINE CONST {$mul = "Constant";}) (ALT LET {$mul = "Variable";}))) (RULE listValue (BLOCK (ALT (= v1 value) {ErrorToken type_1 = $v1.type; type_1.exp = $v1.text; this.types.add(type_1); } (* (BLOCK (ALT ',' (= v value) { ErrorToken type_2 = $v.type; type_2.exp = $v.text; this.types.add(type_2);})))))) (RULE value (returns ErrorToken type) (@ init {this.boolList.clear(); this.compareList.clear(); this.concatList.clear(); this.arithmeticList.clear();}) (BLOCK (ALT var {$type= $var.type;}) (ALT number {$type = $number.type;}) (ALT BOOLEANVALUE {$type = new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos);}) (ALT CHAR {$type = new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos); }) (ALT STRING {$type = new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos);}) (ALT condition {$type = IDF_HashTable.table.conditionType(this.boolList,this.compareList);}) (ALT arithmeticExpression {$type=IDF_HashTable.table.getType(this.arithmeticList,0);}) (ALT concatInst {$type=IDF_HashTable.table.getType(this.concatList,1);}))) (RULE mainCode (BLOCK (ALT BEGIN '{' (+ (BLOCK (ALT inst))) '}' END ';') (ALT BEGIN '{' '}' END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst) (ALT forInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (@ init { this.types.clear(); }) (BLOCK (ALT (= var_1 var) AFFECT (= var_2 var) ';' { 
  IDF_HashTable.table.affectMONO($var_2.text,$var_1.type, $var_2.type,$var_1.start.getLine(),$var_1.start.getCharPositionInLine());
}) (ALT var AFFECT value ';' {
 	IDF_HashTable.table.affectEXP($value.text,$var.type, $value.type,$var.start.getLine(),$var.start.getCharPositionInLine());
	
}) (ALT IDF AFFECT '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  IDF_HashTable.table.affectArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos),this.types, $IDF.line,$IDF.pos);
}) (ALT IDF AFFECT '{' '}' ';' {
  IDF_HashTable.table.affectEmptyArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos), $IDF.line,$IDF.pos);
}))) (RULE concatInst (BLOCK (ALT (BLOCK (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));}) (ALT var {this.concatList.add($var.type);})) (+ (BLOCK (ALT '.' (BLOCK (ALT (BLOCK (ALT var {this.concatList.add($var.type);}) (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));})))))))))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression (= op (SET MUL DIV)) (= ari arithmeticExpression) {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}) (ALT arithmeticExpression (SET PLUS SUB) arithmeticExpression) (ALT operator {this.arithmeticList.add($operator.type);}) (ALT '(' arithmeticExpression ')'))) (RULE operator (returns ErrorToken type) (BLOCK (ALT number {$type = $number.type;}) (ALT var {$type = $var.type;}))) (RULE var (returns ErrorToken type) (BLOCK (ALT IDF {$type = IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos); }) (ALT IDF '[' INT ']' {$type = IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos);}))) (RULE forInst (BLOCK (ALT FOR IDF FROM INT TO INT STEP INT '{' (* (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (* (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (* (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF LPAR condition RPAR THEN '{' (* (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}' elseIfInst) (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT ELSE '{' (* (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseValue (BLOCK (ALT number) (ALT BOOLEANVALUE) (ALT CHAR) (ALT STRING))) (RULE caseInst (BLOCK (ALT CASE caseValue ':' (* (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE caseValue ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (* (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT LPAR condition RPAR) (ALT NOT condition) (ALT condition AND condition) (ALT condition OR condition) (ALT partCondition) (ALT var {this.boolList.add($var.type);}) (ALT BOOLEANVALUE))) (RULE partCondition (BLOCK (ALT arithmeticExpression comparaisonOperator arithmeticExpression {this.compareList.addAll(this.arithmeticList); }))) (RULE comparaisonOperator (BLOCK (ALT (SET EQ NEQ GREATER LESSER GEQ LEQ))))))
2025-04-15 23:27:06:505 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Expr (@ header {
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
}) (@ members {
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();
}) (RULES (RULE prog (BLOCK (ALT MAIN IDF ';' varBlock mainCode EOF))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' value ';' {
this.types.add($value.type);
    for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$value.text,types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
        for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
       }))) (RULE number (returns ErrorToken type) (BLOCK (ALT INT { $type = new ErrorToken($INT.text,"INT",$INT.line,$INT.pos); }) (ALT FLOAT { $type = new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos); }))) (RULE arrayDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,this.types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}))) (RULE affectArray (BLOCK (ALT '=' '{' (* (BLOCK (ALT listValue))) '}'))) (RULE declarationKeyword (returns String mul) (BLOCK (ALT DEFINE CONST {$mul = "Constant";}) (ALT LET {$mul = "Variable";}))) (RULE listValue (BLOCK (ALT (= v1 value) {ErrorToken type_1 = $v1.type; type_1.exp = $v1.text; this.types.add(type_1); } (* (BLOCK (ALT ',' (= v value) { ErrorToken type_2 = $v.type; type_2.exp = $v.text; this.types.add(type_2);})))))) (RULE value (returns ErrorToken type) (@ init {this.boolList.clear(); this.compareList.clear(); this.concatList.clear(); this.arithmeticList.clear();}) (BLOCK (ALT var {$type= $var.type;}) (ALT number {$type = $number.type;}) (ALT BOOLEANVALUE {$type = new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos);}) (ALT CHAR {$type = new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos); }) (ALT STRING {$type = new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos);}) (ALT condition {$type = IDF_HashTable.table.conditionType(this.boolList,this.compareList);}) (ALT arithmeticExpression {$type=IDF_HashTable.table.getType(this.arithmeticList,0);}) (ALT concatInst {$type=IDF_HashTable.table.getType(this.concatList,1);}))) (RULE mainCode (BLOCK (ALT BEGIN '{' (+ (BLOCK (ALT inst))) '}' END ';') (ALT BEGIN '{' '}' END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst) (ALT forInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (@ init { this.types.clear(); }) (BLOCK (ALT (= var_1 var) AFFECT (= var_2 var) ';' { 
  IDF_HashTable.table.affectMONO($var_2.text,$var_1.type, $var_2.type,$var_1.start.getLine(),$var_1.start.getCharPositionInLine());
}) (ALT var AFFECT value ';' {
 	IDF_HashTable.table.affectEXP($value.text,$var.type, $value.type,$var.start.getLine(),$var.start.getCharPositionInLine());
	
}) (ALT IDF AFFECT '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  IDF_HashTable.table.affectArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos),this.types, $IDF.line,$IDF.pos);
}) (ALT IDF AFFECT '{' '}' ';' {
  IDF_HashTable.table.affectEmptyArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos), $IDF.line,$IDF.pos);
}))) (RULE concatInst (BLOCK (ALT (BLOCK (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));}) (ALT var {this.concatList.add($var.type);})) (+ (BLOCK (ALT '.' (BLOCK (ALT (BLOCK (ALT var {this.concatList.add($var.type);}) (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));})))))))))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression (= op (SET MUL DIV)) (= ari arithmeticExpression) {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}) (ALT arithmeticExpression (SET PLUS SUB) arithmeticExpression) (ALT operator {this.arithmeticList.add($operator.type);}) (ALT '(' arithmeticExpression ')'))) (RULE operator (returns ErrorToken type) (BLOCK (ALT number {$type = $number.type;}) (ALT var {$type = $var.type;}))) (RULE var (returns ErrorToken type) (BLOCK (ALT IDF {$type = IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos); }) (ALT IDF '[' INT ']' {$type = IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos);}))) (RULE forInst (BLOCK (ALT FOR IDF FROM INT TO INT STEP INT '{' (* (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (* (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (* (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF LPAR condition RPAR THEN '{' (* (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}' elseIfInst) (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT ELSE '{' (* (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseValue (BLOCK (ALT number) (ALT BOOLEANVALUE) (ALT CHAR) (ALT STRING))) (RULE caseInst (BLOCK (ALT CASE caseValue ':' (* (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE caseValue ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (* (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT LPAR condition RPAR) (ALT NOT condition) (ALT condition AND condition) (ALT condition OR condition) (ALT partCondition) (ALT var {this.boolList.add($var.type);}) (ALT BOOLEANVALUE))) (RULE partCondition (BLOCK (ALT arithmeticExpression comparaisonOperator arithmeticExpression {this.compareList.addAll(this.arithmeticList); }))) (RULE comparaisonOperator (BLOCK (ALT (SET EQ NEQ GREATER LESSER GEQ LEQ))))))
2025-04-15 23:27:06:506 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR ExprLexer (@ header {
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
}) (@ members {
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();
}) (RULES (RULE SIGN (RULEMODIFIERS fragment) (BLOCK (ALT (SET '-' '+')))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INTEGER (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT)))))) (RULE FLOATED (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.'))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE BOOLEANVALUE (BLOCK (ALT 'True' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}) (ALT 'False' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}))) (RULE INPUT (BLOCK (ALT 'input' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Read Function");}))) (RULE OUTPUT (BLOCK (ALT 'output' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Print Function");}))) (RULE TYPE (BLOCK (ALT 'Int' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Float' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Bool' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'String' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Char' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainProgram Header");}))) (RULE VAR (BLOCK (ALT 'Var' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Block Delimiter");}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE END (BLOCK (ALT 'EndPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE IF (BLOCK (ALT 'if' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"If Keyword");}))) (RULE ELSE (BLOCK (ALT 'else' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else Keyword");}))) (RULE ELSIF (BLOCK (ALT 'elsif' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else If Keyword");}))) (RULE THEN (BLOCK (ALT 'then' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Then Keyword");}))) (RULE SWITCH (BLOCK (ALT 'switch' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Switch Keyword");}))) (RULE CASE (BLOCK (ALT 'case' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE BREAK (BLOCK (ALT 'break' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE DEFAULT (BLOCK (ALT 'default' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Default Case Delimiter");}))) (RULE WHILE (BLOCK (ALT 'while' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE DO (BLOCK (ALT 'do' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FOR (BLOCK (ALT 'for' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FROM (BLOCK (ALT 'from' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"From Keyword");}))) (RULE TO (BLOCK (ALT 'to' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"To Keyword");}))) (RULE STEP (BLOCK (ALT 'step' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Step Keyword");}))) (RULE AND (BLOCK (ALT 'AND' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical AND");}))) (RULE OR (BLOCK (ALT 'OR' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical OR");}))) (RULE LET (BLOCK (ALT 'let' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Declarator");}))) (RULE DEFINE (BLOCK (ALT '@define' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE CONST (BLOCK (ALT 'Const' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (? (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {IDF_HashTable.table.insertFirst(getText(),getLine(),getCharPositionInLine());}))) (RULE INT (BLOCK (ALT '(' SIGN INTEGER ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}) (ALT INTEGER {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT '(' SIGN FLOATED ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}) (ALT FLOATED {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {Constant_Hashtable.ConstantTable.insertTable(getText(),"string",getLine(),getCharPositionInLine());}))) (RULE CHAR (BLOCK (ALT '\'' (* (BLOCK (ALT (~ (SET ['\n]))))) '\'' {Constant_Hashtable.ConstantTable.insertTable(getText(),"char",getLine(),getCharPositionInLine());}))) (RULE CONCAT (BLOCK (ALT '.'))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE GREATER (BLOCK (ALT '>'))) (RULE LESSER (BLOCK (ALT '<'))) (RULE GEQ (BLOCK (ALT '>='))) (RULE LEQ (BLOCK (ALT '<='))) (RULE EQ (BLOCK (ALT '=='))) (RULE NEQ (BLOCK (ALT '!='))) (RULE LBRACE (BLOCK (ALT '{'))) (RULE RBRACE (BLOCK (ALT '}'))) (RULE PLUS (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE COM (BLOCK (ALT ','))) (RULE SEMI (BLOCK (ALT ';'))) (RULE LBRACKET (BLOCK (ALT '['))) (RULE RBRACKET (BLOCK (ALT ']'))) (RULE LPAR (BLOCK (ALT '('))) (RULE RPAR (BLOCK (ALT ')'))) (RULE ASSIGN (BLOCK (ALT '='))) (RULE TWOPOINT (BLOCK (ALT ':'))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT))) (LEXER_ACTION_CALL channel HIDDEN)))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT .)))))
2025-04-15 23:27:06:977 action-translator LogManager.java:25 translate 
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();

2025-04-15 23:27:06:978 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;

2025-04-15 23:27:07:000 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");
2025-04-15 23:27:07:000 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");
2025-04-15 23:27:07:000 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Read Function");
2025-04-15 23:27:07:000 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Print Function");
2025-04-15 23:27:07:001 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-15 23:27:07:001 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-15 23:27:07:001 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-15 23:27:07:001 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-15 23:27:07:001 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-15 23:27:07:001 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainProgram Header");
2025-04-15 23:27:07:001 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Block Delimiter");
2025-04-15 23:27:07:001 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");
2025-04-15 23:27:07:001 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");
2025-04-15 23:27:07:001 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"If Keyword");
2025-04-15 23:27:07:002 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else Keyword");
2025-04-15 23:27:07:002 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else If Keyword");
2025-04-15 23:27:07:002 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Then Keyword");
2025-04-15 23:27:07:002 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Switch Keyword");
2025-04-15 23:27:07:002 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");
2025-04-15 23:27:07:002 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");
2025-04-15 23:27:07:002 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Default Case Delimiter");
2025-04-15 23:27:07:002 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");
2025-04-15 23:27:07:002 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"From Keyword");
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"To Keyword");
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Step Keyword");
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical AND");
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical OR");
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Declarator");
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate IDF_HashTable.table.insertFirst(getText(),getLine(),getCharPositionInLine());
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"string",getLine(),getCharPositionInLine());
2025-04-15 23:27:07:003 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"char",getLine(),getCharPositionInLine());
2025-04-15 23:27:07:107 left-recursion LogManager.java:25 arithmeticExpression
    :   ( {} operator<tokenIndex=1188> {this.arithmeticList.add($operator.type);} 
        | '('<tokenIndex=1193> arithmeticExpression<tokenIndex=1195> ')'<tokenIndex=1197> 
        )
        (
          {precpred(_ctx, 4)}?<p=4> op=(MUL<tokenIndex=1160> | DIV<tokenIndex=1164>) ari=arithmeticExpression<tokenIndex=1169,p=5>  {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}
                  | {precpred(_ctx, 3)}?<p=3> (PLUS<tokenIndex=1178>| SUB<tokenIndex=1181>) arithmeticExpression<tokenIndex=1184,p=4>
        )*
    ;
2025-04-15 23:27:07:117 grammar LogManager.java:25 added: (RULE arithmeticExpression (BLOCK (ALT (BLOCK (ALT {} (operator (ELEMENT_OPTIONS (= tokenIndex 1188))) {this.arithmeticList.add($operator.type);}) (ALT ('(' (ELEMENT_OPTIONS (= tokenIndex 1193))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 1195))) (')' (ELEMENT_OPTIONS (= tokenIndex 1197))))) (* (BLOCK (ALT ({precpred(_ctx, 4)}? (ELEMENT_OPTIONS (= p 4))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 1160))) (DIV (ELEMENT_OPTIONS (= tokenIndex 1164))))) (= ari (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 1169) (= p 5)))) {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}) (ALT ({precpred(_ctx, 3)}? (ELEMENT_OPTIONS (= p 3))) (SET (PLUS (ELEMENT_OPTIONS (= tokenIndex 1178))) (SUB (ELEMENT_OPTIONS (= tokenIndex 1181)))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 1184) (= p 4)))))))))
2025-04-15 23:27:07:122 left-recursion LogManager.java:25 condition
    :   ( {} LPAR<tokenIndex=1481> condition<tokenIndex=1483> RPAR<tokenIndex=1485> 
        | NOT<tokenIndex=1488> condition<tokenIndex=1490,p=6> 
        | partCondition<tokenIndex=1508> 
        | var<tokenIndex=1511> {this.boolList.add($var.type);} 
        | BOOLEANVALUE<tokenIndex=1517> 
        )
        (
          {precpred(_ctx, 5)}?<p=5> AND<tokenIndex=1496> condition<tokenIndex=1498,p=6>
                  | {precpred(_ctx, 4)}?<p=4> OR<tokenIndex=1503> condition<tokenIndex=1505,p=5>
        )*
    ;
2025-04-15 23:27:07:128 grammar LogManager.java:25 added: (RULE condition (BLOCK (ALT (BLOCK (ALT {} (LPAR (ELEMENT_OPTIONS (= tokenIndex 1481))) (condition (ELEMENT_OPTIONS (= tokenIndex 1483))) (RPAR (ELEMENT_OPTIONS (= tokenIndex 1485)))) (ALT (NOT (ELEMENT_OPTIONS (= tokenIndex 1488))) (condition (ELEMENT_OPTIONS (= tokenIndex 1490) (= p 6)))) (ALT (partCondition (ELEMENT_OPTIONS (= tokenIndex 1508)))) (ALT (var (ELEMENT_OPTIONS (= tokenIndex 1511))) {this.boolList.add($var.type);}) (ALT (BOOLEANVALUE (ELEMENT_OPTIONS (= tokenIndex 1517))))) (* (BLOCK (ALT ({precpred(_ctx, 5)}? (ELEMENT_OPTIONS (= p 5))) (AND (ELEMENT_OPTIONS (= tokenIndex 1496))) (condition (ELEMENT_OPTIONS (= tokenIndex 1498) (= p 6)))) (ALT ({precpred(_ctx, 4)}? (ELEMENT_OPTIONS (= p 4))) (OR (ELEMENT_OPTIONS (= tokenIndex 1503))) (condition (ELEMENT_OPTIONS (= tokenIndex 1505) (= p 5)))))))))
2025-04-15 23:27:07:133 semantics LogManager.java:25 tokens={EOF=-1, BOOLEANVALUE=1, INPUT=2, OUTPUT=3, TYPE=4, MAIN=5, VAR=6, BEGIN=7, END=8, IF=9, ELSE=10, ELSIF=11, THEN=12, SWITCH=13, CASE=14, BREAK=15, DEFAULT=16, WHILE=17, DO=18, FOR=19, FROM=20, TO=21, STEP=22, AND=23, OR=24, LET=25, DEFINE=26, CONST=27, IDF=28, INT=29, FLOAT=30, STRING=31, CHAR=32, CONCAT=33, AFFECT=34, NOT=35, GREATER=36, LESSER=37, GEQ=38, LEQ=39, EQ=40, NEQ=41, LBRACE=42, RBRACE=43, PLUS=44, SUB=45, MUL=46, DIV=47, COM=48, SEMI=49, LBRACKET=50, RBRACKET=51, LPAR=52, RPAR=53, ASSIGN=54, TWOPOINT=55, COMMENT=56, WS=57, ERROR_TOKEN=58}
2025-04-15 23:27:07:133 semantics LogManager.java:25 strings={'input'=2, 'output'=3, 'MainPrgm'=5, 'Var'=6, 'BeginPg'=7, 'EndPg'=8, 'if'=9, 'else'=10, 'elsif'=11, 'then'=12, 'switch'=13, 'case'=14, 'break'=15, 'default'=16, 'while'=17, 'do'=18, 'for'=19, 'from'=20, 'to'=21, 'step'=22, 'AND'=23, 'OR'=24, 'let'=25, '@define'=26, 'Const'=27, '.'=33, ':='=34, '!'=35, '>'=36, '<'=37, '>='=38, '<='=39, '=='=40, '!='=41, '{'=42, '}'=43, '+'=44, '-'=45, '*'=46, '/'=47, ','=48, ';'=49, '['=50, ']'=51, '('=52, ')'=53, '='=54, ':'=55}
2025-04-15 23:27:07:161 LL1 LogManager.java:25 
DECISION 0 in rule varBlock
2025-04-15 23:27:07:162 LL1 LogManager.java:25 look=[{25..26}, 7]
2025-04-15 23:27:07:162 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:162 LL1 LogManager.java:25 
DECISION 1 in rule varBlock
2025-04-15 23:27:07:162 LL1 LogManager.java:25 look=[6, 6]
2025-04-15 23:27:07:162 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:162 LL1 LogManager.java:25 
DECISION 2 in rule declaration
2025-04-15 23:27:07:162 LL1 LogManager.java:25 look=[{25..26}, {25..26}]
2025-04-15 23:27:07:162 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:162 LL1 LogManager.java:25 
DECISION 3 in rule listIDF
2025-04-15 23:27:07:162 LL1 LogManager.java:25 look=[48, {53, 55}]
2025-04-15 23:27:07:162 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:162 LL1 LogManager.java:25 
DECISION 4 in rule normalDeclaration
2025-04-15 23:27:07:162 LL1 LogManager.java:25 look=[{25..26}, {25..26}]
2025-04-15 23:27:07:162 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:162 LL1 LogManager.java:25 
DECISION 5 in rule number
2025-04-15 23:27:07:162 LL1 LogManager.java:25 look=[29, 30]
2025-04-15 23:27:07:162 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:162 LL1 LogManager.java:25 
DECISION 6 in rule arrayDeclaration
2025-04-15 23:27:07:163 LL1 LogManager.java:25 look=[{1, 28..32, 35, 52}, 43]
2025-04-15 23:27:07:163 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:163 LL1 LogManager.java:25 
DECISION 7 in rule arrayDeclaration
2025-04-15 23:27:07:163 LL1 LogManager.java:25 look=[{25..26}, {25..26}, {25..26}]
2025-04-15 23:27:07:163 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:163 LL1 LogManager.java:25 
DECISION 8 in rule affectArray
2025-04-15 23:27:07:163 LL1 LogManager.java:25 look=[{1, 28..32, 35, 52}, 43]
2025-04-15 23:27:07:163 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:163 LL1 LogManager.java:25 
DECISION 9 in rule declarationKeyword
2025-04-15 23:27:07:163 LL1 LogManager.java:25 look=[26, 25]
2025-04-15 23:27:07:163 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:163 LL1 LogManager.java:25 
DECISION 10 in rule listValue
2025-04-15 23:27:07:163 LL1 LogManager.java:25 look=[48, {1, 28..32, 35, 43, 52}]
2025-04-15 23:27:07:163 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:163 LL1 LogManager.java:25 
DECISION 11 in rule value
2025-04-15 23:27:07:164 LL1 LogManager.java:25 look=[28, {29..30}, 1, 32, 31, {1, 28..30, 35, 52}, {28..30, 52}, {28, 31..32}]
2025-04-15 23:27:07:164 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:164 LL1 LogManager.java:25 
DECISION 12 in rule mainCode
2025-04-15 23:27:07:164 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-15 23:27:07:164 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:164 LL1 LogManager.java:25 
DECISION 13 in rule mainCode
2025-04-15 23:27:07:164 LL1 LogManager.java:25 look=[7, 7]
2025-04-15 23:27:07:164 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:164 LL1 LogManager.java:25 
DECISION 14 in rule inst
2025-04-15 23:27:07:164 LL1 LogManager.java:25 look=[3, 2, 28, 18, 17, 9, 13, 19]
2025-04-15 23:27:07:164 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:164 LL1 LogManager.java:25 
DECISION 15 in rule content
2025-04-15 23:27:07:164 LL1 LogManager.java:25 look=[{28, 31}, {28, 31}]
2025-04-15 23:27:07:164 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:164 LL1 LogManager.java:25 
DECISION 16 in rule content
2025-04-15 23:27:07:164 LL1 LogManager.java:25 look=[{28, 31}, {28, 31}]
2025-04-15 23:27:07:164 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:164 LL1 LogManager.java:25 
DECISION 17 in rule affectInst
2025-04-15 23:27:07:164 LL1 LogManager.java:25 look=[{1, 28..32, 35, 52}, 43]
2025-04-15 23:27:07:164 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:164 LL1 LogManager.java:25 
DECISION 18 in rule affectInst
2025-04-15 23:27:07:165 LL1 LogManager.java:25 look=[28, 28, 28, 28]
2025-04-15 23:27:07:165 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:165 LL1 LogManager.java:25 
DECISION 19 in rule concatInst
2025-04-15 23:27:07:165 LL1 LogManager.java:25 look=[31, 32, 28]
2025-04-15 23:27:07:165 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:165 LL1 LogManager.java:25 
DECISION 20 in rule concatInst
2025-04-15 23:27:07:165 LL1 LogManager.java:25 look=[28, 31, 32]
2025-04-15 23:27:07:165 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:165 LL1 LogManager.java:25 
DECISION 21 in rule concatInst
2025-04-15 23:27:07:165 LL1 LogManager.java:25 look=[33, {1, 28..32, 35, 43, 48..49, 52}]
2025-04-15 23:27:07:165 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:165 LL1 LogManager.java:25 
DECISION 22 in rule arithmeticExpression
2025-04-15 23:27:07:165 LL1 LogManager.java:25 look=[{28..30}, 52]
2025-04-15 23:27:07:165 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:165 LL1 LogManager.java:25 
DECISION 23 in rule arithmeticExpression
2025-04-15 23:27:07:165 LL1 LogManager.java:25 look=[null, null]
2025-04-15 23:27:07:165 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:165 LL1 LogManager.java:25 
DECISION 24 in rule arithmeticExpression
2025-04-15 23:27:07:166 LL1 LogManager.java:25 look=[null, null]
2025-04-15 23:27:07:166 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:166 LL1 LogManager.java:25 
DECISION 25 in rule operator
2025-04-15 23:27:07:166 LL1 LogManager.java:25 look=[{29..30}, 28]
2025-04-15 23:27:07:166 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:166 LL1 LogManager.java:25 
DECISION 26 in rule var
2025-04-15 23:27:07:166 LL1 LogManager.java:25 look=[28, 28]
2025-04-15 23:27:07:166 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:166 LL1 LogManager.java:25 
DECISION 27 in rule forInst
2025-04-15 23:27:07:166 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-15 23:27:07:166 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:166 LL1 LogManager.java:25 
DECISION 28 in rule doWhileInst
2025-04-15 23:27:07:166 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-15 23:27:07:166 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:166 LL1 LogManager.java:25 
DECISION 29 in rule whileInst
2025-04-15 23:27:07:166 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-15 23:27:07:166 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:166 LL1 LogManager.java:25 
DECISION 30 in rule ifInst
2025-04-15 23:27:07:166 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-15 23:27:07:166 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:166 LL1 LogManager.java:25 
DECISION 31 in rule ifInst
2025-04-15 23:27:07:166 LL1 LogManager.java:25 look=[11, {2..3, 9..10, 13, 15, 17..19, 28, 43}]
2025-04-15 23:27:07:166 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:166 LL1 LogManager.java:25 
DECISION 32 in rule ifInst
2025-04-15 23:27:07:167 LL1 LogManager.java:25 look=[10, {2..3, 9, 13, 15, 17..19, 28, 43}]
2025-04-15 23:27:07:167 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:167 LL1 LogManager.java:25 
DECISION 33 in rule elseIfInst
2025-04-15 23:27:07:167 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-15 23:27:07:167 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:167 LL1 LogManager.java:25 
DECISION 34 in rule elseIfInst
2025-04-15 23:27:07:167 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-15 23:27:07:167 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:167 LL1 LogManager.java:25 
DECISION 35 in rule elseIfInst
2025-04-15 23:27:07:167 LL1 LogManager.java:25 look=[11, 11]
2025-04-15 23:27:07:167 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:167 LL1 LogManager.java:25 
DECISION 36 in rule elseInst
2025-04-15 23:27:07:167 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-15 23:27:07:167 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:167 LL1 LogManager.java:25 
DECISION 37 in rule caseValue
2025-04-15 23:27:07:167 LL1 LogManager.java:25 look=[{29..30}, 1, 32, 31]
2025-04-15 23:27:07:167 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:167 LL1 LogManager.java:25 
DECISION 38 in rule caseInst
2025-04-15 23:27:07:167 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 15]
2025-04-15 23:27:07:167 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:167 LL1 LogManager.java:25 
DECISION 39 in rule caseInst
2025-04-15 23:27:07:167 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 15]
2025-04-15 23:27:07:167 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:167 LL1 LogManager.java:25 
DECISION 40 in rule caseInst
2025-04-15 23:27:07:167 LL1 LogManager.java:25 look=[14, 14]
2025-04-15 23:27:07:167 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:167 LL1 LogManager.java:25 
DECISION 41 in rule defaultInst
2025-04-15 23:27:07:167 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 15]
2025-04-15 23:27:07:168 LL1 LogManager.java:25 LL(1)? true
2025-04-15 23:27:07:168 LL1 LogManager.java:25 
DECISION 42 in rule condition
2025-04-15 23:27:07:168 LL1 LogManager.java:25 look=[52, 35, {28..30, 52}, 28, 1]
2025-04-15 23:27:07:168 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:168 LL1 LogManager.java:25 
DECISION 43 in rule condition
2025-04-15 23:27:07:168 LL1 LogManager.java:25 look=[null, null]
2025-04-15 23:27:07:168 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:168 LL1 LogManager.java:25 
DECISION 44 in rule condition
2025-04-15 23:27:07:168 LL1 LogManager.java:25 look=[null, null]
2025-04-15 23:27:07:168 LL1 LogManager.java:25 LL(1)? false
2025-04-15 23:27:07:169 action-translator LogManager.java:25 translate 
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();

2025-04-15 23:27:07:170 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;

2025-04-15 23:27:07:196 action-translator LogManager.java:25 translate types.clear();
2025-04-15 23:27:07:198 action-translator LogManager.java:25 translate 
this.types.add($value.type);
    for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$value.text,types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }

2025-04-15 23:27:07:198 action-translator LogManager.java:25 qattr [@-1,18:22='value',<0>,114:16].[@-1,24:27='type',<0>,114:22]
2025-04-15 23:27:07:200 action-translator LogManager.java:25 qattr [@-1,52:58='listIDF',<0>,115:20].[@-1,60:62='ctx',<0>,115:28]
2025-04-15 23:27:07:202 action-translator LogManager.java:25 qattr [@-1,144:161='declarationKeyword',<0>,116:60].[@-1,163:165='mul',<0>,116:79]
2025-04-15 23:27:07:203 action-translator LogManager.java:25 qattr [@-1,169:172='TYPE',<0>,116:85].[@-1,174:177='text',<0>,116:90]
2025-04-15 23:27:07:203 action-translator LogManager.java:25 qattr [@-1,180:184='value',<0>,116:96].[@-1,186:189='text',<0>,116:102]
2025-04-15 23:27:07:205 action-translator LogManager.java:25 translate 
        for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
       
2025-04-15 23:27:07:205 action-translator LogManager.java:25 qattr [@-1,26:32='listIDF',<0>,122:24].[@-1,34:36='ctx',<0>,122:32]
2025-04-15 23:27:07:205 action-translator LogManager.java:25 qattr [@-1,113:130='declarationKeyword',<0>,123:55].[@-1,132:134='mul',<0>,123:74]
2025-04-15 23:27:07:205 action-translator LogManager.java:25 qattr [@-1,138:141='TYPE',<0>,123:80].[@-1,143:146='text',<0>,123:85]
2025-04-15 23:27:07:206 action-translator LogManager.java:25 translate  $type = new ErrorToken($INT.text,"INT",$INT.line,$INT.pos); 
2025-04-15 23:27:07:206 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,128:41] [@-1,8:58=' new ErrorToken($INT.text,"INT",$INT.line,$INT.pos)',<0>,128:47]
2025-04-15 23:27:07:206 action-translator LogManager.java:25 translate  new ErrorToken($INT.text,"INT",$INT.line,$INT.pos)
2025-04-15 23:27:07:206 action-translator LogManager.java:25 qattr [@-1,17:19='INT',<0>,128:56].[@-1,21:24='text',<0>,128:60]
2025-04-15 23:27:07:206 action-translator LogManager.java:25 qattr [@-1,33:35='INT',<0>,128:72].[@-1,37:40='line',<0>,128:76]
2025-04-15 23:27:07:217 action-translator LogManager.java:25 qattr [@-1,43:45='INT',<0>,128:82].[@-1,47:49='pos',<0>,128:86]
2025-04-15 23:27:07:219 action-translator LogManager.java:25 translate  $type = new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos); 
2025-04-15 23:27:07:220 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,128:115] [@-1,8:66=' new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos)',<0>,128:121]
2025-04-15 23:27:07:220 action-translator LogManager.java:25 translate  new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos)
2025-04-15 23:27:07:220 action-translator LogManager.java:25 qattr [@-1,17:21='FLOAT',<0>,128:130].[@-1,23:26='text',<0>,128:136]
2025-04-15 23:27:07:220 action-translator LogManager.java:25 qattr [@-1,37:41='FLOAT',<0>,128:150].[@-1,43:46='line',<0>,128:156]
2025-04-15 23:27:07:221 action-translator LogManager.java:25 qattr [@-1,49:53='FLOAT',<0>,128:162].[@-1,55:57='pos',<0>,128:168]
2025-04-15 23:27:07:227 action-translator LogManager.java:25 translate types.clear();
2025-04-15 23:27:07:228 action-translator LogManager.java:25 translate 
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }

2025-04-15 23:27:07:229 action-translator LogManager.java:25 qattr [@-1,20:26='listIDF',<0>,131:18].[@-1,28:30='ctx',<0>,131:26]
2025-04-15 23:27:07:231 action-translator LogManager.java:25 qattr [@-1,116:133='declarationKeyword',<0>,132:64].[@-1,135:137='mul',<0>,132:83]
2025-04-15 23:27:07:231 action-translator LogManager.java:25 qattr [@-1,141:144='TYPE',<0>,132:89].[@-1,146:149='text',<0>,132:94]
2025-04-15 23:27:07:231 action-translator LogManager.java:25 qattr [@-1,152:154='INT',<0>,132:100].[@-1,156:159='text',<0>,132:104]
2025-04-15 23:27:07:232 action-translator LogManager.java:25 translate 
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,this.types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }

2025-04-15 23:27:07:232 action-translator LogManager.java:25 qattr [@-1,20:26='listIDF',<0>,137:18].[@-1,28:30='ctx',<0>,137:26]
2025-04-15 23:27:07:232 action-translator LogManager.java:25 qattr [@-1,116:133='declarationKeyword',<0>,138:64].[@-1,135:137='mul',<0>,138:83]
2025-04-15 23:27:07:232 action-translator LogManager.java:25 qattr [@-1,141:144='TYPE',<0>,138:89].[@-1,146:149='text',<0>,138:94]
2025-04-15 23:27:07:232 action-translator LogManager.java:25 qattr [@-1,152:154='INT',<0>,138:100].[@-1,156:159='text',<0>,138:104]
2025-04-15 23:27:07:235 action-translator LogManager.java:25 translate 
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }

2025-04-15 23:27:07:235 action-translator LogManager.java:25 qattr [@-1,20:26='listIDF',<0>,144:18].[@-1,28:30='ctx',<0>,144:26]
2025-04-15 23:27:07:235 action-translator LogManager.java:25 qattr [@-1,111:128='declarationKeyword',<0>,145:59].[@-1,130:132='mul',<0>,145:78]
2025-04-15 23:27:07:235 action-translator LogManager.java:25 qattr [@-1,136:139='TYPE',<0>,145:84].[@-1,141:144='text',<0>,145:89]
2025-04-15 23:27:07:235 action-translator LogManager.java:25 qattr [@-1,147:149='INT',<0>,145:95].[@-1,151:154='text',<0>,145:99]
2025-04-15 23:27:07:239 action-translator LogManager.java:25 translate $mul = "Constant";
2025-04-15 23:27:07:239 action-translator LogManager.java:25 setAttr [@-1,1:3='mul',<0>,150:54] [@-1,6:16=' "Constant"',<0>,150:59]
2025-04-15 23:27:07:239 action-translator LogManager.java:25 translate  "Constant"
2025-04-15 23:27:07:239 action-translator LogManager.java:25 translate $mul = "Variable";
2025-04-15 23:27:07:239 action-translator LogManager.java:25 setAttr [@-1,1:3='mul',<0>,150:81] [@-1,6:16=' "Variable"',<0>,150:86]
2025-04-15 23:27:07:239 action-translator LogManager.java:25 translate  "Variable"
2025-04-15 23:27:07:240 action-translator LogManager.java:25 translate ErrorToken type_1 = $v1.type; type_1.exp = $v1.text; this.types.add(type_1); 
2025-04-15 23:27:07:240 action-translator LogManager.java:25 qattr [@-1,21:22='v1',<0>,151:41].[@-1,24:27='type',<0>,151:44]
2025-04-15 23:27:07:240 action-translator LogManager.java:25 qattr [@-1,44:45='v1',<0>,151:64].[@-1,47:50='text',<0>,151:67]
2025-04-15 23:27:07:240 action-translator LogManager.java:25 translate  ErrorToken type_2 = $v.type; type_2.exp = $v.text; this.types.add(type_2);
2025-04-15 23:27:07:241 action-translator LogManager.java:25 qattr [@-1,22:22='v',<0>,151:136].[@-1,24:27='type',<0>,151:138]
2025-04-15 23:27:07:241 action-translator LogManager.java:25 qattr [@-1,44:44='v',<0>,151:158].[@-1,46:49='text',<0>,151:160]
2025-04-15 23:27:07:241 action-translator LogManager.java:25 translate this.boolList.clear(); this.compareList.clear(); this.concatList.clear(); this.arithmeticList.clear();
2025-04-15 23:27:07:241 action-translator LogManager.java:25 translate $type= $var.type;
2025-04-15 23:27:07:241 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,152:150] [@-1,6:15=' $var.type',<0>,152:155]
2025-04-15 23:27:07:241 action-translator LogManager.java:25 translate  $var.type
2025-04-15 23:27:07:241 action-translator LogManager.java:25 qattr [@-1,2:4='var',<0>,152:151].[@-1,6:9='type',<0>,152:155]
2025-04-15 23:27:07:241 action-translator LogManager.java:25 translate $type = $number.type;
2025-04-15 23:27:07:242 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,152:178] [@-1,7:19=' $number.type',<0>,152:184]
2025-04-15 23:27:07:242 action-translator LogManager.java:25 translate  $number.type
2025-04-15 23:27:07:242 action-translator LogManager.java:25 qattr [@-1,2:7='number',<0>,152:179].[@-1,9:12='type',<0>,152:186]
2025-04-15 23:27:07:242 action-translator LogManager.java:25 translate $type = new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos);
2025-04-15 23:27:07:242 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,152:217] [@-1,7:85=' new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos)',<0>,152:223]
2025-04-15 23:27:07:242 action-translator LogManager.java:25 translate  new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos)
2025-04-15 23:27:07:242 action-translator LogManager.java:25 qattr [@-1,17:28='BOOLEANVALUE',<0>,152:233].[@-1,30:33='text',<0>,152:246]
2025-04-15 23:27:07:242 action-translator LogManager.java:25 qattr [@-1,43:54='BOOLEANVALUE',<0>,152:259].[@-1,56:59='line',<0>,152:272]
2025-04-15 23:27:07:242 action-translator LogManager.java:25 qattr [@-1,62:73='BOOLEANVALUE',<0>,152:278].[@-1,75:77='pos',<0>,152:291]
2025-04-15 23:27:07:242 action-translator LogManager.java:25 translate $type = new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos); 
2025-04-15 23:27:07:242 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,152:314] [@-1,7:61=' new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos)',<0>,152:320]
2025-04-15 23:27:07:242 action-translator LogManager.java:25 translate  new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos)
2025-04-15 23:27:07:242 action-translator LogManager.java:25 qattr [@-1,17:20='CHAR',<0>,152:330].[@-1,22:25='text',<0>,152:335]
2025-04-15 23:27:07:242 action-translator LogManager.java:25 qattr [@-1,35:38='CHAR',<0>,152:348].[@-1,40:43='line',<0>,152:353]
2025-04-15 23:27:07:242 action-translator LogManager.java:25 qattr [@-1,46:49='CHAR',<0>,152:359].[@-1,51:53='pos',<0>,152:364]
2025-04-15 23:27:07:243 action-translator LogManager.java:25 translate $type = new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos);
2025-04-15 23:27:07:243 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,152:390] [@-1,7:69=' new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos)',<0>,152:396]
2025-04-15 23:27:07:243 action-translator LogManager.java:25 translate  new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos)
2025-04-15 23:27:07:243 action-translator LogManager.java:25 qattr [@-1,17:22='STRING',<0>,152:406].[@-1,24:27='text',<0>,152:413]
2025-04-15 23:27:07:243 action-translator LogManager.java:25 qattr [@-1,39:44='STRING',<0>,152:428].[@-1,46:49='line',<0>,152:435]
2025-04-15 23:27:07:243 action-translator LogManager.java:25 qattr [@-1,52:57='STRING',<0>,152:441].[@-1,59:61='pos',<0>,152:448]
2025-04-15 23:27:07:243 action-translator LogManager.java:25 translate $type = IDF_HashTable.table.conditionType(this.boolList,this.compareList);
2025-04-15 23:27:07:243 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,152:477] [@-1,7:72=' IDF_HashTable.table.conditionType(this.boolList,this.compareList)',<0>,152:483]
2025-04-15 23:27:07:243 action-translator LogManager.java:25 translate  IDF_HashTable.table.conditionType(this.boolList,this.compareList)
2025-04-15 23:27:07:244 action-translator LogManager.java:25 translate $type=IDF_HashTable.table.getType(this.arithmeticList,0);
2025-04-15 23:27:07:244 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,152:576] [@-1,6:55='IDF_HashTable.table.getType(this.arithmeticList,0)',<0>,152:581]
2025-04-15 23:27:07:244 action-translator LogManager.java:25 translate IDF_HashTable.table.getType(this.arithmeticList,0)
2025-04-15 23:27:07:244 action-translator LogManager.java:25 translate $type=IDF_HashTable.table.getType(this.concatList,1);
2025-04-15 23:27:07:244 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,152:649] [@-1,6:51='IDF_HashTable.table.getType(this.concatList,1)',<0>,152:654]
2025-04-15 23:27:07:244 action-translator LogManager.java:25 translate IDF_HashTable.table.getType(this.concatList,1)
2025-04-15 23:27:07:247 action-translator LogManager.java:25 translate  this.types.clear(); 
2025-04-15 23:27:07:247 action-translator LogManager.java:25 translate  
  IDF_HashTable.table.affectMONO($var_2.text,$var_1.type, $var_2.type,$var_1.start.getLine(),$var_1.start.getCharPositionInLine());

2025-04-15 23:27:07:247 action-translator LogManager.java:25 qattr [@-1,37:41='var_2',<0>,161:34].[@-1,43:46='text',<0>,161:40]
2025-04-15 23:27:07:247 action-translator LogManager.java:25 qattr [@-1,49:53='var_1',<0>,161:46].[@-1,55:58='type',<0>,161:52]
2025-04-15 23:27:07:247 action-translator LogManager.java:25 qattr [@-1,62:66='var_2',<0>,161:59].[@-1,68:71='type',<0>,161:65]
2025-04-15 23:27:07:247 action-translator LogManager.java:25 qattr [@-1,74:78='var_1',<0>,161:71].[@-1,80:84='start',<0>,161:77]
2025-04-15 23:27:07:247 action-translator LogManager.java:25 qattr [@-1,97:101='var_1',<0>,161:94].[@-1,103:107='start',<0>,161:100]
2025-04-15 23:27:07:247 action-translator LogManager.java:25 translate 
 	IDF_HashTable.table.affectEXP($value.text,$var.type, $value.type,$var.start.getLine(),$var.start.getCharPositionInLine());
	

2025-04-15 23:27:07:247 action-translator LogManager.java:25 qattr [@-1,35:39='value',<0>,165:33].[@-1,41:44='text',<0>,165:39]
2025-04-15 23:27:07:247 action-translator LogManager.java:25 qattr [@-1,47:49='var',<0>,165:45].[@-1,51:54='type',<0>,165:49]
2025-04-15 23:27:07:247 action-translator LogManager.java:25 qattr [@-1,58:62='value',<0>,165:56].[@-1,64:67='type',<0>,165:62]
2025-04-15 23:27:07:247 action-translator LogManager.java:25 qattr [@-1,70:72='var',<0>,165:68].[@-1,74:78='start',<0>,165:72]
2025-04-15 23:27:07:247 action-translator LogManager.java:25 qattr [@-1,91:93='var',<0>,165:89].[@-1,95:99='start',<0>,165:93]
2025-04-15 23:27:07:248 action-translator LogManager.java:25 translate 
  IDF_HashTable.table.affectArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos),this.types, $IDF.line,$IDF.pos);

2025-04-15 23:27:07:248 action-translator LogManager.java:25 qattr [@-1,37:39='IDF',<0>,170:35].[@-1,41:44='text',<0>,170:39]
2025-04-15 23:27:07:248 action-translator LogManager.java:25 qattr [@-1,91:93='IDF',<0>,170:89].[@-1,95:98='text',<0>,170:93]
2025-04-15 23:27:07:248 action-translator LogManager.java:25 qattr [@-1,101:103='IDF',<0>,170:99].[@-1,105:108='line',<0>,170:103]
2025-04-15 23:27:07:248 action-translator LogManager.java:25 qattr [@-1,111:113='IDF',<0>,170:109].[@-1,115:117='pos',<0>,170:113]
2025-04-15 23:27:07:248 action-translator LogManager.java:25 qattr [@-1,133:135='IDF',<0>,170:131].[@-1,137:140='line',<0>,170:135]
2025-04-15 23:27:07:248 action-translator LogManager.java:25 qattr [@-1,143:145='IDF',<0>,170:141].[@-1,147:149='pos',<0>,170:145]
2025-04-15 23:27:07:248 action-translator LogManager.java:25 translate 
  IDF_HashTable.table.affectEmptyArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos), $IDF.line,$IDF.pos);

2025-04-15 23:27:07:248 action-translator LogManager.java:25 qattr [@-1,42:44='IDF',<0>,174:40].[@-1,46:49='text',<0>,174:44]
2025-04-15 23:27:07:248 action-translator LogManager.java:25 qattr [@-1,96:98='IDF',<0>,174:94].[@-1,100:103='text',<0>,174:98]
2025-04-15 23:27:07:248 action-translator LogManager.java:25 qattr [@-1,106:108='IDF',<0>,174:104].[@-1,110:113='line',<0>,174:108]
2025-04-15 23:27:07:248 action-translator LogManager.java:25 qattr [@-1,116:118='IDF',<0>,174:114].[@-1,120:122='pos',<0>,174:118]
2025-04-15 23:27:07:249 action-translator LogManager.java:25 qattr [@-1,127:129='IDF',<0>,174:125].[@-1,131:134='line',<0>,174:129]
2025-04-15 23:27:07:249 action-translator LogManager.java:25 qattr [@-1,137:139='IDF',<0>,174:135].[@-1,141:143='pos',<0>,174:139]
2025-04-15 23:27:07:250 action-translator LogManager.java:25 translate this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));
2025-04-15 23:27:07:250 action-translator LogManager.java:25 qattr [@-1,36:41='STRING',<0>,178:57].[@-1,43:46='text',<0>,178:64]
2025-04-15 23:27:07:250 action-translator LogManager.java:25 qattr [@-1,58:63='STRING',<0>,178:79].[@-1,65:68='line',<0>,178:86]
2025-04-15 23:27:07:250 action-translator LogManager.java:25 qattr [@-1,71:76='STRING',<0>,178:92].[@-1,78:80='pos',<0>,178:99]
2025-04-15 23:27:07:250 action-translator LogManager.java:25 translate this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));
2025-04-15 23:27:07:251 action-translator LogManager.java:25 qattr [@-1,36:39='CHAR',<0>,178:150].[@-1,41:44='text',<0>,178:155]
2025-04-15 23:27:07:251 action-translator LogManager.java:25 qattr [@-1,56:59='CHAR',<0>,178:170].[@-1,61:64='line',<0>,178:175]
2025-04-15 23:27:07:251 action-translator LogManager.java:25 qattr [@-1,67:70='CHAR',<0>,178:181].[@-1,72:74='pos',<0>,178:186]
2025-04-15 23:27:07:251 action-translator LogManager.java:25 translate this.concatList.add($var.type);
2025-04-15 23:27:07:251 action-translator LogManager.java:25 qattr [@-1,21:23='var',<0>,178:221].[@-1,25:28='type',<0>,178:225]
2025-04-15 23:27:07:251 action-translator LogManager.java:25 translate this.concatList.add($var.type);
2025-04-15 23:27:07:251 action-translator LogManager.java:25 qattr [@-1,21:23='var',<0>,178:268].[@-1,25:28='type',<0>,178:272]
2025-04-15 23:27:07:252 action-translator LogManager.java:25 translate this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));
2025-04-15 23:27:07:252 action-translator LogManager.java:25 qattr [@-1,36:41='STRING',<0>,178:324].[@-1,43:46='text',<0>,178:331]
2025-04-15 23:27:07:252 action-translator LogManager.java:25 qattr [@-1,58:63='STRING',<0>,178:346].[@-1,65:68='line',<0>,178:353]
2025-04-15 23:27:07:252 action-translator LogManager.java:25 qattr [@-1,71:76='STRING',<0>,178:359].[@-1,78:80='pos',<0>,178:366]
2025-04-15 23:27:07:252 action-translator LogManager.java:25 translate this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));
2025-04-15 23:27:07:252 action-translator LogManager.java:25 qattr [@-1,36:39='CHAR',<0>,178:415].[@-1,41:44='text',<0>,178:420]
2025-04-15 23:27:07:252 action-translator LogManager.java:25 qattr [@-1,56:59='CHAR',<0>,178:435].[@-1,61:64='line',<0>,178:440]
2025-04-15 23:27:07:253 action-translator LogManager.java:25 qattr [@-1,67:70='CHAR',<0>,178:446].[@-1,72:74='pos',<0>,178:451]
2025-04-15 23:27:07:254 action-translator LogManager.java:25 translate 
2025-04-15 23:27:07:254 action-translator LogManager.java:25 translate this.arithmeticList.add($operator.type);
2025-04-15 23:27:07:254 action-translator LogManager.java:25 qattr [@-1,25:32='operator',<0>,2:64].[@-1,34:37='type',<0>,2:73]
2025-04-15 23:27:07:255 action-translator LogManager.java:25 translate precpred(_ctx, 4)
2025-04-15 23:27:07:255 action-translator LogManager.java:25 translate if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}
2025-04-15 23:27:07:255 action-translator LogManager.java:25 qattr [@-1,4:5='op',<0>,6:136].[@-1,7:10='type',<0>,6:139]
2025-04-15 23:27:07:255 action-translator LogManager.java:25 qattr [@-1,95:97='ari',<0>,6:227].[@-1,99:102='text',<0>,6:231]
2025-04-15 23:27:07:256 action-translator LogManager.java:25 qattr [@-1,106:108='ari',<0>,6:238].[@-1,110:114='start',<0>,6:242]
2025-04-15 23:27:07:256 action-translator LogManager.java:25 qattr [@-1,128:130='ari',<0>,6:260].[@-1,132:136='start',<0>,6:264]
2025-04-15 23:27:07:256 action-translator LogManager.java:25 translate precpred(_ctx, 3)
2025-04-15 23:27:07:257 action-translator LogManager.java:25 translate precpred(_ctx, 4)
2025-04-15 23:27:07:257 action-translator LogManager.java:25 translate precpred(_ctx, 3)
2025-04-15 23:27:07:257 action-translator LogManager.java:25 translate $type = $number.type;
2025-04-15 23:27:07:258 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,180:44] [@-1,7:19=' $number.type',<0>,180:50]
2025-04-15 23:27:07:258 action-translator LogManager.java:25 translate  $number.type
2025-04-15 23:27:07:258 action-translator LogManager.java:25 qattr [@-1,2:7='number',<0>,180:45].[@-1,9:12='type',<0>,180:52]
2025-04-15 23:27:07:258 action-translator LogManager.java:25 translate $type = $var.type;
2025-04-15 23:27:07:258 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,180:74] [@-1,7:16=' $var.type',<0>,180:80]
2025-04-15 23:27:07:258 action-translator LogManager.java:25 translate  $var.type
2025-04-15 23:27:07:258 action-translator LogManager.java:25 qattr [@-1,2:4='var',<0>,180:75].[@-1,6:9='type',<0>,180:79]
2025-04-15 23:27:07:259 action-translator LogManager.java:25 translate $type = IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos); 
2025-04-15 23:27:07:259 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,181:36] [@-1,7:80=' IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos)',<0>,181:42]
2025-04-15 23:27:07:259 action-translator LogManager.java:25 translate  IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos)
2025-04-15 23:27:07:259 action-translator LogManager.java:25 qattr [@-1,46:48='IDF',<0>,181:81].[@-1,50:53='text',<0>,181:85]
2025-04-15 23:27:07:259 action-translator LogManager.java:25 qattr [@-1,56:58='IDF',<0>,181:91].[@-1,60:63='line',<0>,181:95]
2025-04-15 23:27:07:259 action-translator LogManager.java:25 qattr [@-1,66:68='IDF',<0>,181:101].[@-1,70:72='pos',<0>,181:105]
2025-04-15 23:27:07:259 action-translator LogManager.java:25 translate $type = IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos);
2025-04-15 23:27:07:259 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,181:140] [@-1,7:89=' IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos)',<0>,181:146]
2025-04-15 23:27:07:259 action-translator LogManager.java:25 translate  IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos)
2025-04-15 23:27:07:260 action-translator LogManager.java:25 qattr [@-1,45:47='IDF',<0>,181:184].[@-1,49:52='text',<0>,181:188]
2025-04-15 23:27:07:260 action-translator LogManager.java:25 qattr [@-1,55:57='INT',<0>,181:194].[@-1,59:62='text',<0>,181:198]
2025-04-15 23:27:07:260 action-translator LogManager.java:25 qattr [@-1,65:67='IDF',<0>,181:204].[@-1,69:72='line',<0>,181:208]
2025-04-15 23:27:07:260 action-translator LogManager.java:25 qattr [@-1,75:77='IDF',<0>,181:214].[@-1,79:81='pos',<0>,181:218]
2025-04-15 23:27:07:268 action-translator LogManager.java:25 translate 
2025-04-15 23:27:07:268 action-translator LogManager.java:25 translate this.boolList.add($var.type);
2025-04-15 23:27:07:268 action-translator LogManager.java:25 qattr [@-1,19:21='var',<0>,5:50].[@-1,23:26='type',<0>,5:54]
2025-04-15 23:27:07:268 action-translator LogManager.java:25 translate precpred(_ctx, 5)
2025-04-15 23:27:07:269 action-translator LogManager.java:25 translate precpred(_ctx, 4)
2025-04-15 23:27:07:269 action-translator LogManager.java:25 translate precpred(_ctx, 5)
2025-04-15 23:27:07:269 action-translator LogManager.java:25 translate precpred(_ctx, 4)
2025-04-15 23:27:07:269 action-translator LogManager.java:25 translate this.compareList.addAll(this.arithmeticList); 
2025-04-15 23:27:07:368 action-translator LogManager.java:25 translate 
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();

2025-04-15 23:27:07:368 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;

2025-04-15 23:27:07:368 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;

2025-04-15 23:27:07:374 action-translator LogManager.java:25 translate 
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();

2025-04-15 23:27:07:374 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;

2025-04-15 23:27:07:374 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;

