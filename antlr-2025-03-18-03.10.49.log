2025-03-18 03:10:48:676 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Expr (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (@ lexer members {
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }

}) (RULES (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE ARITHMETICOPERATOR (RULEMODIFIERS fragment) (BLOCK (ALT [+/*\-]))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE TYPE (BLOCK (ALT 'Int') (ALT 'Float' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE VAR (BLOCK (ALT 'Var' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE END (BLOCK (ALT 'EndPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IF (BLOCK (ALT 'if' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSE (BLOCK (ALT 'else' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSIF (BLOCK (ALT 'elsif'))) (RULE THEN (BLOCK (ALT 'then' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DO (BLOCK (ALT 'do' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FOR (BLOCK (ALT 'for' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FROM (BLOCK (ALT 'from' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE TO (BLOCK (ALT 'to' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE STEP (BLOCK (ALT 'step' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE AND (BLOCK (ALT 'AND' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE OR (BLOCK (ALT 'OR' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE LET (BLOCK (ALT 'let' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DEFINE (BLOCK (ALT '@Define' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE CONST (BLOCK (ALT 'const' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (* (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());}))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) {validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.' {printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {printToken(getText(),"String Constant",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE COMPARAISONOPERATOR (BLOCK (ALT '<') (ALT '>') (ALT '>=') (ALT '<=') (ALT '==') (ALT '!='))) (RULE LBRACE (BLOCK (ALT '{'))) (RULE RBRACE (BLOCK (ALT '}'))) (RULE Separators (BLOCK (ALT '(') (ALT ')') (ALT '=') (ALT ';') (ALT '{') (ALT '}') (ALT '[') (ALT ']') (ALT ':') (ALT ',') (ALT ARITHMETICOPERATOR) (ALT COMPARAISONOPERATOR {printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COMMENT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT {printToken(getText(),"Comment",getLine(),getCharPositionInLine());}))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT . {System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());System.exit(1);}))) (RULE prog (BLOCK (ALT (* (BLOCK (ALT COMMENT))) MAIN IDF ';' (* (BLOCK (ALT COMMENT))) varBlock (* (BLOCK (ALT COMMENT))) mainCode (* (BLOCK (ALT COMMENT))) EOF {IDF_HashTable.table.printTable();}))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration) (ALT COMMENT))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' affectValue ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }
}))) (RULE sign (BLOCK (ALT '+') (ALT '-'))) (RULE affectValue (returns String type) (BLOCK (ALT number {$type = $number.type;}))) (RULE number (returns String type) (BLOCK (ALT '(' sign INT ')' { $type = "INT"; }) (ALT '(' sign FLOAT ')' { $type = "FLOAT"; }) (ALT INT { $type = "INT"; }) (ALT FLOAT { $type = "FLOAT"; }))) (RULE arrayDeclaration (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' affectArray ';') (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';'))) (RULE affectArray (BLOCK (ALT '=' '{' listNumber '}'))) (RULE declarationKeyword (BLOCK (ALT DEFINE CONST) (ALT LET))) (RULE listNumber (BLOCK (ALT number (* (BLOCK (ALT ',' number)))))) (RULE mainCode (BLOCK (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' (+ (BLOCK (ALT inst))) '}' (* (BLOCK (ALT COMMENT))) END ';') (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' '}' (* (BLOCK (ALT COMMENT))) END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT COMMENT) (ALT forInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (BLOCK (ALT STRING) (ALT IDF)) ','))) (BLOCK (ALT STRING) (ALT IDF))) (ALT (BLOCK (ALT STRING) (ALT IDF))))) (RULE affectInst (BLOCK (ALT var AFFECT arithmeticExpression ';'))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression operation arithmeticExpression) (ALT '(' arithmeticExpression ')') (ALT operator))) (RULE operator (BLOCK (ALT number) (ALT var))) (RULE var (BLOCK (ALT IDF) (ALT IDF '[' INT ']'))) (RULE operation (BLOCK (ALT '+') (ALT '-') (ALT '*') (ALT '/'))) (RULE forInst (BLOCK (ALT FOR IDF (? (BLOCK (ALT operation arithmeticExpression))) FROM arithmeticExpression TO arithmeticExpression STEP arithmeticExpression '{' (+ (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (+ (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (+ (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' elseIfInst) (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSE '{' (+ (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseInst (BLOCK (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (+ (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT '(' condition ')') (ALT '!' '(' condition ')') (ALT condition logicalOperator condition) (ALT partCondition))) (RULE partCondition (BLOCK (ALT IDF COMPARAISONOPERATOR arithmeticExpression))) (RULE logicalOperator (BLOCK (ALT AND) (ALT OR) (ALT NOT)))))
2025-03-18 03:10:48:704 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Expr (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (@ lexer members {
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }

}) (RULES (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE ARITHMETICOPERATOR (RULEMODIFIERS fragment) (BLOCK (ALT [+/*\-]))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE TYPE (BLOCK (ALT 'Int') (ALT 'Float' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE VAR (BLOCK (ALT 'Var' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE END (BLOCK (ALT 'EndPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IF (BLOCK (ALT 'if' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSE (BLOCK (ALT 'else' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSIF (BLOCK (ALT 'elsif'))) (RULE THEN (BLOCK (ALT 'then' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DO (BLOCK (ALT 'do' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FOR (BLOCK (ALT 'for' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FROM (BLOCK (ALT 'from' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE TO (BLOCK (ALT 'to' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE STEP (BLOCK (ALT 'step' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE AND (BLOCK (ALT 'AND' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE OR (BLOCK (ALT 'OR' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE LET (BLOCK (ALT 'let' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DEFINE (BLOCK (ALT '@Define' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE CONST (BLOCK (ALT 'const' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (* (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());}))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) {validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.' {printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {printToken(getText(),"String Constant",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE COMPARAISONOPERATOR (BLOCK (ALT '<') (ALT '>') (ALT '>=') (ALT '<=') (ALT '==') (ALT '!='))) (RULE LBRACE (BLOCK (ALT '{'))) (RULE RBRACE (BLOCK (ALT '}'))) (RULE Separators (BLOCK (ALT '(') (ALT ')') (ALT '=') (ALT ';') (ALT '{') (ALT '}') (ALT '[') (ALT ']') (ALT ':') (ALT ',') (ALT ARITHMETICOPERATOR) (ALT COMPARAISONOPERATOR {printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COMMENT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT {printToken(getText(),"Comment",getLine(),getCharPositionInLine());}))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT . {System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());System.exit(1);}))) (RULE prog (BLOCK (ALT (* (BLOCK (ALT COMMENT))) MAIN IDF ';' (* (BLOCK (ALT COMMENT))) varBlock (* (BLOCK (ALT COMMENT))) mainCode (* (BLOCK (ALT COMMENT))) EOF {IDF_HashTable.table.printTable();}))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration) (ALT COMMENT))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' affectValue ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }
}))) (RULE sign (BLOCK (ALT (SET '+' '-')))) (RULE affectValue (returns String type) (BLOCK (ALT number {$type = $number.type;}))) (RULE number (returns String type) (BLOCK (ALT '(' sign INT ')' { $type = "INT"; }) (ALT '(' sign FLOAT ')' { $type = "FLOAT"; }) (ALT INT { $type = "INT"; }) (ALT FLOAT { $type = "FLOAT"; }))) (RULE arrayDeclaration (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' affectArray ';') (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';'))) (RULE affectArray (BLOCK (ALT '=' '{' listNumber '}'))) (RULE declarationKeyword (BLOCK (ALT DEFINE CONST) (ALT LET))) (RULE listNumber (BLOCK (ALT number (* (BLOCK (ALT ',' number)))))) (RULE mainCode (BLOCK (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' (+ (BLOCK (ALT inst))) '}' (* (BLOCK (ALT COMMENT))) END ';') (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' '}' (* (BLOCK (ALT COMMENT))) END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT COMMENT) (ALT forInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (BLOCK (ALT var AFFECT arithmeticExpression ';'))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression operation arithmeticExpression) (ALT '(' arithmeticExpression ')') (ALT operator))) (RULE operator (BLOCK (ALT number) (ALT var))) (RULE var (BLOCK (ALT IDF) (ALT IDF '[' INT ']'))) (RULE operation (BLOCK (ALT (SET '+' '-' '*' '/')))) (RULE forInst (BLOCK (ALT FOR IDF (? (BLOCK (ALT operation arithmeticExpression))) FROM arithmeticExpression TO arithmeticExpression STEP arithmeticExpression '{' (+ (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (+ (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (+ (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' elseIfInst) (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSE '{' (+ (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseInst (BLOCK (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (+ (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT '(' condition ')') (ALT '!' '(' condition ')') (ALT condition logicalOperator condition) (ALT partCondition))) (RULE partCondition (BLOCK (ALT IDF COMPARAISONOPERATOR arithmeticExpression))) (RULE logicalOperator (BLOCK (ALT (SET AND OR NOT))))))
2025-03-18 03:10:48:743 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Expr (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT COMMENT))) MAIN IDF ';' (* (BLOCK (ALT COMMENT))) varBlock (* (BLOCK (ALT COMMENT))) mainCode (* (BLOCK (ALT COMMENT))) EOF {IDF_HashTable.table.printTable();}))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration) (ALT COMMENT))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' affectValue ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }
}))) (RULE sign (BLOCK (ALT (SET '+' '-')))) (RULE affectValue (returns String type) (BLOCK (ALT number {$type = $number.type;}))) (RULE number (returns String type) (BLOCK (ALT '(' sign INT ')' { $type = "INT"; }) (ALT '(' sign FLOAT ')' { $type = "FLOAT"; }) (ALT INT { $type = "INT"; }) (ALT FLOAT { $type = "FLOAT"; }))) (RULE arrayDeclaration (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' affectArray ';') (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';'))) (RULE affectArray (BLOCK (ALT '=' '{' listNumber '}'))) (RULE declarationKeyword (BLOCK (ALT DEFINE CONST) (ALT LET))) (RULE listNumber (BLOCK (ALT number (* (BLOCK (ALT ',' number)))))) (RULE mainCode (BLOCK (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' (+ (BLOCK (ALT inst))) '}' (* (BLOCK (ALT COMMENT))) END ';') (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' '}' (* (BLOCK (ALT COMMENT))) END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT COMMENT) (ALT forInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (BLOCK (ALT var AFFECT arithmeticExpression ';'))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression operation arithmeticExpression) (ALT '(' arithmeticExpression ')') (ALT operator))) (RULE operator (BLOCK (ALT number) (ALT var))) (RULE var (BLOCK (ALT IDF) (ALT IDF '[' INT ']'))) (RULE operation (BLOCK (ALT (SET '+' '-' '*' '/')))) (RULE forInst (BLOCK (ALT FOR IDF (? (BLOCK (ALT operation arithmeticExpression))) FROM arithmeticExpression TO arithmeticExpression STEP arithmeticExpression '{' (+ (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (+ (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (+ (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' elseIfInst) (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSE '{' (+ (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseInst (BLOCK (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (+ (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT '(' condition ')') (ALT '!' '(' condition ')') (ALT condition logicalOperator condition) (ALT partCondition))) (RULE partCondition (BLOCK (ALT IDF COMPARAISONOPERATOR arithmeticExpression))) (RULE logicalOperator (BLOCK (ALT (SET AND OR NOT))))))
2025-03-18 03:10:48:744 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR ExprLexer (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (@ lexer members {
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }

}) (RULES (RULE T__0 (BLOCK (ALT ';'))) (RULE T__1 (BLOCK (ALT ','))) (RULE T__2 (BLOCK (ALT ':'))) (RULE T__3 (BLOCK (ALT '='))) (RULE T__4 (BLOCK (ALT '+'))) (RULE T__5 (BLOCK (ALT '-'))) (RULE T__6 (BLOCK (ALT '('))) (RULE T__7 (BLOCK (ALT ')'))) (RULE T__8 (BLOCK (ALT '['))) (RULE T__9 (BLOCK (ALT ']'))) (RULE T__10 (BLOCK (ALT '*'))) (RULE T__11 (BLOCK (ALT '/'))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE ARITHMETICOPERATOR (RULEMODIFIERS fragment) (BLOCK (ALT [+/*\-]))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE TYPE (BLOCK (ALT 'Int') (ALT 'Float' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE VAR (BLOCK (ALT 'Var' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE END (BLOCK (ALT 'EndPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IF (BLOCK (ALT 'if' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSE (BLOCK (ALT 'else' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSIF (BLOCK (ALT 'elsif'))) (RULE THEN (BLOCK (ALT 'then' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DO (BLOCK (ALT 'do' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FOR (BLOCK (ALT 'for' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FROM (BLOCK (ALT 'from' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE TO (BLOCK (ALT 'to' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE STEP (BLOCK (ALT 'step' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE AND (BLOCK (ALT 'AND' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE OR (BLOCK (ALT 'OR' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE LET (BLOCK (ALT 'let' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DEFINE (BLOCK (ALT '@Define' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE CONST (BLOCK (ALT 'const' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (* (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());}))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) {validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.' {printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {printToken(getText(),"String Constant",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE COMPARAISONOPERATOR (BLOCK (ALT '<') (ALT '>') (ALT '>=') (ALT '<=') (ALT '==') (ALT '!='))) (RULE LBRACE (BLOCK (ALT '{'))) (RULE RBRACE (BLOCK (ALT '}'))) (RULE Separators (BLOCK (ALT '(') (ALT ')') (ALT '=') (ALT ';') (ALT '{') (ALT '}') (ALT '[') (ALT ']') (ALT ':') (ALT ',') (ALT ARITHMETICOPERATOR) (ALT COMPARAISONOPERATOR {printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COMMENT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT {printToken(getText(),"Comment",getLine(),getCharPositionInLine());}))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT . {System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());System.exit(1);})))))
2025-03-18 03:10:48:971 action-translator LogManager.java:25 translate 
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }


2025-03-18 03:10:48:971 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-18 03:10:48:991 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:991 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:991 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:991 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:991 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:991 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:992 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:992 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:992 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:992 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:992 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:992 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:992 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:992 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:992 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:992 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:992 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:992 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:993 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:993 action-translator LogManager.java:25 translate validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());
2025-03-18 03:10:48:993 action-translator LogManager.java:25 translate validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());
2025-03-18 03:10:48:993 action-translator LogManager.java:25 translate printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:993 action-translator LogManager.java:25 translate printToken(getText(),"String Constant",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:993 action-translator LogManager.java:25 translate printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:993 action-translator LogManager.java:25 translate printToken(getText(),"Comment",getLine(),getCharPositionInLine());
2025-03-18 03:10:48:993 action-translator LogManager.java:25 translate System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());System.exit(1);
2025-03-18 03:10:49:097 left-recursion LogManager.java:25 arithmeticExpression
    :   ( {} '('<tokenIndex=862> arithmeticExpression<tokenIndex=864> ')'<tokenIndex=866> 
        | operator<tokenIndex=870> 
        )
        (
          {precpred(_ctx, 3)}?<p=3> operation<tokenIndex=856> arithmeticExpression<tokenIndex=858,p=4>
        )*
    ;
2025-03-18 03:10:49:103 grammar LogManager.java:25 added: (RULE arithmeticExpression (BLOCK (ALT (BLOCK (ALT {} ('(' (ELEMENT_OPTIONS (= tokenIndex 862))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 864))) (')' (ELEMENT_OPTIONS (= tokenIndex 866)))) (ALT (operator (ELEMENT_OPTIONS (= tokenIndex 870))))) (* (BLOCK (ALT ({precpred(_ctx, 3)}? (ELEMENT_OPTIONS (= p 3))) (operation (ELEMENT_OPTIONS (= tokenIndex 856))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 858) (= p 4)))))))))
2025-03-18 03:10:49:107 left-recursion LogManager.java:25 condition
    :   ( {} '('<tokenIndex=1159> condition<tokenIndex=1161> ')'<tokenIndex=1163> 
        | '!'<tokenIndex=1167> '('<tokenIndex=1169> condition<tokenIndex=1171> ')'<tokenIndex=1173> 
        | partCondition<tokenIndex=1185> 
        )
        (
          {precpred(_ctx, 2)}?<p=2> logicalOperator<tokenIndex=1179> condition<tokenIndex=1181,p=3>
        )*
    ;
2025-03-18 03:10:49:111 grammar LogManager.java:25 added: (RULE condition (BLOCK (ALT (BLOCK (ALT {} ('(' (ELEMENT_OPTIONS (= tokenIndex 1159))) (condition (ELEMENT_OPTIONS (= tokenIndex 1161))) (')' (ELEMENT_OPTIONS (= tokenIndex 1163)))) (ALT ('!' (ELEMENT_OPTIONS (= tokenIndex 1167))) ('(' (ELEMENT_OPTIONS (= tokenIndex 1169))) (condition (ELEMENT_OPTIONS (= tokenIndex 1171))) (')' (ELEMENT_OPTIONS (= tokenIndex 1173)))) (ALT (partCondition (ELEMENT_OPTIONS (= tokenIndex 1185))))) (* (BLOCK (ALT ({precpred(_ctx, 2)}? (ELEMENT_OPTIONS (= p 2))) (logicalOperator (ELEMENT_OPTIONS (= tokenIndex 1179))) (condition (ELEMENT_OPTIONS (= tokenIndex 1181) (= p 3)))))))))
2025-03-18 03:10:49:114 semantics LogManager.java:25 tokens={EOF=-1, T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, T__8=9, T__9=10, T__10=11, T__11=12, INPUT=13, OUTPUT=14, TYPE=15, MAIN=16, VAR=17, BEGIN=18, END=19, IF=20, ELSE=21, ELSIF=22, THEN=23, SWITCH=24, CASE=25, BREAK=26, DEFAULT=27, WHILE=28, DO=29, FOR=30, FROM=31, TO=32, STEP=33, AND=34, OR=35, LET=36, DEFINE=37, CONST=38, IDF=39, INT=40, FLOAT=41, STRING=42, AFFECT=43, NOT=44, COMPARAISONOPERATOR=45, LBRACE=46, RBRACE=47, Separators=48, COMMENT=49, WS=50, ERROR_TOKEN=51}
2025-03-18 03:10:49:114 semantics LogManager.java:25 strings={';'=1, ','=2, ':'=3, '='=4, '+'=5, '-'=6, '('=7, ')'=8, '['=9, ']'=10, '*'=11, '/'=12, 'input'=13, 'output'=14, 'MainPrgm'=16, 'Var'=17, 'BeginPg'=18, 'EndPg'=19, 'if'=20, 'else'=21, 'elsif'=22, 'then'=23, 'switch'=24, 'case'=25, 'break'=26, 'default'=27, 'while'=28, 'do'=29, 'for'=30, 'from'=31, 'to'=32, 'step'=33, 'AND'=34, 'OR'=35, 'let'=36, '@Define'=37, 'const'=38, ':='=43, '!'=44, '{'=46, '}'=47}
2025-03-18 03:10:49:130 LL1 LogManager.java:25 
DECISION 0 in rule prog
2025-03-18 03:10:49:130 LL1 LogManager.java:25 look=[49, 16]
2025-03-18 03:10:49:130 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:130 LL1 LogManager.java:25 
DECISION 1 in rule prog
2025-03-18 03:10:49:130 LL1 LogManager.java:25 look=[49, 17]
2025-03-18 03:10:49:130 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:130 LL1 LogManager.java:25 
DECISION 2 in rule prog
2025-03-18 03:10:49:131 LL1 LogManager.java:25 look=[49, 18]
2025-03-18 03:10:49:131 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:131 LL1 LogManager.java:25 
DECISION 3 in rule prog
2025-03-18 03:10:49:131 LL1 LogManager.java:25 look=[49, <EOF>]
2025-03-18 03:10:49:131 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:131 LL1 LogManager.java:25 
DECISION 4 in rule varBlock
2025-03-18 03:10:49:131 LL1 LogManager.java:25 look=[{36..37, 49}, {18, 49}]
2025-03-18 03:10:49:131 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:131 LL1 LogManager.java:25 
DECISION 5 in rule varBlock
2025-03-18 03:10:49:131 LL1 LogManager.java:25 look=[17, 17]
2025-03-18 03:10:49:131 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:131 LL1 LogManager.java:25 
DECISION 6 in rule declaration
2025-03-18 03:10:49:131 LL1 LogManager.java:25 look=[{36..37}, {36..37}, 49]
2025-03-18 03:10:49:131 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:131 LL1 LogManager.java:25 
DECISION 7 in rule listIDF
2025-03-18 03:10:49:131 LL1 LogManager.java:25 look=[2, {3, 8}]
2025-03-18 03:10:49:131 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:131 LL1 LogManager.java:25 
DECISION 8 in rule normalDeclaration
2025-03-18 03:10:49:132 LL1 LogManager.java:25 look=[{36..37}, {36..37}]
2025-03-18 03:10:49:132 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:132 LL1 LogManager.java:25 
DECISION 9 in rule number
2025-03-18 03:10:49:132 LL1 LogManager.java:25 look=[7, 7, 40, 41]
2025-03-18 03:10:49:132 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:132 LL1 LogManager.java:25 
DECISION 10 in rule arrayDeclaration
2025-03-18 03:10:49:132 LL1 LogManager.java:25 look=[{36..37}, {36..37}]
2025-03-18 03:10:49:132 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:132 LL1 LogManager.java:25 
DECISION 11 in rule declarationKeyword
2025-03-18 03:10:49:132 LL1 LogManager.java:25 look=[37, 36]
2025-03-18 03:10:49:132 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:132 LL1 LogManager.java:25 
DECISION 12 in rule listNumber
2025-03-18 03:10:49:132 LL1 LogManager.java:25 look=[2, 47]
2025-03-18 03:10:49:132 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:132 LL1 LogManager.java:25 
DECISION 13 in rule mainCode
2025-03-18 03:10:49:132 LL1 LogManager.java:25 look=[49, 46]
2025-03-18 03:10:49:132 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:132 LL1 LogManager.java:25 
DECISION 14 in rule mainCode
2025-03-18 03:10:49:132 LL1 LogManager.java:25 look=[{13..14, 20, 24, 28..30, 39, 49}, 47]
2025-03-18 03:10:49:132 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:132 LL1 LogManager.java:25 
DECISION 15 in rule mainCode
2025-03-18 03:10:49:133 LL1 LogManager.java:25 look=[49, 19]
2025-03-18 03:10:49:133 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:133 LL1 LogManager.java:25 
DECISION 16 in rule mainCode
2025-03-18 03:10:49:133 LL1 LogManager.java:25 look=[49, 46]
2025-03-18 03:10:49:133 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:133 LL1 LogManager.java:25 
DECISION 17 in rule mainCode
2025-03-18 03:10:49:133 LL1 LogManager.java:25 look=[49, 19]
2025-03-18 03:10:49:133 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:133 LL1 LogManager.java:25 
DECISION 18 in rule mainCode
2025-03-18 03:10:49:133 LL1 LogManager.java:25 look=[18, 18]
2025-03-18 03:10:49:133 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:133 LL1 LogManager.java:25 
DECISION 19 in rule inst
2025-03-18 03:10:49:133 LL1 LogManager.java:25 look=[14, 13, 39, 49, 30, 29, 28, 20, 24]
2025-03-18 03:10:49:133 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:133 LL1 LogManager.java:25 
DECISION 20 in rule content
2025-03-18 03:10:49:133 LL1 LogManager.java:25 look=[{39, 42}, {39, 42}]
2025-03-18 03:10:49:133 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:133 LL1 LogManager.java:25 
DECISION 21 in rule content
2025-03-18 03:10:49:133 LL1 LogManager.java:25 look=[{39, 42}, {39, 42}]
2025-03-18 03:10:49:133 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:133 LL1 LogManager.java:25 
DECISION 22 in rule arithmeticExpression
2025-03-18 03:10:49:133 LL1 LogManager.java:25 look=[7, {7, 39..41}]
2025-03-18 03:10:49:133 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:133 LL1 LogManager.java:25 
DECISION 23 in rule arithmeticExpression
2025-03-18 03:10:49:133 LL1 LogManager.java:25 look=[null, null]
2025-03-18 03:10:49:133 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:133 LL1 LogManager.java:25 
DECISION 24 in rule operator
2025-03-18 03:10:49:133 LL1 LogManager.java:25 look=[{7, 40..41}, 39]
2025-03-18 03:10:49:134 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:134 LL1 LogManager.java:25 
DECISION 25 in rule var
2025-03-18 03:10:49:134 LL1 LogManager.java:25 look=[39, 39]
2025-03-18 03:10:49:134 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:134 LL1 LogManager.java:25 
DECISION 26 in rule forInst
2025-03-18 03:10:49:134 LL1 LogManager.java:25 look=[{5..6, 11..12}, 31]
2025-03-18 03:10:49:134 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:134 LL1 LogManager.java:25 
DECISION 27 in rule forInst
2025-03-18 03:10:49:134 LL1 LogManager.java:25 look=[{13..14, 20, 24, 28..30, 39, 49}, 47]
2025-03-18 03:10:49:134 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:134 LL1 LogManager.java:25 
DECISION 28 in rule doWhileInst
2025-03-18 03:10:49:134 LL1 LogManager.java:25 look=[{13..14, 20, 24, 28..30, 39, 49}, 47]
2025-03-18 03:10:49:134 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:134 LL1 LogManager.java:25 
DECISION 29 in rule whileInst
2025-03-18 03:10:49:134 LL1 LogManager.java:25 look=[{13..14, 20, 24, 28..30, 39, 49}, 47]
2025-03-18 03:10:49:134 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:134 LL1 LogManager.java:25 
DECISION 30 in rule ifInst
2025-03-18 03:10:49:135 LL1 LogManager.java:25 look=[{13..14, 20, 24, 28..30, 39, 49}, 47]
2025-03-18 03:10:49:135 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:135 LL1 LogManager.java:25 
DECISION 31 in rule ifInst
2025-03-18 03:10:49:136 LL1 LogManager.java:25 look=[{22, 49}, {13..14, 20..21, 24, 26, 28..30, 39, 47, 49}]
2025-03-18 03:10:49:136 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:136 LL1 LogManager.java:25 
DECISION 32 in rule ifInst
2025-03-18 03:10:49:137 LL1 LogManager.java:25 look=[{21, 49}, {13..14, 20, 24, 26, 28..30, 39, 47, 49}]
2025-03-18 03:10:49:137 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:137 LL1 LogManager.java:25 
DECISION 33 in rule elseIfInst
2025-03-18 03:10:49:137 LL1 LogManager.java:25 look=[49, 22]
2025-03-18 03:10:49:137 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:137 LL1 LogManager.java:25 
DECISION 34 in rule elseIfInst
2025-03-18 03:10:49:137 LL1 LogManager.java:25 look=[{13..14, 20, 24, 28..30, 39, 49}, 47]
2025-03-18 03:10:49:137 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:137 LL1 LogManager.java:25 
DECISION 35 in rule elseIfInst
2025-03-18 03:10:49:137 LL1 LogManager.java:25 look=[49, 22]
2025-03-18 03:10:49:137 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:137 LL1 LogManager.java:25 
DECISION 36 in rule elseIfInst
2025-03-18 03:10:49:137 LL1 LogManager.java:25 look=[{13..14, 20, 24, 28..30, 39, 49}, 47]
2025-03-18 03:10:49:137 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:137 LL1 LogManager.java:25 
DECISION 37 in rule elseIfInst
2025-03-18 03:10:49:137 LL1 LogManager.java:25 look=[{22, 49}, {22, 49}]
2025-03-18 03:10:49:137 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:137 LL1 LogManager.java:25 
DECISION 38 in rule elseInst
2025-03-18 03:10:49:137 LL1 LogManager.java:25 look=[49, 21]
2025-03-18 03:10:49:137 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:137 LL1 LogManager.java:25 
DECISION 39 in rule elseInst
2025-03-18 03:10:49:137 LL1 LogManager.java:25 look=[{13..14, 20, 24, 28..30, 39, 49}, 47]
2025-03-18 03:10:49:137 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:137 LL1 LogManager.java:25 
DECISION 40 in rule caseInst
2025-03-18 03:10:49:137 LL1 LogManager.java:25 look=[{13..14, 20, 24, 28..30, 39, 49}, 26]
2025-03-18 03:10:49:137 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:137 LL1 LogManager.java:25 
DECISION 41 in rule caseInst
2025-03-18 03:10:49:138 LL1 LogManager.java:25 look=[{13..14, 20, 24, 28..30, 39, 49}, 26]
2025-03-18 03:10:49:138 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:138 LL1 LogManager.java:25 
DECISION 42 in rule caseInst
2025-03-18 03:10:49:138 LL1 LogManager.java:25 look=[25, 25]
2025-03-18 03:10:49:138 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:138 LL1 LogManager.java:25 
DECISION 43 in rule defaultInst
2025-03-18 03:10:49:138 LL1 LogManager.java:25 look=[{13..14, 20, 24, 28..30, 39, 49}, 26]
2025-03-18 03:10:49:138 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:138 LL1 LogManager.java:25 
DECISION 44 in rule condition
2025-03-18 03:10:49:138 LL1 LogManager.java:25 look=[7, 44, 39]
2025-03-18 03:10:49:138 LL1 LogManager.java:25 LL(1)? true
2025-03-18 03:10:49:138 LL1 LogManager.java:25 
DECISION 45 in rule condition
2025-03-18 03:10:49:138 LL1 LogManager.java:25 look=[null, null]
2025-03-18 03:10:49:138 LL1 LogManager.java:25 LL(1)? false
2025-03-18 03:10:49:139 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-18 03:10:49:160 action-translator LogManager.java:25 translate IDF_HashTable.table.printTable();
2025-03-18 03:10:49:164 action-translator LogManager.java:25 translate 
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }

2025-03-18 03:10:49:165 action-translator LogManager.java:25 qattr [@-1,25:31='listIDF',<0>,105:23].[@-1,33:36='text',<0>,105:31]
2025-03-18 03:10:49:167 action-translator LogManager.java:25 qattr [@-1,111:114='TYPE',<0>,106:57].[@-1,116:119='text',<0>,106:62]
2025-03-18 03:10:49:167 action-translator LogManager.java:25 qattr [@-1,122:132='affectValue',<0>,106:68].[@-1,134:137='text',<0>,106:80]
2025-03-18 03:10:49:167 action-translator LogManager.java:25 qattr [@-1,140:150='affectValue',<0>,106:86].[@-1,152:155='type',<0>,106:98]
2025-03-18 03:10:49:168 action-translator LogManager.java:25 translate 
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }

2025-03-18 03:10:49:168 action-translator LogManager.java:25 qattr [@-1,25:31='listIDF',<0>,111:23].[@-1,33:36='text',<0>,111:31]
2025-03-18 03:10:49:169 action-translator LogManager.java:25 qattr [@-1,106:109='TYPE',<0>,112:52].[@-1,111:114='text',<0>,112:57]
2025-03-18 03:10:49:170 action-translator LogManager.java:25 translate $type = $number.type;
2025-03-18 03:10:49:170 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,116:46] [@-1,7:19=' $number.type',<0>,116:52]
2025-03-18 03:10:49:170 action-translator LogManager.java:25 translate  $number.type
2025-03-18 03:10:49:170 action-translator LogManager.java:25 qattr [@-1,2:7='number',<0>,116:47].[@-1,9:12='type',<0>,116:54]
2025-03-18 03:10:49:171 action-translator LogManager.java:25 translate  $type = "INT"; 
2025-03-18 03:10:49:171 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,117:49] [@-1,8:13=' "INT"',<0>,117:55]
2025-03-18 03:10:49:171 action-translator LogManager.java:25 translate  "INT"
2025-03-18 03:10:49:172 action-translator LogManager.java:25 translate  $type = "FLOAT"; 
2025-03-18 03:10:49:172 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,117:89] [@-1,8:15=' "FLOAT"',<0>,117:95]
2025-03-18 03:10:49:172 action-translator LogManager.java:25 translate  "FLOAT"
2025-03-18 03:10:49:172 action-translator LogManager.java:25 translate  $type = "INT"; 
2025-03-18 03:10:49:172 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,117:116] [@-1,8:13=' "INT"',<0>,117:122]
2025-03-18 03:10:49:172 action-translator LogManager.java:25 translate  "INT"
2025-03-18 03:10:49:172 action-translator LogManager.java:25 translate  $type = "FLOAT"; 
2025-03-18 03:10:49:172 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,117:144] [@-1,8:15=' "FLOAT"',<0>,117:150]
2025-03-18 03:10:49:173 action-translator LogManager.java:25 translate  "FLOAT"
2025-03-18 03:10:49:181 action-translator LogManager.java:25 translate 
2025-03-18 03:10:49:182 action-translator LogManager.java:25 translate precpred(_ctx, 3)
2025-03-18 03:10:49:184 action-translator LogManager.java:25 translate precpred(_ctx, 3)
2025-03-18 03:10:49:195 action-translator LogManager.java:25 translate 
2025-03-18 03:10:49:195 action-translator LogManager.java:25 translate precpred(_ctx, 2)
2025-03-18 03:10:49:196 action-translator LogManager.java:25 translate precpred(_ctx, 2)
2025-03-18 03:10:49:299 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-18 03:10:49:299 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-18 03:10:49:305 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-18 03:10:49:305 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

