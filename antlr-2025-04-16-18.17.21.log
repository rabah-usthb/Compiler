2025-04-16 18:17:20:493 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Expr (@ header {
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;
}) (@ parser members {
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();
}) (@ lexer members {
     printLexerConsole.console.nb = 0;
     printLexerConsole.output.setLength(0);

}) (RULES (RULE SIGN (RULEMODIFIERS fragment) (BLOCK (ALT '-') (ALT '+'))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INTEGER (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT)))))) (RULE FLOATED (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.'))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE BOOLEANVALUE (BLOCK (ALT (BLOCK (ALT 'True') (ALT 'False')) { printLexerConsole.console.printToken(getText(),"Keyword",getLine(),getCharPositionInLine());  Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}))) (RULE INPUT (BLOCK (ALT 'input' { printLexerConsole.console.printToken(getText(),"Read Function",getLine(),getCharPositionInLine());  Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Read Function");}))) (RULE OUTPUT (BLOCK (ALT 'output' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Print Function");}))) (RULE TYPE (BLOCK (ALT 'Int' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Float' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Bool' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'String' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Char' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainProgram Header");}))) (RULE VAR (BLOCK (ALT 'Var' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Block Delimiter");}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE END (BLOCK (ALT 'EndPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE IF (BLOCK (ALT 'if' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"If Keyword");}))) (RULE ELSE (BLOCK (ALT 'else' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else Keyword");}))) (RULE ELSIF (BLOCK (ALT 'elsif' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else If Keyword");}))) (RULE THEN (BLOCK (ALT 'then' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Then Keyword");}))) (RULE SWITCH (BLOCK (ALT 'switch' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Switch Keyword");}))) (RULE CASE (BLOCK (ALT 'case' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE BREAK (BLOCK (ALT 'break' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE DEFAULT (BLOCK (ALT 'default' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Default Case Delimiter");}))) (RULE WHILE (BLOCK (ALT 'while' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE DO (BLOCK (ALT 'do' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FOR (BLOCK (ALT 'for' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FROM (BLOCK (ALT 'from' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"From Keyword");}))) (RULE TO (BLOCK (ALT 'to' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"To Keyword");}))) (RULE STEP (BLOCK (ALT 'step' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Step Keyword");}))) (RULE AND (BLOCK (ALT 'AND' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical AND");}))) (RULE OR (BLOCK (ALT 'OR' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical OR");}))) (RULE LET (BLOCK (ALT 'let' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Declarator");}))) (RULE DEFINE (BLOCK (ALT '@define' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE CONST (BLOCK (ALT 'Const' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (? (BLOCK (ALT (* (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {IDF_HashTable.table.insertFirst(getText(),getLine(),getCharPositionInLine());}))) (RULE INT (BLOCK (ALT '(' SIGN INTEGER ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}) (ALT INTEGER {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT '(' SIGN FLOATED ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}) (ALT FLOATED {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {Constant_Hashtable.ConstantTable.insertTable(getText(),"string",getLine(),getCharPositionInLine());}))) (RULE CHAR (BLOCK (ALT '\'' (* (BLOCK (ALT (~ (SET ['\n]))))) '\'' {Constant_Hashtable.ConstantTable.insertTable(getText(),"char",getLine(),getCharPositionInLine());}))) (RULE CONCAT (BLOCK (ALT '.' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE NOT (BLOCK (ALT '!' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE GREATER (BLOCK (ALT '>' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LESSER (BLOCK (ALT '<' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE GEQ (BLOCK (ALT '>=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LEQ (BLOCK (ALT '<=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE EQ (BLOCK (ALT '==' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE NEQ (BLOCK (ALT '!=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LBRACE (BLOCK (ALT '{' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE RBRACE (BLOCK (ALT '}' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE PLUS (BLOCK (ALT '+' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE SUB (BLOCK (ALT '-' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE MUL (BLOCK (ALT '*' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE DIV (BLOCK (ALT '/' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COM (BLOCK (ALT ',' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE SEMI (BLOCK (ALT ';' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LBRACKET (BLOCK (ALT '[' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE RBRACKET (BLOCK (ALT ']' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LPAR (BLOCK (ALT '(' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE RPAR (BLOCK (ALT ')' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE ASSIGN (BLOCK (ALT '=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE TWOPOINT (BLOCK (ALT ':' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT)) {printLexerConsole.console.printToken(getText(),"Comment",getLine(),getCharPositionInLine());}) (LEXER_ACTION_CALL channel HIDDEN)))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT .))) (RULE prog (BLOCK (ALT MAIN IDF ';' varBlock mainCode EOF))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' value ';' {
this.types.add($value.type);
    for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$value.text,types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
        for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
       }))) (RULE number (returns ErrorToken type) (BLOCK (ALT INT { $type = new ErrorToken($INT.text,"INT",$INT.line,$INT.pos); }) (ALT FLOAT { $type = new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos); }))) (RULE arrayDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,this.types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}))) (RULE affectArray (BLOCK (ALT '=' '{' (* (BLOCK (ALT listValue))) '}'))) (RULE declarationKeyword (returns String mul) (BLOCK (ALT DEFINE CONST {$mul = "Constant";}) (ALT LET {$mul = "Variable";}))) (RULE listValue (BLOCK (ALT (= v1 value) {ErrorToken type_1 = $v1.type; type_1.exp = $v1.text; this.types.add(type_1); } (* (BLOCK (ALT ',' (= v value) { ErrorToken type_2 = $v.type; type_2.exp = $v.text; this.types.add(type_2);})))))) (RULE value (returns ErrorToken type) (@ init {this.boolList.clear(); this.compareList.clear(); this.concatList.clear(); this.arithmeticList.clear();}) (BLOCK (ALT var {$type= $var.type;}) (ALT number {$type = $number.type;}) (ALT BOOLEANVALUE {$type = new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos);}) (ALT CHAR {$type = new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos); }) (ALT STRING {$type = new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos);}) (ALT condition {$type = IDF_HashTable.table.conditionType(this.boolList,this.compareList);}) (ALT arithmeticExpression {$type=IDF_HashTable.table.getType(this.arithmeticList,0);}) (ALT concatInst {$type=IDF_HashTable.table.getType(this.concatList,1);}))) (RULE mainCode (BLOCK (ALT BEGIN '{' (+ (BLOCK (ALT inst))) '}' END ';') (ALT BEGIN '{' '}' END ';'))) (RULE inst (@ init { this.types.clear();}) (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst) (ALT forInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (BLOCK (ALT STRING) (ALT IDF)) ','))) (BLOCK (ALT STRING) (ALT IDF))) (ALT (BLOCK (ALT STRING) (ALT IDF))))) (RULE affectInst (@ init { this.types.clear(); }) (BLOCK (ALT (= var_1 var) AFFECT (= var_2 var) ';' { 
  IDF_HashTable.table.affectMONO($var_2.text,$var_1.type, $var_2.type,$var_1.start.getLine(),$var_1.start.getCharPositionInLine());
}) (ALT var AFFECT value ';' {
 	IDF_HashTable.table.affectEXP($value.text,$var.type, $value.type,$var.start.getLine(),$var.start.getCharPositionInLine());
	
}) (ALT IDF AFFECT '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  IDF_HashTable.table.affectArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos),this.types, $IDF.line,$IDF.pos);
}) (ALT IDF AFFECT '{' '}' ';' {
  IDF_HashTable.table.affectEmptyArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos), $IDF.line,$IDF.pos);
}))) (RULE concatInst (BLOCK (ALT (BLOCK (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));}) (ALT var {this.concatList.add($var.type);})) (+ (BLOCK (ALT '.' (BLOCK (ALT (BLOCK (ALT var {this.concatList.add($var.type);}) (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));})))))))))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression (= op (BLOCK (ALT MUL) (ALT DIV))) (= ari arithmeticExpression) {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}) (ALT arithmeticExpression (BLOCK (ALT PLUS) (ALT SUB)) arithmeticExpression) (ALT operator {this.arithmeticList.add($operator.type);}) (ALT '(' arithmeticExpression ')'))) (RULE operator (returns ErrorToken type) (BLOCK (ALT number {$type = $number.type;}) (ALT var {$type = $var.type;}))) (RULE var (returns ErrorToken type) (BLOCK (ALT IDF {$type = IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos); }) (ALT IDF '[' INT ']' {$type = IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos);}))) (RULE forInst (BLOCK (ALT FOR IDF FROM INT TO INT STEP INT '{' (* (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (* (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (* (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF LPAR condition RPAR THEN '{' (* (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}' elseIfInst) (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT ELSE '{' (* (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseValue (BLOCK (ALT number) (ALT BOOLEANVALUE) (ALT CHAR) (ALT STRING))) (RULE caseInst (BLOCK (ALT CASE caseValue ':' (* (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE caseValue ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (* (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT LPAR condition RPAR) (ALT NOT condition) (ALT condition AND condition) (ALT condition OR condition) (ALT partCondition) (ALT var {this.boolList.add($var.type);}) (ALT BOOLEANVALUE))) (RULE partCondition (BLOCK (ALT arithmeticExpression comparaisonOperator arithmeticExpression {this.compareList.addAll(this.arithmeticList); }))) (RULE comparaisonOperator (BLOCK (ALT EQ) (ALT NEQ) (ALT GREATER) (ALT LESSER) (ALT GEQ) (ALT LEQ)))))
2025-04-16 18:17:20:529 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Expr (@ header {
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;
}) (@ parser members {
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();
}) (@ lexer members {
     printLexerConsole.console.nb = 0;
     printLexerConsole.output.setLength(0);

}) (RULES (RULE SIGN (RULEMODIFIERS fragment) (BLOCK (ALT (SET '-' '+')))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INTEGER (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT)))))) (RULE FLOATED (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.'))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE BOOLEANVALUE (BLOCK (ALT (BLOCK (ALT 'True') (ALT 'False')) { printLexerConsole.console.printToken(getText(),"Keyword",getLine(),getCharPositionInLine());  Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}))) (RULE INPUT (BLOCK (ALT 'input' { printLexerConsole.console.printToken(getText(),"Read Function",getLine(),getCharPositionInLine());  Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Read Function");}))) (RULE OUTPUT (BLOCK (ALT 'output' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Print Function");}))) (RULE TYPE (BLOCK (ALT 'Int' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Float' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Bool' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'String' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Char' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainProgram Header");}))) (RULE VAR (BLOCK (ALT 'Var' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Block Delimiter");}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE END (BLOCK (ALT 'EndPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE IF (BLOCK (ALT 'if' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"If Keyword");}))) (RULE ELSE (BLOCK (ALT 'else' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else Keyword");}))) (RULE ELSIF (BLOCK (ALT 'elsif' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else If Keyword");}))) (RULE THEN (BLOCK (ALT 'then' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Then Keyword");}))) (RULE SWITCH (BLOCK (ALT 'switch' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Switch Keyword");}))) (RULE CASE (BLOCK (ALT 'case' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE BREAK (BLOCK (ALT 'break' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE DEFAULT (BLOCK (ALT 'default' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Default Case Delimiter");}))) (RULE WHILE (BLOCK (ALT 'while' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE DO (BLOCK (ALT 'do' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FOR (BLOCK (ALT 'for' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FROM (BLOCK (ALT 'from' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"From Keyword");}))) (RULE TO (BLOCK (ALT 'to' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"To Keyword");}))) (RULE STEP (BLOCK (ALT 'step' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Step Keyword");}))) (RULE AND (BLOCK (ALT 'AND' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical AND");}))) (RULE OR (BLOCK (ALT 'OR' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical OR");}))) (RULE LET (BLOCK (ALT 'let' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Declarator");}))) (RULE DEFINE (BLOCK (ALT '@define' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE CONST (BLOCK (ALT 'Const' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (? (BLOCK (ALT (* (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {IDF_HashTable.table.insertFirst(getText(),getLine(),getCharPositionInLine());}))) (RULE INT (BLOCK (ALT '(' SIGN INTEGER ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}) (ALT INTEGER {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT '(' SIGN FLOATED ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}) (ALT FLOATED {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {Constant_Hashtable.ConstantTable.insertTable(getText(),"string",getLine(),getCharPositionInLine());}))) (RULE CHAR (BLOCK (ALT '\'' (* (BLOCK (ALT (~ (SET ['\n]))))) '\'' {Constant_Hashtable.ConstantTable.insertTable(getText(),"char",getLine(),getCharPositionInLine());}))) (RULE CONCAT (BLOCK (ALT '.' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE NOT (BLOCK (ALT '!' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE GREATER (BLOCK (ALT '>' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LESSER (BLOCK (ALT '<' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE GEQ (BLOCK (ALT '>=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LEQ (BLOCK (ALT '<=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE EQ (BLOCK (ALT '==' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE NEQ (BLOCK (ALT '!=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LBRACE (BLOCK (ALT '{' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE RBRACE (BLOCK (ALT '}' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE PLUS (BLOCK (ALT '+' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE SUB (BLOCK (ALT '-' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE MUL (BLOCK (ALT '*' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE DIV (BLOCK (ALT '/' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COM (BLOCK (ALT ',' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE SEMI (BLOCK (ALT ';' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LBRACKET (BLOCK (ALT '[' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE RBRACKET (BLOCK (ALT ']' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LPAR (BLOCK (ALT '(' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE RPAR (BLOCK (ALT ')' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE ASSIGN (BLOCK (ALT '=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE TWOPOINT (BLOCK (ALT ':' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT)) {printLexerConsole.console.printToken(getText(),"Comment",getLine(),getCharPositionInLine());}) (LEXER_ACTION_CALL channel HIDDEN)))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT .))) (RULE prog (BLOCK (ALT MAIN IDF ';' varBlock mainCode EOF))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' value ';' {
this.types.add($value.type);
    for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$value.text,types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
        for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
       }))) (RULE number (returns ErrorToken type) (BLOCK (ALT INT { $type = new ErrorToken($INT.text,"INT",$INT.line,$INT.pos); }) (ALT FLOAT { $type = new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos); }))) (RULE arrayDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,this.types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}))) (RULE affectArray (BLOCK (ALT '=' '{' (* (BLOCK (ALT listValue))) '}'))) (RULE declarationKeyword (returns String mul) (BLOCK (ALT DEFINE CONST {$mul = "Constant";}) (ALT LET {$mul = "Variable";}))) (RULE listValue (BLOCK (ALT (= v1 value) {ErrorToken type_1 = $v1.type; type_1.exp = $v1.text; this.types.add(type_1); } (* (BLOCK (ALT ',' (= v value) { ErrorToken type_2 = $v.type; type_2.exp = $v.text; this.types.add(type_2);})))))) (RULE value (returns ErrorToken type) (@ init {this.boolList.clear(); this.compareList.clear(); this.concatList.clear(); this.arithmeticList.clear();}) (BLOCK (ALT var {$type= $var.type;}) (ALT number {$type = $number.type;}) (ALT BOOLEANVALUE {$type = new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos);}) (ALT CHAR {$type = new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos); }) (ALT STRING {$type = new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos);}) (ALT condition {$type = IDF_HashTable.table.conditionType(this.boolList,this.compareList);}) (ALT arithmeticExpression {$type=IDF_HashTable.table.getType(this.arithmeticList,0);}) (ALT concatInst {$type=IDF_HashTable.table.getType(this.concatList,1);}))) (RULE mainCode (BLOCK (ALT BEGIN '{' (+ (BLOCK (ALT inst))) '}' END ';') (ALT BEGIN '{' '}' END ';'))) (RULE inst (@ init { this.types.clear();}) (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst) (ALT forInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (@ init { this.types.clear(); }) (BLOCK (ALT (= var_1 var) AFFECT (= var_2 var) ';' { 
  IDF_HashTable.table.affectMONO($var_2.text,$var_1.type, $var_2.type,$var_1.start.getLine(),$var_1.start.getCharPositionInLine());
}) (ALT var AFFECT value ';' {
 	IDF_HashTable.table.affectEXP($value.text,$var.type, $value.type,$var.start.getLine(),$var.start.getCharPositionInLine());
	
}) (ALT IDF AFFECT '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  IDF_HashTable.table.affectArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos),this.types, $IDF.line,$IDF.pos);
}) (ALT IDF AFFECT '{' '}' ';' {
  IDF_HashTable.table.affectEmptyArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos), $IDF.line,$IDF.pos);
}))) (RULE concatInst (BLOCK (ALT (BLOCK (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));}) (ALT var {this.concatList.add($var.type);})) (+ (BLOCK (ALT '.' (BLOCK (ALT (BLOCK (ALT var {this.concatList.add($var.type);}) (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));})))))))))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression (= op (SET MUL DIV)) (= ari arithmeticExpression) {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}) (ALT arithmeticExpression (SET PLUS SUB) arithmeticExpression) (ALT operator {this.arithmeticList.add($operator.type);}) (ALT '(' arithmeticExpression ')'))) (RULE operator (returns ErrorToken type) (BLOCK (ALT number {$type = $number.type;}) (ALT var {$type = $var.type;}))) (RULE var (returns ErrorToken type) (BLOCK (ALT IDF {$type = IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos); }) (ALT IDF '[' INT ']' {$type = IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos);}))) (RULE forInst (BLOCK (ALT FOR IDF FROM INT TO INT STEP INT '{' (* (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (* (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (* (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF LPAR condition RPAR THEN '{' (* (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}' elseIfInst) (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT ELSE '{' (* (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseValue (BLOCK (ALT number) (ALT BOOLEANVALUE) (ALT CHAR) (ALT STRING))) (RULE caseInst (BLOCK (ALT CASE caseValue ':' (* (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE caseValue ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (* (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT LPAR condition RPAR) (ALT NOT condition) (ALT condition AND condition) (ALT condition OR condition) (ALT partCondition) (ALT var {this.boolList.add($var.type);}) (ALT BOOLEANVALUE))) (RULE partCondition (BLOCK (ALT arithmeticExpression comparaisonOperator arithmeticExpression {this.compareList.addAll(this.arithmeticList); }))) (RULE comparaisonOperator (BLOCK (ALT (SET EQ NEQ GREATER LESSER GEQ LEQ))))))
2025-04-16 18:17:20:598 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Expr (@ header {
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;
}) (@ parser members {
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();
}) (RULES (RULE prog (BLOCK (ALT MAIN IDF ';' varBlock mainCode EOF))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' value ';' {
this.types.add($value.type);
    for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$value.text,types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
        for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
       }))) (RULE number (returns ErrorToken type) (BLOCK (ALT INT { $type = new ErrorToken($INT.text,"INT",$INT.line,$INT.pos); }) (ALT FLOAT { $type = new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos); }))) (RULE arrayDeclaration (@ init {types.clear();}) (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' '=' '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,this.types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}) (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';' {
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }
}))) (RULE affectArray (BLOCK (ALT '=' '{' (* (BLOCK (ALT listValue))) '}'))) (RULE declarationKeyword (returns String mul) (BLOCK (ALT DEFINE CONST {$mul = "Constant";}) (ALT LET {$mul = "Variable";}))) (RULE listValue (BLOCK (ALT (= v1 value) {ErrorToken type_1 = $v1.type; type_1.exp = $v1.text; this.types.add(type_1); } (* (BLOCK (ALT ',' (= v value) { ErrorToken type_2 = $v.type; type_2.exp = $v.text; this.types.add(type_2);})))))) (RULE value (returns ErrorToken type) (@ init {this.boolList.clear(); this.compareList.clear(); this.concatList.clear(); this.arithmeticList.clear();}) (BLOCK (ALT var {$type= $var.type;}) (ALT number {$type = $number.type;}) (ALT BOOLEANVALUE {$type = new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos);}) (ALT CHAR {$type = new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos); }) (ALT STRING {$type = new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos);}) (ALT condition {$type = IDF_HashTable.table.conditionType(this.boolList,this.compareList);}) (ALT arithmeticExpression {$type=IDF_HashTable.table.getType(this.arithmeticList,0);}) (ALT concatInst {$type=IDF_HashTable.table.getType(this.concatList,1);}))) (RULE mainCode (BLOCK (ALT BEGIN '{' (+ (BLOCK (ALT inst))) '}' END ';') (ALT BEGIN '{' '}' END ';'))) (RULE inst (@ init { this.types.clear();}) (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst) (ALT forInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (@ init { this.types.clear(); }) (BLOCK (ALT (= var_1 var) AFFECT (= var_2 var) ';' { 
  IDF_HashTable.table.affectMONO($var_2.text,$var_1.type, $var_2.type,$var_1.start.getLine(),$var_1.start.getCharPositionInLine());
}) (ALT var AFFECT value ';' {
 	IDF_HashTable.table.affectEXP($value.text,$var.type, $value.type,$var.start.getLine(),$var.start.getCharPositionInLine());
	
}) (ALT IDF AFFECT '{' (+ (BLOCK (ALT listValue))) '}' ';' {
  IDF_HashTable.table.affectArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos),this.types, $IDF.line,$IDF.pos);
}) (ALT IDF AFFECT '{' '}' ';' {
  IDF_HashTable.table.affectEmptyArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos), $IDF.line,$IDF.pos);
}))) (RULE concatInst (BLOCK (ALT (BLOCK (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));}) (ALT var {this.concatList.add($var.type);})) (+ (BLOCK (ALT '.' (BLOCK (ALT (BLOCK (ALT var {this.concatList.add($var.type);}) (ALT STRING {this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));}) (ALT CHAR {this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));})))))))))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression (= op (SET MUL DIV)) (= ari arithmeticExpression) {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}) (ALT arithmeticExpression (SET PLUS SUB) arithmeticExpression) (ALT operator {this.arithmeticList.add($operator.type);}) (ALT '(' arithmeticExpression ')'))) (RULE operator (returns ErrorToken type) (BLOCK (ALT number {$type = $number.type;}) (ALT var {$type = $var.type;}))) (RULE var (returns ErrorToken type) (BLOCK (ALT IDF {$type = IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos); }) (ALT IDF '[' INT ']' {$type = IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos);}))) (RULE forInst (BLOCK (ALT FOR IDF FROM INT TO INT STEP INT '{' (* (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (* (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (* (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF LPAR condition RPAR THEN '{' (* (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}' elseIfInst) (ALT ELSIF '(' condition ')' THEN '{' (* (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT ELSE '{' (* (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseValue (BLOCK (ALT number) (ALT BOOLEANVALUE) (ALT CHAR) (ALT STRING))) (RULE caseInst (BLOCK (ALT CASE caseValue ':' (* (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE caseValue ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (* (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT LPAR condition RPAR) (ALT NOT condition) (ALT condition AND condition) (ALT condition OR condition) (ALT partCondition) (ALT var {this.boolList.add($var.type);}) (ALT BOOLEANVALUE))) (RULE partCondition (BLOCK (ALT arithmeticExpression comparaisonOperator arithmeticExpression {this.compareList.addAll(this.arithmeticList); }))) (RULE comparaisonOperator (BLOCK (ALT (SET EQ NEQ GREATER LESSER GEQ LEQ))))))
2025-04-16 18:17:20:598 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR ExprLexer (@ header {
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;
}) (@ parser members {
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();
}) (@ lexer members {
     printLexerConsole.console.nb = 0;
     printLexerConsole.output.setLength(0);

}) (RULES (RULE SIGN (RULEMODIFIERS fragment) (BLOCK (ALT (SET '-' '+')))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INTEGER (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT)))))) (RULE FLOATED (RULEMODIFIERS fragment) (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.'))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE BOOLEANVALUE (BLOCK (ALT (BLOCK (ALT 'True') (ALT 'False')) { printLexerConsole.console.printToken(getText(),"Keyword",getLine(),getCharPositionInLine());  Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");}))) (RULE INPUT (BLOCK (ALT 'input' { printLexerConsole.console.printToken(getText(),"Read Function",getLine(),getCharPositionInLine());  Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Read Function");}))) (RULE OUTPUT (BLOCK (ALT 'output' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Print Function");}))) (RULE TYPE (BLOCK (ALT 'Int' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Float' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Bool' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'String' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}) (ALT 'Char' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainProgram Header");}))) (RULE VAR (BLOCK (ALT 'Var' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Block Delimiter");}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE END (BLOCK (ALT 'EndPg' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");}))) (RULE IF (BLOCK (ALT 'if' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"If Keyword");}))) (RULE ELSE (BLOCK (ALT 'else' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else Keyword");}))) (RULE ELSIF (BLOCK (ALT 'elsif' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else If Keyword");}))) (RULE THEN (BLOCK (ALT 'then' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Then Keyword");}))) (RULE SWITCH (BLOCK (ALT 'switch' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Switch Keyword");}))) (RULE CASE (BLOCK (ALT 'case' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE BREAK (BLOCK (ALT 'break' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");}))) (RULE DEFAULT (BLOCK (ALT 'default' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Default Case Delimiter");}))) (RULE WHILE (BLOCK (ALT 'while' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE DO (BLOCK (ALT 'do' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FOR (BLOCK (ALT 'for' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");}))) (RULE FROM (BLOCK (ALT 'from' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"From Keyword");}))) (RULE TO (BLOCK (ALT 'to' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"To Keyword");}))) (RULE STEP (BLOCK (ALT 'step' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Step Keyword");}))) (RULE AND (BLOCK (ALT 'AND' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical AND");}))) (RULE OR (BLOCK (ALT 'OR' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical OR");}))) (RULE LET (BLOCK (ALT 'let' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Declarator");}))) (RULE DEFINE (BLOCK (ALT '@define' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE CONST (BLOCK (ALT 'Const' {Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (? (BLOCK (ALT (* (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {IDF_HashTable.table.insertFirst(getText(),getLine(),getCharPositionInLine());}))) (RULE INT (BLOCK (ALT '(' SIGN INTEGER ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}) (ALT INTEGER {Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT '(' SIGN FLOATED ')' {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}) (ALT FLOATED {Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {Constant_Hashtable.ConstantTable.insertTable(getText(),"string",getLine(),getCharPositionInLine());}))) (RULE CHAR (BLOCK (ALT '\'' (* (BLOCK (ALT (~ (SET ['\n]))))) '\'' {Constant_Hashtable.ConstantTable.insertTable(getText(),"char",getLine(),getCharPositionInLine());}))) (RULE CONCAT (BLOCK (ALT '.' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE NOT (BLOCK (ALT '!' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE GREATER (BLOCK (ALT '>' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LESSER (BLOCK (ALT '<' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE GEQ (BLOCK (ALT '>=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LEQ (BLOCK (ALT '<=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE EQ (BLOCK (ALT '==' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE NEQ (BLOCK (ALT '!=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LBRACE (BLOCK (ALT '{' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE RBRACE (BLOCK (ALT '}' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE PLUS (BLOCK (ALT '+' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE SUB (BLOCK (ALT '-' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE MUL (BLOCK (ALT '*' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE DIV (BLOCK (ALT '/' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COM (BLOCK (ALT ',' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE SEMI (BLOCK (ALT ';' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LBRACKET (BLOCK (ALT '[' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE RBRACKET (BLOCK (ALT ']' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE LPAR (BLOCK (ALT '(' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE RPAR (BLOCK (ALT ')' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE ASSIGN (BLOCK (ALT '=' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE TWOPOINT (BLOCK (ALT ':' {printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT)) {printLexerConsole.console.printToken(getText(),"Comment",getLine(),getCharPositionInLine());}) (LEXER_ACTION_CALL channel HIDDEN)))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT .)))))
2025-04-16 18:17:20:869 action-translator LogManager.java:25 translate 
     printLexerConsole.console.nb = 0;
     printLexerConsole.output.setLength(0);


2025-04-16 18:17:20:869 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;

2025-04-16 18:17:20:898 action-translator LogManager.java:25 translate  printLexerConsole.console.printToken(getText(),"Keyword",getLine(),getCharPositionInLine());  Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Boolean Value");
2025-04-16 18:17:20:898 action-translator LogManager.java:25 translate  printLexerConsole.console.printToken(getText(),"Read Function",getLine(),getCharPositionInLine());  Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Read Function");
2025-04-16 18:17:20:898 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Print Function");
2025-04-16 18:17:20:898 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-16 18:17:20:898 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-16 18:17:20:898 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-16 18:17:20:898 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-16 18:17:20:898 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Data Type");
2025-04-16 18:17:20:898 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainProgram Header");
2025-04-16 18:17:20:898 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Block Delimiter");
2025-04-16 18:17:20:899 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");
2025-04-16 18:17:20:899 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"MainCode Delimiter");
2025-04-16 18:17:20:899 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"If Keyword");
2025-04-16 18:17:20:899 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else Keyword");
2025-04-16 18:17:20:899 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Else If Keyword");
2025-04-16 18:17:20:899 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Then Keyword");
2025-04-16 18:17:20:899 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Switch Keyword");
2025-04-16 18:17:20:899 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");
2025-04-16 18:17:20:899 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Case Delimiter");
2025-04-16 18:17:20:900 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Default Case Delimiter");
2025-04-16 18:17:20:900 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");
2025-04-16 18:17:20:900 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");
2025-04-16 18:17:20:900 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Loop Keyword");
2025-04-16 18:17:20:900 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"From Keyword");
2025-04-16 18:17:20:900 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"To Keyword");
2025-04-16 18:17:20:900 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Step Keyword");
2025-04-16 18:17:20:900 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical AND");
2025-04-16 18:17:20:900 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Logical OR");
2025-04-16 18:17:20:900 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Variable Declarator");
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate Keywords_Hashtable.KeywordsTable.insertTable(getText(),"Constant Declarator");
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate IDF_HashTable.table.insertFirst(getText(),getLine(),getCharPositionInLine());
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"int",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"float",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"string",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate Constant_Hashtable.ConstantTable.insertTable(getText(),"char",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:901 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:902 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:903 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:903 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-04-16 18:17:20:903 action-translator LogManager.java:25 translate printLexerConsole.console.printToken(getText(),"Comment",getLine(),getCharPositionInLine());
2025-04-16 18:17:21:014 left-recursion LogManager.java:25 arithmeticExpression
    :   ( {} operator<tokenIndex=1243> {this.arithmeticList.add($operator.type);} 
        | '('<tokenIndex=1248> arithmeticExpression<tokenIndex=1250> ')'<tokenIndex=1252> 
        )
        (
          {precpred(_ctx, 4)}?<p=4> op=(MUL<tokenIndex=1215> | DIV<tokenIndex=1219>) ari=arithmeticExpression<tokenIndex=1224,p=5>  {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}
                  | {precpred(_ctx, 3)}?<p=3> (PLUS<tokenIndex=1233>| SUB<tokenIndex=1236>) arithmeticExpression<tokenIndex=1239,p=4>
        )*
    ;
2025-04-16 18:17:21:022 grammar LogManager.java:25 added: (RULE arithmeticExpression (BLOCK (ALT (BLOCK (ALT {} (operator (ELEMENT_OPTIONS (= tokenIndex 1243))) {this.arithmeticList.add($operator.type);}) (ALT ('(' (ELEMENT_OPTIONS (= tokenIndex 1248))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 1250))) (')' (ELEMENT_OPTIONS (= tokenIndex 1252))))) (* (BLOCK (ALT ({precpred(_ctx, 4)}? (ELEMENT_OPTIONS (= p 4))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 1215))) (DIV (ELEMENT_OPTIONS (= tokenIndex 1219))))) (= ari (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 1224) (= p 5)))) {if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}}) (ALT ({precpred(_ctx, 3)}? (ELEMENT_OPTIONS (= p 3))) (SET (PLUS (ELEMENT_OPTIONS (= tokenIndex 1233))) (SUB (ELEMENT_OPTIONS (= tokenIndex 1236)))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 1239) (= p 4)))))))))
2025-04-16 18:17:21:028 left-recursion LogManager.java:25 condition
    :   ( {} LPAR<tokenIndex=1536> condition<tokenIndex=1538> RPAR<tokenIndex=1540> 
        | NOT<tokenIndex=1543> condition<tokenIndex=1545,p=6> 
        | partCondition<tokenIndex=1563> 
        | var<tokenIndex=1566> {this.boolList.add($var.type);} 
        | BOOLEANVALUE<tokenIndex=1572> 
        )
        (
          {precpred(_ctx, 5)}?<p=5> AND<tokenIndex=1551> condition<tokenIndex=1553,p=6>
                  | {precpred(_ctx, 4)}?<p=4> OR<tokenIndex=1558> condition<tokenIndex=1560,p=5>
        )*
    ;
2025-04-16 18:17:21:032 grammar LogManager.java:25 added: (RULE condition (BLOCK (ALT (BLOCK (ALT {} (LPAR (ELEMENT_OPTIONS (= tokenIndex 1536))) (condition (ELEMENT_OPTIONS (= tokenIndex 1538))) (RPAR (ELEMENT_OPTIONS (= tokenIndex 1540)))) (ALT (NOT (ELEMENT_OPTIONS (= tokenIndex 1543))) (condition (ELEMENT_OPTIONS (= tokenIndex 1545) (= p 6)))) (ALT (partCondition (ELEMENT_OPTIONS (= tokenIndex 1563)))) (ALT (var (ELEMENT_OPTIONS (= tokenIndex 1566))) {this.boolList.add($var.type);}) (ALT (BOOLEANVALUE (ELEMENT_OPTIONS (= tokenIndex 1572))))) (* (BLOCK (ALT ({precpred(_ctx, 5)}? (ELEMENT_OPTIONS (= p 5))) (AND (ELEMENT_OPTIONS (= tokenIndex 1551))) (condition (ELEMENT_OPTIONS (= tokenIndex 1553) (= p 6)))) (ALT ({precpred(_ctx, 4)}? (ELEMENT_OPTIONS (= p 4))) (OR (ELEMENT_OPTIONS (= tokenIndex 1558))) (condition (ELEMENT_OPTIONS (= tokenIndex 1560) (= p 5)))))))))
2025-04-16 18:17:21:042 semantics LogManager.java:25 tokens={EOF=-1, BOOLEANVALUE=1, INPUT=2, OUTPUT=3, TYPE=4, MAIN=5, VAR=6, BEGIN=7, END=8, IF=9, ELSE=10, ELSIF=11, THEN=12, SWITCH=13, CASE=14, BREAK=15, DEFAULT=16, WHILE=17, DO=18, FOR=19, FROM=20, TO=21, STEP=22, AND=23, OR=24, LET=25, DEFINE=26, CONST=27, IDF=28, INT=29, FLOAT=30, STRING=31, CHAR=32, CONCAT=33, AFFECT=34, NOT=35, GREATER=36, LESSER=37, GEQ=38, LEQ=39, EQ=40, NEQ=41, LBRACE=42, RBRACE=43, PLUS=44, SUB=45, MUL=46, DIV=47, COM=48, SEMI=49, LBRACKET=50, RBRACKET=51, LPAR=52, RPAR=53, ASSIGN=54, TWOPOINT=55, COMMENT=56, WS=57, ERROR_TOKEN=58}
2025-04-16 18:17:21:042 semantics LogManager.java:25 strings={'input'=2, 'output'=3, 'MainPrgm'=5, 'Var'=6, 'BeginPg'=7, 'EndPg'=8, 'if'=9, 'else'=10, 'elsif'=11, 'then'=12, 'switch'=13, 'case'=14, 'break'=15, 'default'=16, 'while'=17, 'do'=18, 'for'=19, 'from'=20, 'to'=21, 'step'=22, 'AND'=23, 'OR'=24, 'let'=25, '@define'=26, 'Const'=27, '.'=33, ':='=34, '!'=35, '>'=36, '<'=37, '>='=38, '<='=39, '=='=40, '!='=41, '{'=42, '}'=43, '+'=44, '-'=45, '*'=46, '/'=47, ','=48, ';'=49, '['=50, ']'=51, '('=52, ')'=53, '='=54, ':'=55}
2025-04-16 18:17:21:074 LL1 LogManager.java:25 
DECISION 0 in rule varBlock
2025-04-16 18:17:21:075 LL1 LogManager.java:25 look=[{25..26}, 7]
2025-04-16 18:17:21:075 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:075 LL1 LogManager.java:25 
DECISION 1 in rule varBlock
2025-04-16 18:17:21:075 LL1 LogManager.java:25 look=[6, 6]
2025-04-16 18:17:21:075 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:075 LL1 LogManager.java:25 
DECISION 2 in rule declaration
2025-04-16 18:17:21:075 LL1 LogManager.java:25 look=[{25..26}, {25..26}]
2025-04-16 18:17:21:075 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:075 LL1 LogManager.java:25 
DECISION 3 in rule listIDF
2025-04-16 18:17:21:078 LL1 LogManager.java:25 look=[48, {53, 55}]
2025-04-16 18:17:21:078 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:078 LL1 LogManager.java:25 
DECISION 4 in rule normalDeclaration
2025-04-16 18:17:21:078 LL1 LogManager.java:25 look=[{25..26}, {25..26}]
2025-04-16 18:17:21:078 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:078 LL1 LogManager.java:25 
DECISION 5 in rule number
2025-04-16 18:17:21:078 LL1 LogManager.java:25 look=[29, 30]
2025-04-16 18:17:21:078 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:078 LL1 LogManager.java:25 
DECISION 6 in rule arrayDeclaration
2025-04-16 18:17:21:079 LL1 LogManager.java:25 look=[{1, 28..32, 35, 52}, 43]
2025-04-16 18:17:21:079 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:079 LL1 LogManager.java:25 
DECISION 7 in rule arrayDeclaration
2025-04-16 18:17:21:079 LL1 LogManager.java:25 look=[{25..26}, {25..26}, {25..26}]
2025-04-16 18:17:21:079 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:079 LL1 LogManager.java:25 
DECISION 8 in rule affectArray
2025-04-16 18:17:21:081 LL1 LogManager.java:25 look=[{1, 28..32, 35, 52}, 43]
2025-04-16 18:17:21:081 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:081 LL1 LogManager.java:25 
DECISION 9 in rule declarationKeyword
2025-04-16 18:17:21:081 LL1 LogManager.java:25 look=[26, 25]
2025-04-16 18:17:21:081 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:081 LL1 LogManager.java:25 
DECISION 10 in rule listValue
2025-04-16 18:17:21:084 LL1 LogManager.java:25 look=[48, {1, 28..32, 35, 43, 52}]
2025-04-16 18:17:21:084 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:084 LL1 LogManager.java:25 
DECISION 11 in rule value
2025-04-16 18:17:21:084 LL1 LogManager.java:25 look=[28, {29..30}, 1, 32, 31, {1, 28..30, 35, 52}, {28..30, 52}, {28, 31..32}]
2025-04-16 18:17:21:084 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:084 LL1 LogManager.java:25 
DECISION 12 in rule mainCode
2025-04-16 18:17:21:085 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 18:17:21:085 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:085 LL1 LogManager.java:25 
DECISION 13 in rule mainCode
2025-04-16 18:17:21:085 LL1 LogManager.java:25 look=[7, 7]
2025-04-16 18:17:21:085 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:085 LL1 LogManager.java:25 
DECISION 14 in rule inst
2025-04-16 18:17:21:085 LL1 LogManager.java:25 look=[3, 2, 28, 18, 17, 9, 13, 19]
2025-04-16 18:17:21:085 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:085 LL1 LogManager.java:25 
DECISION 15 in rule content
2025-04-16 18:17:21:085 LL1 LogManager.java:25 look=[{28, 31}, {28, 31}]
2025-04-16 18:17:21:085 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:085 LL1 LogManager.java:25 
DECISION 16 in rule content
2025-04-16 18:17:21:085 LL1 LogManager.java:25 look=[{28, 31}, {28, 31}]
2025-04-16 18:17:21:085 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:085 LL1 LogManager.java:25 
DECISION 17 in rule affectInst
2025-04-16 18:17:21:086 LL1 LogManager.java:25 look=[{1, 28..32, 35, 52}, 43]
2025-04-16 18:17:21:086 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:086 LL1 LogManager.java:25 
DECISION 18 in rule affectInst
2025-04-16 18:17:21:086 LL1 LogManager.java:25 look=[28, 28, 28, 28]
2025-04-16 18:17:21:086 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:086 LL1 LogManager.java:25 
DECISION 19 in rule concatInst
2025-04-16 18:17:21:086 LL1 LogManager.java:25 look=[31, 32, 28]
2025-04-16 18:17:21:086 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:086 LL1 LogManager.java:25 
DECISION 20 in rule concatInst
2025-04-16 18:17:21:086 LL1 LogManager.java:25 look=[28, 31, 32]
2025-04-16 18:17:21:086 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:086 LL1 LogManager.java:25 
DECISION 21 in rule concatInst
2025-04-16 18:17:21:087 LL1 LogManager.java:25 look=[33, {1, 28..32, 35, 43, 48..49, 52}]
2025-04-16 18:17:21:087 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:087 LL1 LogManager.java:25 
DECISION 22 in rule arithmeticExpression
2025-04-16 18:17:21:087 LL1 LogManager.java:25 look=[{28..30}, 52]
2025-04-16 18:17:21:087 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:087 LL1 LogManager.java:25 
DECISION 23 in rule arithmeticExpression
2025-04-16 18:17:21:087 LL1 LogManager.java:25 look=[null, null]
2025-04-16 18:17:21:087 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:087 LL1 LogManager.java:25 
DECISION 24 in rule arithmeticExpression
2025-04-16 18:17:21:087 LL1 LogManager.java:25 look=[null, null]
2025-04-16 18:17:21:087 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:087 LL1 LogManager.java:25 
DECISION 25 in rule operator
2025-04-16 18:17:21:087 LL1 LogManager.java:25 look=[{29..30}, 28]
2025-04-16 18:17:21:087 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:087 LL1 LogManager.java:25 
DECISION 26 in rule var
2025-04-16 18:17:21:087 LL1 LogManager.java:25 look=[28, 28]
2025-04-16 18:17:21:087 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:087 LL1 LogManager.java:25 
DECISION 27 in rule forInst
2025-04-16 18:17:21:087 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 18:17:21:087 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:087 LL1 LogManager.java:25 
DECISION 28 in rule doWhileInst
2025-04-16 18:17:21:087 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 18:17:21:087 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:087 LL1 LogManager.java:25 
DECISION 29 in rule whileInst
2025-04-16 18:17:21:087 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 18:17:21:087 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:088 LL1 LogManager.java:25 
DECISION 30 in rule ifInst
2025-04-16 18:17:21:091 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 18:17:21:091 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:091 LL1 LogManager.java:25 
DECISION 31 in rule ifInst
2025-04-16 18:17:21:092 LL1 LogManager.java:25 look=[11, {2..3, 9..10, 13, 15, 17..19, 28, 43}]
2025-04-16 18:17:21:092 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:092 LL1 LogManager.java:25 
DECISION 32 in rule ifInst
2025-04-16 18:17:21:093 LL1 LogManager.java:25 look=[10, {2..3, 9, 13, 15, 17..19, 28, 43}]
2025-04-16 18:17:21:093 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:093 LL1 LogManager.java:25 
DECISION 33 in rule elseIfInst
2025-04-16 18:17:21:093 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 18:17:21:093 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:093 LL1 LogManager.java:25 
DECISION 34 in rule elseIfInst
2025-04-16 18:17:21:093 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 18:17:21:093 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:093 LL1 LogManager.java:25 
DECISION 35 in rule elseIfInst
2025-04-16 18:17:21:093 LL1 LogManager.java:25 look=[11, 11]
2025-04-16 18:17:21:093 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:093 LL1 LogManager.java:25 
DECISION 36 in rule elseInst
2025-04-16 18:17:21:093 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 43]
2025-04-16 18:17:21:093 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:093 LL1 LogManager.java:25 
DECISION 37 in rule caseValue
2025-04-16 18:17:21:093 LL1 LogManager.java:25 look=[{29..30}, 1, 32, 31]
2025-04-16 18:17:21:093 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:093 LL1 LogManager.java:25 
DECISION 38 in rule caseInst
2025-04-16 18:17:21:093 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 15]
2025-04-16 18:17:21:093 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:093 LL1 LogManager.java:25 
DECISION 39 in rule caseInst
2025-04-16 18:17:21:093 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 15]
2025-04-16 18:17:21:093 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:093 LL1 LogManager.java:25 
DECISION 40 in rule caseInst
2025-04-16 18:17:21:093 LL1 LogManager.java:25 look=[14, 14]
2025-04-16 18:17:21:093 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:093 LL1 LogManager.java:25 
DECISION 41 in rule defaultInst
2025-04-16 18:17:21:094 LL1 LogManager.java:25 look=[{2..3, 9, 13, 17..19, 28}, 15]
2025-04-16 18:17:21:094 LL1 LogManager.java:25 LL(1)? true
2025-04-16 18:17:21:094 LL1 LogManager.java:25 
DECISION 42 in rule condition
2025-04-16 18:17:21:094 LL1 LogManager.java:25 look=[52, 35, {28..30, 52}, 28, 1]
2025-04-16 18:17:21:094 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:094 LL1 LogManager.java:25 
DECISION 43 in rule condition
2025-04-16 18:17:21:094 LL1 LogManager.java:25 look=[null, null]
2025-04-16 18:17:21:094 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:094 LL1 LogManager.java:25 
DECISION 44 in rule condition
2025-04-16 18:17:21:094 LL1 LogManager.java:25 look=[null, null]
2025-04-16 18:17:21:094 LL1 LogManager.java:25 LL(1)? false
2025-04-16 18:17:21:096 action-translator LogManager.java:25 translate 
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();

2025-04-16 18:17:21:096 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;

2025-04-16 18:17:21:136 action-translator LogManager.java:25 translate types.clear();
2025-04-16 18:17:21:137 action-translator LogManager.java:25 translate 
this.types.add($value.type);
    for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$value.text,types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }

2025-04-16 18:17:21:137 action-translator LogManager.java:25 qattr [@-1,18:22='value',<0>,125:16].[@-1,24:27='type',<0>,125:22]
2025-04-16 18:17:21:138 action-translator LogManager.java:25 qattr [@-1,52:58='listIDF',<0>,126:20].[@-1,60:62='ctx',<0>,126:28]
2025-04-16 18:17:21:144 action-translator LogManager.java:25 qattr [@-1,144:161='declarationKeyword',<0>,127:60].[@-1,163:165='mul',<0>,127:79]
2025-04-16 18:17:21:144 action-translator LogManager.java:25 qattr [@-1,169:172='TYPE',<0>,127:85].[@-1,174:177='text',<0>,127:90]
2025-04-16 18:17:21:145 action-translator LogManager.java:25 qattr [@-1,180:184='value',<0>,127:96].[@-1,186:189='text',<0>,127:102]
2025-04-16 18:17:21:147 action-translator LogManager.java:25 translate 
        for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
    }
       
2025-04-16 18:17:21:147 action-translator LogManager.java:25 qattr [@-1,26:32='listIDF',<0>,133:24].[@-1,34:36='ctx',<0>,133:32]
2025-04-16 18:17:21:147 action-translator LogManager.java:25 qattr [@-1,113:130='declarationKeyword',<0>,134:55].[@-1,132:134='mul',<0>,134:74]
2025-04-16 18:17:21:147 action-translator LogManager.java:25 qattr [@-1,138:141='TYPE',<0>,134:80].[@-1,143:146='text',<0>,134:85]
2025-04-16 18:17:21:148 action-translator LogManager.java:25 translate  $type = new ErrorToken($INT.text,"INT",$INT.line,$INT.pos); 
2025-04-16 18:17:21:148 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,139:41] [@-1,8:58=' new ErrorToken($INT.text,"INT",$INT.line,$INT.pos)',<0>,139:47]
2025-04-16 18:17:21:148 action-translator LogManager.java:25 translate  new ErrorToken($INT.text,"INT",$INT.line,$INT.pos)
2025-04-16 18:17:21:148 action-translator LogManager.java:25 qattr [@-1,17:19='INT',<0>,139:56].[@-1,21:24='text',<0>,139:60]
2025-04-16 18:17:21:148 action-translator LogManager.java:25 qattr [@-1,33:35='INT',<0>,139:72].[@-1,37:40='line',<0>,139:76]
2025-04-16 18:17:21:150 action-translator LogManager.java:25 qattr [@-1,43:45='INT',<0>,139:82].[@-1,47:49='pos',<0>,139:86]
2025-04-16 18:17:21:151 action-translator LogManager.java:25 translate  $type = new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos); 
2025-04-16 18:17:21:151 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,139:115] [@-1,8:66=' new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos)',<0>,139:121]
2025-04-16 18:17:21:151 action-translator LogManager.java:25 translate  new ErrorToken($FLOAT.text,"FLOAT",$FLOAT.line,$FLOAT.pos)
2025-04-16 18:17:21:151 action-translator LogManager.java:25 qattr [@-1,17:21='FLOAT',<0>,139:130].[@-1,23:26='text',<0>,139:136]
2025-04-16 18:17:21:151 action-translator LogManager.java:25 qattr [@-1,37:41='FLOAT',<0>,139:150].[@-1,43:46='line',<0>,139:156]
2025-04-16 18:17:21:152 action-translator LogManager.java:25 qattr [@-1,49:53='FLOAT',<0>,139:162].[@-1,55:57='pos',<0>,139:168]
2025-04-16 18:17:21:154 action-translator LogManager.java:25 translate types.clear();
2025-04-16 18:17:21:154 action-translator LogManager.java:25 translate 
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }

2025-04-16 18:17:21:155 action-translator LogManager.java:25 qattr [@-1,20:26='listIDF',<0>,142:18].[@-1,28:30='ctx',<0>,142:26]
2025-04-16 18:17:21:155 action-translator LogManager.java:25 qattr [@-1,116:133='declarationKeyword',<0>,143:64].[@-1,135:137='mul',<0>,143:83]
2025-04-16 18:17:21:155 action-translator LogManager.java:25 qattr [@-1,141:144='TYPE',<0>,143:89].[@-1,146:149='text',<0>,143:94]
2025-04-16 18:17:21:155 action-translator LogManager.java:25 qattr [@-1,152:154='INT',<0>,143:100].[@-1,156:159='text',<0>,143:104]
2025-04-16 18:17:21:156 action-translator LogManager.java:25 translate 
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeTypeValue(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,this.types,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }

2025-04-16 18:17:21:156 action-translator LogManager.java:25 qattr [@-1,20:26='listIDF',<0>,148:18].[@-1,28:30='ctx',<0>,148:26]
2025-04-16 18:17:21:156 action-translator LogManager.java:25 qattr [@-1,116:133='declarationKeyword',<0>,149:64].[@-1,135:137='mul',<0>,149:83]
2025-04-16 18:17:21:156 action-translator LogManager.java:25 qattr [@-1,141:144='TYPE',<0>,149:89].[@-1,146:149='text',<0>,149:94]
2025-04-16 18:17:21:156 action-translator LogManager.java:25 qattr [@-1,152:154='INT',<0>,149:100].[@-1,156:159='text',<0>,149:104]
2025-04-16 18:17:21:157 action-translator LogManager.java:25 translate 
  for (var idf : $listIDF.ctx.getTokens(IDF)) { 
        IDF_HashTable.table.updateSizeType(idf.getText(), $declarationKeyword.mul ,$TYPE.text,$INT.text,idf.getSymbol().getLine(),idf.getSymbol().getCharPositionInLine());
  }

2025-04-16 18:17:21:157 action-translator LogManager.java:25 qattr [@-1,20:26='listIDF',<0>,155:18].[@-1,28:30='ctx',<0>,155:26]
2025-04-16 18:17:21:157 action-translator LogManager.java:25 qattr [@-1,111:128='declarationKeyword',<0>,156:59].[@-1,130:132='mul',<0>,156:78]
2025-04-16 18:17:21:157 action-translator LogManager.java:25 qattr [@-1,136:139='TYPE',<0>,156:84].[@-1,141:144='text',<0>,156:89]
2025-04-16 18:17:21:157 action-translator LogManager.java:25 qattr [@-1,147:149='INT',<0>,156:95].[@-1,151:154='text',<0>,156:99]
2025-04-16 18:17:21:158 action-translator LogManager.java:25 translate $mul = "Constant";
2025-04-16 18:17:21:159 action-translator LogManager.java:25 setAttr [@-1,1:3='mul',<0>,161:54] [@-1,6:16=' "Constant"',<0>,161:59]
2025-04-16 18:17:21:159 action-translator LogManager.java:25 translate  "Constant"
2025-04-16 18:17:21:159 action-translator LogManager.java:25 translate $mul = "Variable";
2025-04-16 18:17:21:159 action-translator LogManager.java:25 setAttr [@-1,1:3='mul',<0>,161:81] [@-1,6:16=' "Variable"',<0>,161:86]
2025-04-16 18:17:21:159 action-translator LogManager.java:25 translate  "Variable"
2025-04-16 18:17:21:160 action-translator LogManager.java:25 translate ErrorToken type_1 = $v1.type; type_1.exp = $v1.text; this.types.add(type_1); 
2025-04-16 18:17:21:160 action-translator LogManager.java:25 qattr [@-1,21:22='v1',<0>,162:41].[@-1,24:27='type',<0>,162:44]
2025-04-16 18:17:21:160 action-translator LogManager.java:25 qattr [@-1,44:45='v1',<0>,162:64].[@-1,47:50='text',<0>,162:67]
2025-04-16 18:17:21:160 action-translator LogManager.java:25 translate  ErrorToken type_2 = $v.type; type_2.exp = $v.text; this.types.add(type_2);
2025-04-16 18:17:21:160 action-translator LogManager.java:25 qattr [@-1,22:22='v',<0>,162:136].[@-1,24:27='type',<0>,162:138]
2025-04-16 18:17:21:160 action-translator LogManager.java:25 qattr [@-1,44:44='v',<0>,162:158].[@-1,46:49='text',<0>,162:160]
2025-04-16 18:17:21:161 action-translator LogManager.java:25 translate this.boolList.clear(); this.compareList.clear(); this.concatList.clear(); this.arithmeticList.clear();
2025-04-16 18:17:21:162 action-translator LogManager.java:25 translate $type= $var.type;
2025-04-16 18:17:21:162 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,163:150] [@-1,6:15=' $var.type',<0>,163:155]
2025-04-16 18:17:21:162 action-translator LogManager.java:25 translate  $var.type
2025-04-16 18:17:21:162 action-translator LogManager.java:25 qattr [@-1,2:4='var',<0>,163:151].[@-1,6:9='type',<0>,163:155]
2025-04-16 18:17:21:162 action-translator LogManager.java:25 translate $type = $number.type;
2025-04-16 18:17:21:162 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,163:178] [@-1,7:19=' $number.type',<0>,163:184]
2025-04-16 18:17:21:162 action-translator LogManager.java:25 translate  $number.type
2025-04-16 18:17:21:162 action-translator LogManager.java:25 qattr [@-1,2:7='number',<0>,163:179].[@-1,9:12='type',<0>,163:186]
2025-04-16 18:17:21:163 action-translator LogManager.java:25 translate $type = new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos);
2025-04-16 18:17:21:163 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,163:217] [@-1,7:85=' new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos)',<0>,163:223]
2025-04-16 18:17:21:163 action-translator LogManager.java:25 translate  new ErrorToken($BOOLEANVALUE.text,"BOOL",$BOOLEANVALUE.line,$BOOLEANVALUE.pos)
2025-04-16 18:17:21:163 action-translator LogManager.java:25 qattr [@-1,17:28='BOOLEANVALUE',<0>,163:233].[@-1,30:33='text',<0>,163:246]
2025-04-16 18:17:21:163 action-translator LogManager.java:25 qattr [@-1,43:54='BOOLEANVALUE',<0>,163:259].[@-1,56:59='line',<0>,163:272]
2025-04-16 18:17:21:163 action-translator LogManager.java:25 qattr [@-1,62:73='BOOLEANVALUE',<0>,163:278].[@-1,75:77='pos',<0>,163:291]
2025-04-16 18:17:21:164 action-translator LogManager.java:25 translate $type = new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos); 
2025-04-16 18:17:21:164 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,163:314] [@-1,7:61=' new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos)',<0>,163:320]
2025-04-16 18:17:21:164 action-translator LogManager.java:25 translate  new ErrorToken($CHAR.text,"CHAR",$CHAR.line,$CHAR.pos)
2025-04-16 18:17:21:164 action-translator LogManager.java:25 qattr [@-1,17:20='CHAR',<0>,163:330].[@-1,22:25='text',<0>,163:335]
2025-04-16 18:17:21:164 action-translator LogManager.java:25 qattr [@-1,35:38='CHAR',<0>,163:348].[@-1,40:43='line',<0>,163:353]
2025-04-16 18:17:21:164 action-translator LogManager.java:25 qattr [@-1,46:49='CHAR',<0>,163:359].[@-1,51:53='pos',<0>,163:364]
2025-04-16 18:17:21:164 action-translator LogManager.java:25 translate $type = new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos);
2025-04-16 18:17:21:165 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,163:390] [@-1,7:69=' new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos)',<0>,163:396]
2025-04-16 18:17:21:165 action-translator LogManager.java:25 translate  new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos)
2025-04-16 18:17:21:165 action-translator LogManager.java:25 qattr [@-1,17:22='STRING',<0>,163:406].[@-1,24:27='text',<0>,163:413]
2025-04-16 18:17:21:165 action-translator LogManager.java:25 qattr [@-1,39:44='STRING',<0>,163:428].[@-1,46:49='line',<0>,163:435]
2025-04-16 18:17:21:165 action-translator LogManager.java:25 qattr [@-1,52:57='STRING',<0>,163:441].[@-1,59:61='pos',<0>,163:448]
2025-04-16 18:17:21:165 action-translator LogManager.java:25 translate $type = IDF_HashTable.table.conditionType(this.boolList,this.compareList);
2025-04-16 18:17:21:165 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,163:477] [@-1,7:72=' IDF_HashTable.table.conditionType(this.boolList,this.compareList)',<0>,163:483]
2025-04-16 18:17:21:165 action-translator LogManager.java:25 translate  IDF_HashTable.table.conditionType(this.boolList,this.compareList)
2025-04-16 18:17:21:165 action-translator LogManager.java:25 translate $type=IDF_HashTable.table.getType(this.arithmeticList,0);
2025-04-16 18:17:21:165 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,163:576] [@-1,6:55='IDF_HashTable.table.getType(this.arithmeticList,0)',<0>,163:581]
2025-04-16 18:17:21:165 action-translator LogManager.java:25 translate IDF_HashTable.table.getType(this.arithmeticList,0)
2025-04-16 18:17:21:166 action-translator LogManager.java:25 translate $type=IDF_HashTable.table.getType(this.concatList,1);
2025-04-16 18:17:21:166 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,163:649] [@-1,6:51='IDF_HashTable.table.getType(this.concatList,1)',<0>,163:654]
2025-04-16 18:17:21:166 action-translator LogManager.java:25 translate IDF_HashTable.table.getType(this.concatList,1)
2025-04-16 18:17:21:168 action-translator LogManager.java:25 translate  this.types.clear();
2025-04-16 18:17:21:170 action-translator LogManager.java:25 translate  this.types.clear(); 
2025-04-16 18:17:21:171 action-translator LogManager.java:25 translate  
  IDF_HashTable.table.affectMONO($var_2.text,$var_1.type, $var_2.type,$var_1.start.getLine(),$var_1.start.getCharPositionInLine());

2025-04-16 18:17:21:171 action-translator LogManager.java:25 qattr [@-1,37:41='var_2',<0>,172:34].[@-1,43:46='text',<0>,172:40]
2025-04-16 18:17:21:171 action-translator LogManager.java:25 qattr [@-1,49:53='var_1',<0>,172:46].[@-1,55:58='type',<0>,172:52]
2025-04-16 18:17:21:171 action-translator LogManager.java:25 qattr [@-1,62:66='var_2',<0>,172:59].[@-1,68:71='type',<0>,172:65]
2025-04-16 18:17:21:171 action-translator LogManager.java:25 qattr [@-1,74:78='var_1',<0>,172:71].[@-1,80:84='start',<0>,172:77]
2025-04-16 18:17:21:171 action-translator LogManager.java:25 qattr [@-1,97:101='var_1',<0>,172:94].[@-1,103:107='start',<0>,172:100]
2025-04-16 18:17:21:172 action-translator LogManager.java:25 translate 
 	IDF_HashTable.table.affectEXP($value.text,$var.type, $value.type,$var.start.getLine(),$var.start.getCharPositionInLine());
	

2025-04-16 18:17:21:172 action-translator LogManager.java:25 qattr [@-1,35:39='value',<0>,176:33].[@-1,41:44='text',<0>,176:39]
2025-04-16 18:17:21:172 action-translator LogManager.java:25 qattr [@-1,47:49='var',<0>,176:45].[@-1,51:54='type',<0>,176:49]
2025-04-16 18:17:21:172 action-translator LogManager.java:25 qattr [@-1,58:62='value',<0>,176:56].[@-1,64:67='type',<0>,176:62]
2025-04-16 18:17:21:172 action-translator LogManager.java:25 qattr [@-1,70:72='var',<0>,176:68].[@-1,74:78='start',<0>,176:72]
2025-04-16 18:17:21:172 action-translator LogManager.java:25 qattr [@-1,91:93='var',<0>,176:89].[@-1,95:99='start',<0>,176:93]
2025-04-16 18:17:21:173 action-translator LogManager.java:25 translate 
  IDF_HashTable.table.affectArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos),this.types, $IDF.line,$IDF.pos);

2025-04-16 18:17:21:173 action-translator LogManager.java:25 qattr [@-1,37:39='IDF',<0>,181:35].[@-1,41:44='text',<0>,181:39]
2025-04-16 18:17:21:173 action-translator LogManager.java:25 qattr [@-1,91:93='IDF',<0>,181:89].[@-1,95:98='text',<0>,181:93]
2025-04-16 18:17:21:173 action-translator LogManager.java:25 qattr [@-1,101:103='IDF',<0>,181:99].[@-1,105:108='line',<0>,181:103]
2025-04-16 18:17:21:174 action-translator LogManager.java:25 qattr [@-1,111:113='IDF',<0>,181:109].[@-1,115:117='pos',<0>,181:113]
2025-04-16 18:17:21:174 action-translator LogManager.java:25 qattr [@-1,133:135='IDF',<0>,181:131].[@-1,137:140='line',<0>,181:135]
2025-04-16 18:17:21:174 action-translator LogManager.java:25 qattr [@-1,143:145='IDF',<0>,181:141].[@-1,147:149='pos',<0>,181:145]
2025-04-16 18:17:21:174 action-translator LogManager.java:25 translate 
  IDF_HashTable.table.affectEmptyArray($IDF.text,IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos), $IDF.line,$IDF.pos);

2025-04-16 18:17:21:174 action-translator LogManager.java:25 qattr [@-1,42:44='IDF',<0>,185:40].[@-1,46:49='text',<0>,185:44]
2025-04-16 18:17:21:174 action-translator LogManager.java:25 qattr [@-1,96:98='IDF',<0>,185:94].[@-1,100:103='text',<0>,185:98]
2025-04-16 18:17:21:174 action-translator LogManager.java:25 qattr [@-1,106:108='IDF',<0>,185:104].[@-1,110:113='line',<0>,185:108]
2025-04-16 18:17:21:174 action-translator LogManager.java:25 qattr [@-1,116:118='IDF',<0>,185:114].[@-1,120:122='pos',<0>,185:118]
2025-04-16 18:17:21:175 action-translator LogManager.java:25 qattr [@-1,127:129='IDF',<0>,185:125].[@-1,131:134='line',<0>,185:129]
2025-04-16 18:17:21:175 action-translator LogManager.java:25 qattr [@-1,137:139='IDF',<0>,185:135].[@-1,141:143='pos',<0>,185:139]
2025-04-16 18:17:21:176 action-translator LogManager.java:25 translate this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));
2025-04-16 18:17:21:176 action-translator LogManager.java:25 qattr [@-1,36:41='STRING',<0>,189:57].[@-1,43:46='text',<0>,189:64]
2025-04-16 18:17:21:176 action-translator LogManager.java:25 qattr [@-1,58:63='STRING',<0>,189:79].[@-1,65:68='line',<0>,189:86]
2025-04-16 18:17:21:176 action-translator LogManager.java:25 qattr [@-1,71:76='STRING',<0>,189:92].[@-1,78:80='pos',<0>,189:99]
2025-04-16 18:17:21:177 action-translator LogManager.java:25 translate this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));
2025-04-16 18:17:21:177 action-translator LogManager.java:25 qattr [@-1,36:39='CHAR',<0>,189:150].[@-1,41:44='text',<0>,189:155]
2025-04-16 18:17:21:177 action-translator LogManager.java:25 qattr [@-1,56:59='CHAR',<0>,189:170].[@-1,61:64='line',<0>,189:175]
2025-04-16 18:17:21:177 action-translator LogManager.java:25 qattr [@-1,67:70='CHAR',<0>,189:181].[@-1,72:74='pos',<0>,189:186]
2025-04-16 18:17:21:177 action-translator LogManager.java:25 translate this.concatList.add($var.type);
2025-04-16 18:17:21:177 action-translator LogManager.java:25 qattr [@-1,21:23='var',<0>,189:221].[@-1,25:28='type',<0>,189:225]
2025-04-16 18:17:21:177 action-translator LogManager.java:25 translate this.concatList.add($var.type);
2025-04-16 18:17:21:178 action-translator LogManager.java:25 qattr [@-1,21:23='var',<0>,189:268].[@-1,25:28='type',<0>,189:272]
2025-04-16 18:17:21:178 action-translator LogManager.java:25 translate this.concatList.add(new ErrorToken($STRING.text,"STRING",$STRING.line,$STRING.pos));
2025-04-16 18:17:21:178 action-translator LogManager.java:25 qattr [@-1,36:41='STRING',<0>,189:324].[@-1,43:46='text',<0>,189:331]
2025-04-16 18:17:21:178 action-translator LogManager.java:25 qattr [@-1,58:63='STRING',<0>,189:346].[@-1,65:68='line',<0>,189:353]
2025-04-16 18:17:21:178 action-translator LogManager.java:25 qattr [@-1,71:76='STRING',<0>,189:359].[@-1,78:80='pos',<0>,189:366]
2025-04-16 18:17:21:178 action-translator LogManager.java:25 translate this.concatList.add(new ErrorToken($CHAR.text,"STRING",$CHAR.line,$CHAR.pos));
2025-04-16 18:17:21:178 action-translator LogManager.java:25 qattr [@-1,36:39='CHAR',<0>,189:415].[@-1,41:44='text',<0>,189:420]
2025-04-16 18:17:21:179 action-translator LogManager.java:25 qattr [@-1,56:59='CHAR',<0>,189:435].[@-1,61:64='line',<0>,189:440]
2025-04-16 18:17:21:179 action-translator LogManager.java:25 qattr [@-1,67:70='CHAR',<0>,189:446].[@-1,72:74='pos',<0>,189:451]
2025-04-16 18:17:21:180 action-translator LogManager.java:25 translate 
2025-04-16 18:17:21:180 action-translator LogManager.java:25 translate this.arithmeticList.add($operator.type);
2025-04-16 18:17:21:180 action-translator LogManager.java:25 qattr [@-1,25:32='operator',<0>,2:64].[@-1,34:37='type',<0>,2:73]
2025-04-16 18:17:21:181 action-translator LogManager.java:25 translate precpred(_ctx, 4)
2025-04-16 18:17:21:182 action-translator LogManager.java:25 translate if($op.type == DIV){ this.arithmeticList.add(validateIDF.isDividingByZero(this.arithmeticList,$ari.text, $ari.start.getLine(), $ari.start.getCharPositionInLine()));}
2025-04-16 18:17:21:182 action-translator LogManager.java:25 qattr [@-1,4:5='op',<0>,6:136].[@-1,7:10='type',<0>,6:139]
2025-04-16 18:17:21:182 action-translator LogManager.java:25 qattr [@-1,95:97='ari',<0>,6:227].[@-1,99:102='text',<0>,6:231]
2025-04-16 18:17:21:182 action-translator LogManager.java:25 qattr [@-1,106:108='ari',<0>,6:238].[@-1,110:114='start',<0>,6:242]
2025-04-16 18:17:21:182 action-translator LogManager.java:25 qattr [@-1,128:130='ari',<0>,6:260].[@-1,132:136='start',<0>,6:264]
2025-04-16 18:17:21:182 action-translator LogManager.java:25 translate precpred(_ctx, 3)
2025-04-16 18:17:21:184 action-translator LogManager.java:25 translate precpred(_ctx, 4)
2025-04-16 18:17:21:184 action-translator LogManager.java:25 translate precpred(_ctx, 3)
2025-04-16 18:17:21:184 action-translator LogManager.java:25 translate $type = $number.type;
2025-04-16 18:17:21:184 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,191:44] [@-1,7:19=' $number.type',<0>,191:50]
2025-04-16 18:17:21:184 action-translator LogManager.java:25 translate  $number.type
2025-04-16 18:17:21:184 action-translator LogManager.java:25 qattr [@-1,2:7='number',<0>,191:45].[@-1,9:12='type',<0>,191:52]
2025-04-16 18:17:21:185 action-translator LogManager.java:25 translate $type = $var.type;
2025-04-16 18:17:21:185 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,191:74] [@-1,7:16=' $var.type',<0>,191:80]
2025-04-16 18:17:21:185 action-translator LogManager.java:25 translate  $var.type
2025-04-16 18:17:21:185 action-translator LogManager.java:25 qattr [@-1,2:4='var',<0>,191:75].[@-1,6:9='type',<0>,191:79]
2025-04-16 18:17:21:185 action-translator LogManager.java:25 translate $type = IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos); 
2025-04-16 18:17:21:185 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,192:36] [@-1,7:80=' IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos)',<0>,192:42]
2025-04-16 18:17:21:185 action-translator LogManager.java:25 translate  IDF_HashTable.table.getNormalTypeExpression($IDF.text,$IDF.line,$IDF.pos)
2025-04-16 18:17:21:186 action-translator LogManager.java:25 qattr [@-1,46:48='IDF',<0>,192:81].[@-1,50:53='text',<0>,192:85]
2025-04-16 18:17:21:186 action-translator LogManager.java:25 qattr [@-1,56:58='IDF',<0>,192:91].[@-1,60:63='line',<0>,192:95]
2025-04-16 18:17:21:186 action-translator LogManager.java:25 qattr [@-1,66:68='IDF',<0>,192:101].[@-1,70:72='pos',<0>,192:105]
2025-04-16 18:17:21:186 action-translator LogManager.java:25 translate $type = IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos);
2025-04-16 18:17:21:186 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,192:140] [@-1,7:89=' IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos)',<0>,192:146]
2025-04-16 18:17:21:186 action-translator LogManager.java:25 translate  IDF_HashTable.table.getArrayTypeExpression($IDF.text,$INT.text,$IDF.line,$IDF.pos)
2025-04-16 18:17:21:186 action-translator LogManager.java:25 qattr [@-1,45:47='IDF',<0>,192:184].[@-1,49:52='text',<0>,192:188]
2025-04-16 18:17:21:187 action-translator LogManager.java:25 qattr [@-1,55:57='INT',<0>,192:194].[@-1,59:62='text',<0>,192:198]
2025-04-16 18:17:21:187 action-translator LogManager.java:25 qattr [@-1,65:67='IDF',<0>,192:204].[@-1,69:72='line',<0>,192:208]
2025-04-16 18:17:21:187 action-translator LogManager.java:25 qattr [@-1,75:77='IDF',<0>,192:214].[@-1,79:81='pos',<0>,192:218]
2025-04-16 18:17:21:196 action-translator LogManager.java:25 translate 
2025-04-16 18:17:21:197 action-translator LogManager.java:25 translate this.boolList.add($var.type);
2025-04-16 18:17:21:197 action-translator LogManager.java:25 qattr [@-1,19:21='var',<0>,5:50].[@-1,23:26='type',<0>,5:54]
2025-04-16 18:17:21:197 action-translator LogManager.java:25 translate precpred(_ctx, 5)
2025-04-16 18:17:21:197 action-translator LogManager.java:25 translate precpred(_ctx, 4)
2025-04-16 18:17:21:197 action-translator LogManager.java:25 translate precpred(_ctx, 5)
2025-04-16 18:17:21:198 action-translator LogManager.java:25 translate precpred(_ctx, 4)
2025-04-16 18:17:21:198 action-translator LogManager.java:25 translate this.compareList.addAll(this.arithmeticList); 
2025-04-16 18:17:21:291 action-translator LogManager.java:25 translate 
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();

2025-04-16 18:17:21:292 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;

2025-04-16 18:17:21:292 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;

2025-04-16 18:17:21:298 action-translator LogManager.java:25 translate 
   public static final ArrayList<ErrorToken> types  = new ArrayList<>();
   public static final ArrayList<ErrorToken> arithmeticList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> concatList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> boolList  = new ArrayList<>();
   public static final ArrayList<ErrorToken> compareList  = new ArrayList<>();

2025-04-16 18:17:21:298 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;

2025-04-16 18:17:21:299 action-translator LogManager.java:25 translate 
  package application.antlr;
  import java.util.HashMap;
  import java.util.Map;
  import java.util.ArrayList;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.validate.validateIDF;
  import application.antlr.SymboleTable.Constant_Hashtable;
  import application.antlr.SymboleTable.ErrorToken;
  import application.antlr.SymboleTable.IDF_HashTable;
  import application.antlr.SymboleTable.Keywords_Hashtable;
  import application.antlr.validate.validateIDF;

