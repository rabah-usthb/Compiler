2025-03-18 14:01:08:166 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Expr (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (@ lexer members {
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }

}) (RULES (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE TYPE (BLOCK (ALT 'Int') (ALT 'Float') (ALT 'Bool') (ALT 'String') (ALT 'Char' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE VAR (BLOCK (ALT 'Var' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE END (BLOCK (ALT 'EndPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IF (BLOCK (ALT 'if' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSE (BLOCK (ALT 'else' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSIF (BLOCK (ALT 'elsif'))) (RULE THEN (BLOCK (ALT 'then' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DO (BLOCK (ALT 'do' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FOR (BLOCK (ALT 'for' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FROM (BLOCK (ALT 'from' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE TO (BLOCK (ALT 'to' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE STEP (BLOCK (ALT 'step' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE AND (BLOCK (ALT 'AND' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE OR (BLOCK (ALT 'OR' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE LET (BLOCK (ALT 'let' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DEFINE (BLOCK (ALT '@Define' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE CONST (BLOCK (ALT 'const' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (* (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());}))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) {validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.' {printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {printToken(getText(),"String Constant",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE COMPARAISONOPERATOR (BLOCK (ALT '<') (ALT '>') (ALT '>=') (ALT '<=') (ALT '==') (ALT '!='))) (RULE LBRACE (BLOCK (ALT '{'))) (RULE RBRACE (BLOCK (ALT '}'))) (RULE PLUS (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE Separators (BLOCK (ALT '(') (ALT ')') (ALT '=') (ALT ';') (ALT '[') (ALT ']') (ALT ':') (ALT ',') (ALT COMPARAISONOPERATOR {printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COMMENT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT {printToken(getText(),"Comment",getLine(),getCharPositionInLine());}))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT . {System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());
//System.exit(1);
}))) (RULE prog (BLOCK (ALT (* (BLOCK (ALT COMMENT))) MAIN IDF ';' (* (BLOCK (ALT COMMENT))) varBlock (* (BLOCK (ALT COMMENT))) mainCode (* (BLOCK (ALT COMMENT))) EOF {IDF_HashTable.table.printTable();}))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration) (ALT COMMENT))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' affectValue ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }
}))) (RULE sign (BLOCK (ALT '+') (ALT '-'))) (RULE affectValue (returns String type) (BLOCK (ALT number {$type = $number.type;}))) (RULE number (returns String type) (BLOCK (ALT '(' sign INT ')' { $type = "INT"; }) (ALT '(' sign FLOAT ')' { $type = "FLOAT"; }) (ALT INT { $type = "INT"; }) (ALT FLOAT { $type = "FLOAT"; }))) (RULE arrayDeclaration (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' affectArray ';') (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';'))) (RULE affectArray (BLOCK (ALT '=' '{' listNumber '}'))) (RULE declarationKeyword (BLOCK (ALT DEFINE CONST) (ALT LET))) (RULE listNumber (BLOCK (ALT number (* (BLOCK (ALT ',' number)))))) (RULE mainCode (BLOCK (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' (+ (BLOCK (ALT inst))) '}' (* (BLOCK (ALT COMMENT))) END ';') (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' '}' (* (BLOCK (ALT COMMENT))) END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT COMMENT) (ALT forInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (BLOCK (ALT STRING) (ALT IDF)) ','))) (BLOCK (ALT STRING) (ALT IDF))) (ALT (BLOCK (ALT STRING) (ALT IDF))))) (RULE affectInst (BLOCK (ALT var AFFECT arithmeticExpression ';'))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression operation arithmeticExpression) (ALT '(' arithmeticExpression ')') (ALT operator))) (RULE operator (BLOCK (ALT number) (ALT var))) (RULE var (BLOCK (ALT IDF) (ALT IDF '[' INT ']'))) (RULE operation (BLOCK (ALT '+') (ALT '-') (ALT '*') (ALT '/'))) (RULE forInst (BLOCK (ALT FOR IDF (? (BLOCK (ALT operation arithmeticExpression))) FROM arithmeticExpression TO arithmeticExpression STEP arithmeticExpression '{' (+ (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (+ (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (+ (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' elseIfInst) (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSE '{' (+ (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseInst (BLOCK (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (+ (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT '(' condition ')') (ALT '!' '(' condition ')') (ALT condition logicalOperator condition) (ALT partCondition))) (RULE partCondition (BLOCK (ALT IDF COMPARAISONOPERATOR arithmeticExpression))) (RULE logicalOperator (BLOCK (ALT AND) (ALT OR) (ALT NOT)))))
2025-03-18 14:01:08:226 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Expr (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (@ lexer members {
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }

}) (RULES (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE TYPE (BLOCK (ALT 'Int') (ALT 'Float') (ALT 'Bool') (ALT 'String') (ALT 'Char' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE VAR (BLOCK (ALT 'Var' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE END (BLOCK (ALT 'EndPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IF (BLOCK (ALT 'if' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSE (BLOCK (ALT 'else' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSIF (BLOCK (ALT 'elsif'))) (RULE THEN (BLOCK (ALT 'then' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DO (BLOCK (ALT 'do' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FOR (BLOCK (ALT 'for' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FROM (BLOCK (ALT 'from' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE TO (BLOCK (ALT 'to' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE STEP (BLOCK (ALT 'step' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE AND (BLOCK (ALT 'AND' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE OR (BLOCK (ALT 'OR' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE LET (BLOCK (ALT 'let' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DEFINE (BLOCK (ALT '@Define' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE CONST (BLOCK (ALT 'const' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (* (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());}))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) {validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.' {printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {printToken(getText(),"String Constant",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE COMPARAISONOPERATOR (BLOCK (ALT '<') (ALT '>') (ALT '>=') (ALT '<=') (ALT '==') (ALT '!='))) (RULE LBRACE (BLOCK (ALT '{'))) (RULE RBRACE (BLOCK (ALT '}'))) (RULE PLUS (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE Separators (BLOCK (ALT '(') (ALT ')') (ALT '=') (ALT ';') (ALT '[') (ALT ']') (ALT ':') (ALT ',') (ALT COMPARAISONOPERATOR {printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COMMENT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT {printToken(getText(),"Comment",getLine(),getCharPositionInLine());}))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT . {System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());
//System.exit(1);
}))) (RULE prog (BLOCK (ALT (* (BLOCK (ALT COMMENT))) MAIN IDF ';' (* (BLOCK (ALT COMMENT))) varBlock (* (BLOCK (ALT COMMENT))) mainCode (* (BLOCK (ALT COMMENT))) EOF {IDF_HashTable.table.printTable();}))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration) (ALT COMMENT))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' affectValue ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }
}))) (RULE sign (BLOCK (ALT (SET '+' '-')))) (RULE affectValue (returns String type) (BLOCK (ALT number {$type = $number.type;}))) (RULE number (returns String type) (BLOCK (ALT '(' sign INT ')' { $type = "INT"; }) (ALT '(' sign FLOAT ')' { $type = "FLOAT"; }) (ALT INT { $type = "INT"; }) (ALT FLOAT { $type = "FLOAT"; }))) (RULE arrayDeclaration (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' affectArray ';') (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';'))) (RULE affectArray (BLOCK (ALT '=' '{' listNumber '}'))) (RULE declarationKeyword (BLOCK (ALT DEFINE CONST) (ALT LET))) (RULE listNumber (BLOCK (ALT number (* (BLOCK (ALT ',' number)))))) (RULE mainCode (BLOCK (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' (+ (BLOCK (ALT inst))) '}' (* (BLOCK (ALT COMMENT))) END ';') (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' '}' (* (BLOCK (ALT COMMENT))) END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT COMMENT) (ALT forInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (BLOCK (ALT var AFFECT arithmeticExpression ';'))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression operation arithmeticExpression) (ALT '(' arithmeticExpression ')') (ALT operator))) (RULE operator (BLOCK (ALT number) (ALT var))) (RULE var (BLOCK (ALT IDF) (ALT IDF '[' INT ']'))) (RULE operation (BLOCK (ALT (SET '+' '-' '*' '/')))) (RULE forInst (BLOCK (ALT FOR IDF (? (BLOCK (ALT operation arithmeticExpression))) FROM arithmeticExpression TO arithmeticExpression STEP arithmeticExpression '{' (+ (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (+ (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (+ (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' elseIfInst) (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSE '{' (+ (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseInst (BLOCK (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (+ (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT '(' condition ')') (ALT '!' '(' condition ')') (ALT condition logicalOperator condition) (ALT partCondition))) (RULE partCondition (BLOCK (ALT IDF COMPARAISONOPERATOR arithmeticExpression))) (RULE logicalOperator (BLOCK (ALT (SET AND OR NOT))))))
2025-03-18 14:01:08:265 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Expr (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (RULES (RULE prog (BLOCK (ALT (* (BLOCK (ALT COMMENT))) MAIN IDF ';' (* (BLOCK (ALT COMMENT))) varBlock (* (BLOCK (ALT COMMENT))) mainCode (* (BLOCK (ALT COMMENT))) EOF {IDF_HashTable.table.printTable();}))) (RULE varBlock (BLOCK (ALT VAR (+ (BLOCK (ALT declaration)))) (ALT VAR))) (RULE declaration (BLOCK (ALT normalDeclaration) (ALT arrayDeclaration) (ALT COMMENT))) (RULE listIDF (BLOCK (ALT IDF (* (BLOCK (ALT ',' IDF)))))) (RULE normalDeclaration (BLOCK (ALT declarationKeyword listIDF ':' TYPE '=' affectValue ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }
}) (ALT declarationKeyword listIDF ':' TYPE ';' {
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }
}))) (RULE sign (BLOCK (ALT (SET '+' '-')))) (RULE affectValue (returns String type) (BLOCK (ALT number {$type = $number.type;}))) (RULE number (returns String type) (BLOCK (ALT '(' sign INT ')' { $type = "INT"; }) (ALT '(' sign FLOAT ')' { $type = "FLOAT"; }) (ALT INT { $type = "INT"; }) (ALT FLOAT { $type = "FLOAT"; }))) (RULE arrayDeclaration (BLOCK (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' affectArray ';') (ALT declarationKeyword listIDF ':' '[' TYPE ';' INT ']' ';'))) (RULE affectArray (BLOCK (ALT '=' '{' listNumber '}'))) (RULE declarationKeyword (BLOCK (ALT DEFINE CONST) (ALT LET))) (RULE listNumber (BLOCK (ALT number (* (BLOCK (ALT ',' number)))))) (RULE mainCode (BLOCK (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' (+ (BLOCK (ALT inst))) '}' (* (BLOCK (ALT COMMENT))) END ';') (ALT BEGIN (* (BLOCK (ALT COMMENT))) '{' '}' (* (BLOCK (ALT COMMENT))) END ';'))) (RULE inst (BLOCK (ALT output) (ALT input) (ALT affectInst) (ALT COMMENT) (ALT forInst) (ALT doWhileInst) (ALT whileInst) (ALT ifInst) (ALT switchInst))) (RULE input (BLOCK (ALT INPUT '(' listIDF ')' ';'))) (RULE output (BLOCK (ALT OUTPUT '(' content ')' ';'))) (RULE content (BLOCK (ALT (+ (BLOCK (ALT (SET STRING IDF) ','))) (SET STRING IDF)) (ALT (SET STRING IDF)))) (RULE affectInst (BLOCK (ALT var AFFECT arithmeticExpression ';'))) (RULE arithmeticExpression (BLOCK (ALT arithmeticExpression operation arithmeticExpression) (ALT '(' arithmeticExpression ')') (ALT operator))) (RULE operator (BLOCK (ALT number) (ALT var))) (RULE var (BLOCK (ALT IDF) (ALT IDF '[' INT ']'))) (RULE operation (BLOCK (ALT (SET '+' '-' '*' '/')))) (RULE forInst (BLOCK (ALT FOR IDF (? (BLOCK (ALT operation arithmeticExpression))) FROM arithmeticExpression TO arithmeticExpression STEP arithmeticExpression '{' (+ (BLOCK (ALT inst))) '}'))) (RULE doWhileInst (BLOCK (ALT DO '{' (+ (BLOCK (ALT inst))) '}' WHILE '(' condition ')' ';'))) (RULE whileInst (BLOCK (ALT WHILE '(' condition ')' DO '{' (+ (BLOCK (ALT inst))) '}'))) (RULE ifInst (BLOCK (ALT IF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' (? (BLOCK (ALT elseIfInst))) (? (BLOCK (ALT elseInst)))))) (RULE elseIfInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}' elseIfInst) (ALT (* (BLOCK (ALT COMMENT))) ELSIF '(' condition ')' THEN '{' (+ (BLOCK (ALT inst))) '}'))) (RULE elseInst (BLOCK (ALT (* (BLOCK (ALT COMMENT))) ELSE '{' (+ (BLOCK (ALT inst))) '}'))) (RULE switchInst (BLOCK (ALT SWITCH '(' IDF ')' '{' caseInst '}'))) (RULE caseInst (BLOCK (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' defaultInst) (ALT CASE number ':' (+ (BLOCK (ALT inst))) BREAK ';' caseInst))) (RULE defaultInst (BLOCK (ALT DEFAULT ':' (+ (BLOCK (ALT inst))) BREAK ';'))) (RULE condition (BLOCK (ALT '(' condition ')') (ALT '!' '(' condition ')') (ALT condition logicalOperator condition) (ALT partCondition))) (RULE partCondition (BLOCK (ALT IDF COMPARAISONOPERATOR arithmeticExpression))) (RULE logicalOperator (BLOCK (ALT (SET AND OR NOT))))))
2025-03-18 14:01:08:266 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR ExprLexer (@ header {
  import java.util.HashMap;
  import java.util.Map;
}) (@ lexer members {
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }

}) (RULES (RULE T__0 (BLOCK (ALT ';'))) (RULE T__1 (BLOCK (ALT ','))) (RULE T__2 (BLOCK (ALT ':'))) (RULE T__3 (BLOCK (ALT '='))) (RULE T__4 (BLOCK (ALT '('))) (RULE T__5 (BLOCK (ALT ')'))) (RULE T__6 (BLOCK (ALT '['))) (RULE T__7 (BLOCK (ALT ']'))) (RULE LETTER (RULEMODIFIERS fragment) (BLOCK (ALT [a-zA-Z]))) (RULE DIGIT (RULEMODIFIERS fragment) (BLOCK (ALT [0-9]))) (RULE ALPHANUMERICAL (RULEMODIFIERS fragment) (BLOCK (ALT LETTER) (ALT DIGIT))) (RULE INLINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '<!-' (* (BLOCK (ALT (~ (SET [\n]))))) '-!>'))) (RULE MULTILINECOMMENT (RULEMODIFIERS fragment) (BLOCK (ALT '{--' (* (BLOCK (ALT .))) '--}'))) (RULE INPUT (BLOCK (ALT 'input'))) (RULE OUTPUT (BLOCK (ALT 'output'))) (RULE TYPE (BLOCK (ALT 'Int') (ALT 'Float') (ALT 'Bool') (ALT 'String') (ALT 'Char' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE MAIN (BLOCK (ALT 'MainPrgm' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE VAR (BLOCK (ALT 'Var' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE BEGIN (BLOCK (ALT 'BeginPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE END (BLOCK (ALT 'EndPg' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IF (BLOCK (ALT 'if' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSE (BLOCK (ALT 'else' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE ELSIF (BLOCK (ALT 'elsif'))) (RULE THEN (BLOCK (ALT 'then' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE WHILE (BLOCK (ALT 'while' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DO (BLOCK (ALT 'do' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FOR (BLOCK (ALT 'for' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE FROM (BLOCK (ALT 'from' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE TO (BLOCK (ALT 'to' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE STEP (BLOCK (ALT 'step' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE AND (BLOCK (ALT 'AND' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE OR (BLOCK (ALT 'OR' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE LET (BLOCK (ALT 'let' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE DEFINE (BLOCK (ALT '@Define' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE CONST (BLOCK (ALT 'const' {printToken(getText(),"Keyword",getLine(),getCharPositionInLine());}))) (RULE IDF (BLOCK (ALT (+ (BLOCK (ALT LETTER))) (* (BLOCK (ALT (+ (BLOCK (ALT ALPHANUMERICAL))) (* (BLOCK (ALT '_' (+ (BLOCK (ALT ALPHANUMERICAL))))))))) {validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());}))) (RULE INT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) {validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());}))) (RULE FLOAT (BLOCK (ALT (+ (BLOCK (ALT DIGIT))) '.' (+ (BLOCK (ALT DIGIT)))) (ALT '.' (+ (BLOCK (ALT DIGIT)))) (ALT (+ (BLOCK (ALT DIGIT))) '.' {printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());}))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["\n]))))) '"' {printToken(getText(),"String Constant",getLine(),getCharPositionInLine());}))) (RULE AFFECT (BLOCK (ALT ':='))) (RULE NOT (BLOCK (ALT '!'))) (RULE COMPARAISONOPERATOR (BLOCK (ALT '<') (ALT '>') (ALT '>=') (ALT '<=') (ALT '==') (ALT '!='))) (RULE LBRACE (BLOCK (ALT '{'))) (RULE RBRACE (BLOCK (ALT '}'))) (RULE PLUS (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE Separators (BLOCK (ALT '(') (ALT ')') (ALT '=') (ALT ';') (ALT '[') (ALT ']') (ALT ':') (ALT ',') (ALT COMPARAISONOPERATOR {printToken(getText(),"Separator",getLine(),getCharPositionInLine());}))) (RULE COMMENT (BLOCK (ALT MULTILINECOMMENT) (ALT INLINECOMMENT {printToken(getText(),"Comment",getLine(),getCharPositionInLine());}))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE ERROR_TOKEN (BLOCK (ALT . {System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());
//System.exit(1);
})))))
2025-03-18 14:01:08:470 action-translator LogManager.java:25 translate 
 
public void printToken(String token , String type, int line , int column) {
    System.out.println("Matched "+type+": "+token+" at line " + line + ", column " + column);
 }

  public void validateIntToken(String token , int min ,int max, int line , int column){
  
    int value = Integer.parseInt(token);
    if(value<min || value >max) {
    System.err.println("Error: Int Constant "+ token + " exceeds maximum value range of [" +min+"," +max+"] At line "+ line+" Column "+column);
    //System.exit(1);
   }
  else {
    printToken(token,"Int Constant",line,column);
  }
 }

 public void validateIDFToken(String token , int maxLength , int line , int column){
    column = column - token.length() + 1;
    if(token.length()>14){
      System.err.println("Error: Identifier "+ token + " exceeds maximum length of " + maxLength + " At line "+ line+" Column "+column);
      IDF_HashTable.table.updateError(token,"Identifier exceeds maximum length of " + maxLength);
      //System.exit(1);
    }
    else {
      printToken(token,"Identifier",line,column);
      IDF_HashTable.table.insert(token);
    }
 }


2025-03-18 14:01:08:471 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-18 14:01:08:490 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:490 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:490 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:490 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:490 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:490 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:490 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:490 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:490 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:490 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:491 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:491 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:491 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:491 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:491 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:491 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:491 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:491 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:491 action-translator LogManager.java:25 translate printToken(getText(),"Keyword",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:491 action-translator LogManager.java:25 translate validateIDFToken(getText(), 14,getLine(), getCharPositionInLine());
2025-03-18 14:01:08:491 action-translator LogManager.java:25 translate validateIntToken(getText(), -32768,32767,getLine(), getCharPositionInLine());
2025-03-18 14:01:08:491 action-translator LogManager.java:25 translate printToken(getText(),"Float Constant",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:492 action-translator LogManager.java:25 translate printToken(getText(),"String Constant",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:492 action-translator LogManager.java:25 translate printToken(getText(),"Separator",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:492 action-translator LogManager.java:25 translate printToken(getText(),"Comment",getLine(),getCharPositionInLine());
2025-03-18 14:01:08:492 action-translator LogManager.java:25 translate System.err.println("Error: Unknown Token "+ getText() + " At line "+ getLine()+" Column "+getCharPositionInLine());
//System.exit(1);

2025-03-18 14:01:08:588 left-recursion LogManager.java:25 arithmeticExpression
    :   ( {} '('<tokenIndex=883> arithmeticExpression<tokenIndex=885> ')'<tokenIndex=887> 
        | operator<tokenIndex=891> 
        )
        (
          {precpred(_ctx, 3)}?<p=3> operation<tokenIndex=877> arithmeticExpression<tokenIndex=879,p=4>
        )*
    ;
2025-03-18 14:01:08:593 grammar LogManager.java:25 added: (RULE arithmeticExpression (BLOCK (ALT (BLOCK (ALT {} ('(' (ELEMENT_OPTIONS (= tokenIndex 883))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 885))) (')' (ELEMENT_OPTIONS (= tokenIndex 887)))) (ALT (operator (ELEMENT_OPTIONS (= tokenIndex 891))))) (* (BLOCK (ALT ({precpred(_ctx, 3)}? (ELEMENT_OPTIONS (= p 3))) (operation (ELEMENT_OPTIONS (= tokenIndex 877))) (arithmeticExpression (ELEMENT_OPTIONS (= tokenIndex 879) (= p 4)))))))))
2025-03-18 14:01:08:596 left-recursion LogManager.java:25 condition
    :   ( {} '('<tokenIndex=1180> condition<tokenIndex=1182> ')'<tokenIndex=1184> 
        | '!'<tokenIndex=1188> '('<tokenIndex=1190> condition<tokenIndex=1192> ')'<tokenIndex=1194> 
        | partCondition<tokenIndex=1206> 
        )
        (
          {precpred(_ctx, 2)}?<p=2> logicalOperator<tokenIndex=1200> condition<tokenIndex=1202,p=3>
        )*
    ;
2025-03-18 14:01:08:599 grammar LogManager.java:25 added: (RULE condition (BLOCK (ALT (BLOCK (ALT {} ('(' (ELEMENT_OPTIONS (= tokenIndex 1180))) (condition (ELEMENT_OPTIONS (= tokenIndex 1182))) (')' (ELEMENT_OPTIONS (= tokenIndex 1184)))) (ALT ('!' (ELEMENT_OPTIONS (= tokenIndex 1188))) ('(' (ELEMENT_OPTIONS (= tokenIndex 1190))) (condition (ELEMENT_OPTIONS (= tokenIndex 1192))) (')' (ELEMENT_OPTIONS (= tokenIndex 1194)))) (ALT (partCondition (ELEMENT_OPTIONS (= tokenIndex 1206))))) (* (BLOCK (ALT ({precpred(_ctx, 2)}? (ELEMENT_OPTIONS (= p 2))) (logicalOperator (ELEMENT_OPTIONS (= tokenIndex 1200))) (condition (ELEMENT_OPTIONS (= tokenIndex 1202) (= p 3)))))))))
2025-03-18 14:01:08:602 semantics LogManager.java:25 tokens={EOF=-1, T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, INPUT=9, OUTPUT=10, TYPE=11, MAIN=12, VAR=13, BEGIN=14, END=15, IF=16, ELSE=17, ELSIF=18, THEN=19, SWITCH=20, CASE=21, BREAK=22, DEFAULT=23, WHILE=24, DO=25, FOR=26, FROM=27, TO=28, STEP=29, AND=30, OR=31, LET=32, DEFINE=33, CONST=34, IDF=35, INT=36, FLOAT=37, STRING=38, AFFECT=39, NOT=40, COMPARAISONOPERATOR=41, LBRACE=42, RBRACE=43, PLUS=44, SUB=45, MUL=46, DIV=47, Separators=48, COMMENT=49, WS=50, ERROR_TOKEN=51}
2025-03-18 14:01:08:602 semantics LogManager.java:25 strings={';'=1, ','=2, ':'=3, '='=4, '('=5, ')'=6, '['=7, ']'=8, 'input'=9, 'output'=10, 'MainPrgm'=12, 'Var'=13, 'BeginPg'=14, 'EndPg'=15, 'if'=16, 'else'=17, 'elsif'=18, 'then'=19, 'switch'=20, 'case'=21, 'break'=22, 'default'=23, 'while'=24, 'do'=25, 'for'=26, 'from'=27, 'to'=28, 'step'=29, 'AND'=30, 'OR'=31, 'let'=32, '@Define'=33, 'const'=34, ':='=39, '!'=40, '{'=42, '}'=43, '+'=44, '-'=45, '*'=46, '/'=47}
2025-03-18 14:01:08:621 LL1 LogManager.java:25 
DECISION 0 in rule prog
2025-03-18 14:01:08:621 LL1 LogManager.java:25 look=[49, 12]
2025-03-18 14:01:08:621 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:621 LL1 LogManager.java:25 
DECISION 1 in rule prog
2025-03-18 14:01:08:621 LL1 LogManager.java:25 look=[49, 13]
2025-03-18 14:01:08:621 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:621 LL1 LogManager.java:25 
DECISION 2 in rule prog
2025-03-18 14:01:08:621 LL1 LogManager.java:25 look=[49, 14]
2025-03-18 14:01:08:621 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:621 LL1 LogManager.java:25 
DECISION 3 in rule prog
2025-03-18 14:01:08:621 LL1 LogManager.java:25 look=[49, <EOF>]
2025-03-18 14:01:08:621 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:621 LL1 LogManager.java:25 
DECISION 4 in rule varBlock
2025-03-18 14:01:08:622 LL1 LogManager.java:25 look=[{32..33, 49}, {14, 49}]
2025-03-18 14:01:08:622 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:622 LL1 LogManager.java:25 
DECISION 5 in rule varBlock
2025-03-18 14:01:08:622 LL1 LogManager.java:25 look=[13, 13]
2025-03-18 14:01:08:622 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:622 LL1 LogManager.java:25 
DECISION 6 in rule declaration
2025-03-18 14:01:08:622 LL1 LogManager.java:25 look=[{32..33}, {32..33}, 49]
2025-03-18 14:01:08:622 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:622 LL1 LogManager.java:25 
DECISION 7 in rule listIDF
2025-03-18 14:01:08:622 LL1 LogManager.java:25 look=[2, {3, 6}]
2025-03-18 14:01:08:622 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:622 LL1 LogManager.java:25 
DECISION 8 in rule normalDeclaration
2025-03-18 14:01:08:622 LL1 LogManager.java:25 look=[{32..33}, {32..33}]
2025-03-18 14:01:08:622 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:622 LL1 LogManager.java:25 
DECISION 9 in rule number
2025-03-18 14:01:08:622 LL1 LogManager.java:25 look=[5, 5, 36, 37]
2025-03-18 14:01:08:622 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:622 LL1 LogManager.java:25 
DECISION 10 in rule arrayDeclaration
2025-03-18 14:01:08:622 LL1 LogManager.java:25 look=[{32..33}, {32..33}]
2025-03-18 14:01:08:622 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:622 LL1 LogManager.java:25 
DECISION 11 in rule declarationKeyword
2025-03-18 14:01:08:622 LL1 LogManager.java:25 look=[33, 32]
2025-03-18 14:01:08:622 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:622 LL1 LogManager.java:25 
DECISION 12 in rule listNumber
2025-03-18 14:01:08:622 LL1 LogManager.java:25 look=[2, 43]
2025-03-18 14:01:08:622 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:623 LL1 LogManager.java:25 
DECISION 13 in rule mainCode
2025-03-18 14:01:08:623 LL1 LogManager.java:25 look=[49, 42]
2025-03-18 14:01:08:623 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:623 LL1 LogManager.java:25 
DECISION 14 in rule mainCode
2025-03-18 14:01:08:623 LL1 LogManager.java:25 look=[{9..10, 16, 20, 24..26, 35, 49}, 43]
2025-03-18 14:01:08:623 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:623 LL1 LogManager.java:25 
DECISION 15 in rule mainCode
2025-03-18 14:01:08:623 LL1 LogManager.java:25 look=[49, 15]
2025-03-18 14:01:08:623 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:623 LL1 LogManager.java:25 
DECISION 16 in rule mainCode
2025-03-18 14:01:08:623 LL1 LogManager.java:25 look=[49, 42]
2025-03-18 14:01:08:623 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:623 LL1 LogManager.java:25 
DECISION 17 in rule mainCode
2025-03-18 14:01:08:623 LL1 LogManager.java:25 look=[49, 15]
2025-03-18 14:01:08:623 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:623 LL1 LogManager.java:25 
DECISION 18 in rule mainCode
2025-03-18 14:01:08:623 LL1 LogManager.java:25 look=[14, 14]
2025-03-18 14:01:08:623 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:623 LL1 LogManager.java:25 
DECISION 19 in rule inst
2025-03-18 14:01:08:624 LL1 LogManager.java:25 look=[10, 9, 35, 49, 26, 25, 24, 16, 20]
2025-03-18 14:01:08:624 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:624 LL1 LogManager.java:25 
DECISION 20 in rule content
2025-03-18 14:01:08:624 LL1 LogManager.java:25 look=[{35, 38}, {35, 38}]
2025-03-18 14:01:08:624 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:624 LL1 LogManager.java:25 
DECISION 21 in rule content
2025-03-18 14:01:08:624 LL1 LogManager.java:25 look=[{35, 38}, {35, 38}]
2025-03-18 14:01:08:624 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:624 LL1 LogManager.java:25 
DECISION 22 in rule arithmeticExpression
2025-03-18 14:01:08:624 LL1 LogManager.java:25 look=[5, {5, 35..37}]
2025-03-18 14:01:08:624 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:624 LL1 LogManager.java:25 
DECISION 23 in rule arithmeticExpression
2025-03-18 14:01:08:624 LL1 LogManager.java:25 look=[null, null]
2025-03-18 14:01:08:624 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:624 LL1 LogManager.java:25 
DECISION 24 in rule operator
2025-03-18 14:01:08:624 LL1 LogManager.java:25 look=[{5, 36..37}, 35]
2025-03-18 14:01:08:624 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:624 LL1 LogManager.java:25 
DECISION 25 in rule var
2025-03-18 14:01:08:624 LL1 LogManager.java:25 look=[35, 35]
2025-03-18 14:01:08:624 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:624 LL1 LogManager.java:25 
DECISION 26 in rule forInst
2025-03-18 14:01:08:624 LL1 LogManager.java:25 look=[{44..47}, 27]
2025-03-18 14:01:08:624 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:624 LL1 LogManager.java:25 
DECISION 27 in rule forInst
2025-03-18 14:01:08:624 LL1 LogManager.java:25 look=[{9..10, 16, 20, 24..26, 35, 49}, 43]
2025-03-18 14:01:08:624 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:624 LL1 LogManager.java:25 
DECISION 28 in rule doWhileInst
2025-03-18 14:01:08:624 LL1 LogManager.java:25 look=[{9..10, 16, 20, 24..26, 35, 49}, 43]
2025-03-18 14:01:08:625 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:625 LL1 LogManager.java:25 
DECISION 29 in rule whileInst
2025-03-18 14:01:08:625 LL1 LogManager.java:25 look=[{9..10, 16, 20, 24..26, 35, 49}, 43]
2025-03-18 14:01:08:625 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:625 LL1 LogManager.java:25 
DECISION 30 in rule ifInst
2025-03-18 14:01:08:625 LL1 LogManager.java:25 look=[{9..10, 16, 20, 24..26, 35, 49}, 43]
2025-03-18 14:01:08:625 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:625 LL1 LogManager.java:25 
DECISION 31 in rule ifInst
2025-03-18 14:01:08:626 LL1 LogManager.java:25 look=[{18, 49}, {9..10, 16..17, 20, 22, 24..26, 35, 43, 49}]
2025-03-18 14:01:08:626 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:626 LL1 LogManager.java:25 
DECISION 32 in rule ifInst
2025-03-18 14:01:08:627 LL1 LogManager.java:25 look=[{17, 49}, {9..10, 16, 20, 22, 24..26, 35, 43, 49}]
2025-03-18 14:01:08:627 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:627 LL1 LogManager.java:25 
DECISION 33 in rule elseIfInst
2025-03-18 14:01:08:627 LL1 LogManager.java:25 look=[49, 18]
2025-03-18 14:01:08:627 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:627 LL1 LogManager.java:25 
DECISION 34 in rule elseIfInst
2025-03-18 14:01:08:627 LL1 LogManager.java:25 look=[{9..10, 16, 20, 24..26, 35, 49}, 43]
2025-03-18 14:01:08:627 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:627 LL1 LogManager.java:25 
DECISION 35 in rule elseIfInst
2025-03-18 14:01:08:627 LL1 LogManager.java:25 look=[49, 18]
2025-03-18 14:01:08:627 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:627 LL1 LogManager.java:25 
DECISION 36 in rule elseIfInst
2025-03-18 14:01:08:627 LL1 LogManager.java:25 look=[{9..10, 16, 20, 24..26, 35, 49}, 43]
2025-03-18 14:01:08:627 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:627 LL1 LogManager.java:25 
DECISION 37 in rule elseIfInst
2025-03-18 14:01:08:628 LL1 LogManager.java:25 look=[{18, 49}, {18, 49}]
2025-03-18 14:01:08:628 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:628 LL1 LogManager.java:25 
DECISION 38 in rule elseInst
2025-03-18 14:01:08:628 LL1 LogManager.java:25 look=[49, 17]
2025-03-18 14:01:08:628 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:628 LL1 LogManager.java:25 
DECISION 39 in rule elseInst
2025-03-18 14:01:08:628 LL1 LogManager.java:25 look=[{9..10, 16, 20, 24..26, 35, 49}, 43]
2025-03-18 14:01:08:628 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:628 LL1 LogManager.java:25 
DECISION 40 in rule caseInst
2025-03-18 14:01:08:628 LL1 LogManager.java:25 look=[{9..10, 16, 20, 24..26, 35, 49}, 22]
2025-03-18 14:01:08:628 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:628 LL1 LogManager.java:25 
DECISION 41 in rule caseInst
2025-03-18 14:01:08:628 LL1 LogManager.java:25 look=[{9..10, 16, 20, 24..26, 35, 49}, 22]
2025-03-18 14:01:08:628 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:628 LL1 LogManager.java:25 
DECISION 42 in rule caseInst
2025-03-18 14:01:08:628 LL1 LogManager.java:25 look=[21, 21]
2025-03-18 14:01:08:628 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:628 LL1 LogManager.java:25 
DECISION 43 in rule defaultInst
2025-03-18 14:01:08:628 LL1 LogManager.java:25 look=[{9..10, 16, 20, 24..26, 35, 49}, 22]
2025-03-18 14:01:08:628 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:628 LL1 LogManager.java:25 
DECISION 44 in rule condition
2025-03-18 14:01:08:628 LL1 LogManager.java:25 look=[5, 40, 35]
2025-03-18 14:01:08:628 LL1 LogManager.java:25 LL(1)? true
2025-03-18 14:01:08:628 LL1 LogManager.java:25 
DECISION 45 in rule condition
2025-03-18 14:01:08:628 LL1 LogManager.java:25 look=[null, null]
2025-03-18 14:01:08:628 LL1 LogManager.java:25 LL(1)? false
2025-03-18 14:01:08:630 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-18 14:01:08:645 action-translator LogManager.java:25 translate IDF_HashTable.table.printTable();
2025-03-18 14:01:08:650 action-translator LogManager.java:25 translate 
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateTypeValue(idf.trim(), $TYPE.text,$affectValue.text,$affectValue.type);
    }

2025-03-18 14:01:08:650 action-translator LogManager.java:25 qattr [@-1,25:31='listIDF',<0>,112:23].[@-1,33:36='text',<0>,112:31]
2025-03-18 14:01:08:652 action-translator LogManager.java:25 qattr [@-1,111:114='TYPE',<0>,113:57].[@-1,116:119='text',<0>,113:62]
2025-03-18 14:01:08:653 action-translator LogManager.java:25 qattr [@-1,122:132='affectValue',<0>,113:68].[@-1,134:137='text',<0>,113:80]
2025-03-18 14:01:08:653 action-translator LogManager.java:25 qattr [@-1,140:150='affectValue',<0>,113:86].[@-1,152:155='type',<0>,113:98]
2025-03-18 14:01:08:654 action-translator LogManager.java:25 translate 
    for (String idf : $listIDF.text.split(",")) { 
        IDF_HashTable.table.updateType(idf.trim(), $TYPE.text);
    }

2025-03-18 14:01:08:654 action-translator LogManager.java:25 qattr [@-1,25:31='listIDF',<0>,118:23].[@-1,33:36='text',<0>,118:31]
2025-03-18 14:01:08:654 action-translator LogManager.java:25 qattr [@-1,106:109='TYPE',<0>,119:52].[@-1,111:114='text',<0>,119:57]
2025-03-18 14:01:08:655 action-translator LogManager.java:25 translate $type = $number.type;
2025-03-18 14:01:08:656 action-translator LogManager.java:25 setAttr [@-1,1:4='type',<0>,123:46] [@-1,7:19=' $number.type',<0>,123:52]
2025-03-18 14:01:08:656 action-translator LogManager.java:25 translate  $number.type
2025-03-18 14:01:08:656 action-translator LogManager.java:25 qattr [@-1,2:7='number',<0>,123:47].[@-1,9:12='type',<0>,123:54]
2025-03-18 14:01:08:657 action-translator LogManager.java:25 translate  $type = "INT"; 
2025-03-18 14:01:08:657 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,124:49] [@-1,8:13=' "INT"',<0>,124:55]
2025-03-18 14:01:08:657 action-translator LogManager.java:25 translate  "INT"
2025-03-18 14:01:08:657 action-translator LogManager.java:25 translate  $type = "FLOAT"; 
2025-03-18 14:01:08:657 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,124:89] [@-1,8:15=' "FLOAT"',<0>,124:95]
2025-03-18 14:01:08:657 action-translator LogManager.java:25 translate  "FLOAT"
2025-03-18 14:01:08:657 action-translator LogManager.java:25 translate  $type = "INT"; 
2025-03-18 14:01:08:658 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,124:116] [@-1,8:13=' "INT"',<0>,124:122]
2025-03-18 14:01:08:658 action-translator LogManager.java:25 translate  "INT"
2025-03-18 14:01:08:658 action-translator LogManager.java:25 translate  $type = "FLOAT"; 
2025-03-18 14:01:08:658 action-translator LogManager.java:25 setAttr [@-1,2:5='type',<0>,124:144] [@-1,8:15=' "FLOAT"',<0>,124:150]
2025-03-18 14:01:08:658 action-translator LogManager.java:25 translate  "FLOAT"
2025-03-18 14:01:08:666 action-translator LogManager.java:25 translate 
2025-03-18 14:01:08:668 action-translator LogManager.java:25 translate precpred(_ctx, 3)
2025-03-18 14:01:08:669 action-translator LogManager.java:25 translate precpred(_ctx, 3)
2025-03-18 14:01:08:681 action-translator LogManager.java:25 translate 
2025-03-18 14:01:08:684 action-translator LogManager.java:25 translate precpred(_ctx, 2)
2025-03-18 14:01:08:685 action-translator LogManager.java:25 translate precpred(_ctx, 2)
2025-03-18 14:01:08:819 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-18 14:01:08:819 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-18 14:01:08:825 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

2025-03-18 14:01:08:825 action-translator LogManager.java:25 translate 
  import java.util.HashMap;
  import java.util.Map;

